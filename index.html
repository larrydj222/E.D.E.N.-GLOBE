<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAP E.D.E.N. Globe</title>

  <style>
    :root{
      --glass: rgba(12,14,18,0.58);
      --stroke: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.68);
      --muted2: rgba(255,255,255,0.45);
    }

    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw !important; height:100vh !important; touch-action:none; }

    /* Floating OPEN button */
    #openBtn{
      position: fixed;
      left: 18px;
      bottom: 18px;
      z-index: 10000;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 12px 14px;
      border-radius: 18px;
      color: var(--text);
      background: rgba(12,14,18,0.62);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.42);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #openBtn:active { transform: translateY(1px); }
    #openBtn svg { width: 16px; height: 16px; opacity: 0.9; }

    /* Bottom Drawer */
    #drawer {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      width: min(720px, calc(100vw - 28px));
      z-index: 9999;
      color: var(--text);
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: 22px;
      padding: 14px 14px 16px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.42);
      user-select: none;
    }
    #drawer.closed{
      transform: translateX(-50%) translateY(140%);
      opacity: 0;
      pointer-events: none;
      transition: transform 240ms ease, opacity 200ms ease;
    }
    #drawer:not(.closed){
      transition: transform 240ms ease, opacity 200ms ease;
    }
    #drawerTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    #titleBlock{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    #title {
      font: 700 18px/1.1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.2px;
    }
    #subtitle{
      font: 500 12px/1.25 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: var(--muted);
    }
    #handle {
      width: 44px;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      margin: 6px auto 10px;
      cursor: pointer;
    }
    #closeBtn{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color: transparent;
      flex: 0 0 auto;
    }
    #closeBtn:active { transform: translateY(1px); }

    #rowWrap { display:flex; flex-direction:column; gap:10px; margin-top: 10px; }
    .row { display:flex; flex-wrap:wrap; gap:10px; }
    .pill {
      flex: 1 1 calc(50% - 10px); /* two columns */
      display:inline-flex;
      align-items:center;
      justify-content:flex-start;
      gap:10px;
      padding: 12px 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font: 700 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.15px;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      min-width: 0;
    }
    .pill:active { transform: translateY(1px); }

    .pill.spacer{
      pointer-events:none;
      opacity:0;
      border-color:transparent;
      background:transparent;
    }

    .dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: rgba(255,255,255,0.18);
      box-shadow: 0 0 0 rgba(0,0,0,0);
      flex: 0 0 auto;
    }
    .pill.on .dot {
      background: rgba(120,255,200,0.88);
      box-shadow: 0 0 18px rgba(120,255,200,0.35);
    }
    /* color hints */
    .pill.on[data-key="rhumbLine"] .dot{ background: rgba(246,194,74,0.95); box-shadow:0 0 18px rgba(246,194,74,0.35); }
    .pill.on[data-key="geodesicLine"] .dot{ background: rgba(91,188,255,0.92); box-shadow:0 0 18px rgba(91,188,255,0.30); }
    .pill.on[data-key="corridors"] .dot{ background: rgba(246,194,74,0.65); box-shadow:0 0 18px rgba(246,194,74,0.24); }
    .pill.on[data-key="perpLine"] .dot{ background: rgba(91,188,255,0.90); box-shadow:0 0 18px rgba(91,188,255,0.30); }
    .pill.on[data-key="aurora"] .dot{ background: rgba(160,120,255,0.90); box-shadow:0 0 18px rgba(160,120,255,0.30); }
    .pill.on[data-key="magField"] .dot{ background: rgba(91,188,255,0.75); box-shadow:0 0 18px rgba(91,188,255,0.22); }
    .pill.on[data-key="continents"] .dot{ background: rgba(255,255,255,0.75); box-shadow:0 0 18px rgba(255,255,255,0.18); }

    #statusLine{
      margin-top:10px;
      color: var(--muted2);
      font: 600 11px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      display:flex;
      justify-content:space-between;
      gap:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    #errors{
      margin-top: 10px;
      display:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,120,120,0.22);
      background: rgba(80,10,10,0.35);
      color: rgba(255,170,170,0.95);
      font: 600 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre-wrap;
    }

    #drawer.collapsed #rowWrap,
    #drawer.collapsed #statusLine,
    #drawer.collapsed #errors { display:none; }
    #drawer.collapsed { padding-bottom: 12px; }

    @media (max-width: 420px){
      .pill { padding: 12px 12px; border-radius: 16px; font-size: 13px; }
    }
  </style>
</head>

<body>
  <button id="openBtn" aria-label="Open layers">
    <svg viewBox="0 0 24 24" fill="none">
      <path d="M4 7h16M4 12h16M4 17h16" stroke="rgba(255,255,255,0.88)" stroke-width="2.2" stroke-linecap="round"/>
    </svg>
    Layers
  </button>

  <div id="drawer">
    <div id="handle" title="Tap to collapse/expand"></div>

    <div id="drawerTop">
      <div id="titleBlock">
        <div id="title">MAP E.D.E.N.</div>
        <div id="subtitle">Tap to toggle layers • Drag globe to rotate • Pinch to zoom</div>
      </div>
      <button id="closeBtn" aria-label="Close drawer" title="Close">✕</button>
    </div>

    <!-- ✅ Toggle layout matches your screenshot (two columns; Continents now same size) -->
    <div id="rowWrap">
      <div class="row">
        <button class="pill on" data-key="rhumbLine"><span class="dot"></span>Rhumb 222°</button>
        <button class="pill" data-key="rhumbName"><span class="dot"></span>Rhumb Name</button>
      </div>

      <div class="row">
        <button class="pill on" data-key="geodesicLine"><span class="dot"></span>Geodesic 222°</button>
        <button class="pill" data-key="geoName"><span class="dot"></span>Geo Name</button>
      </div>

      <div class="row">
        <button class="pill" data-key="perpLine"><span class="dot"></span>Perpendiculars</button>
        <button class="pill" data-key="perpName"><span class="dot"></span>Perp Name</button>
      </div>

      <div class="row">
        <button class="pill" data-key="continents"><span class="dot"></span>Continents</button>
        <button class="pill spacer" type="button" aria-hidden="true" tabindex="-1"></button>
      </div>

      <div class="row">
        <button class="pill on" data-key="stations"><span class="dot"></span>Stations</button>
        <button class="pill" data-key="corridors"><span class="dot"></span>Corridors</button>
      </div>

      <div class="row">
        <button class="pill" data-key="magField"><span class="dot"></span>Magnetic Field</button>
        <button class="pill" data-key="aurora"><span class="dot"></span>Aurora</button>
      </div>

      <div id="statusLine">
        <span id="status">Booting…</span>
        <span id="hint">Tip: With Stations ON, tap globe to drop a Future Station (saved).</span>
      </div>

      <div id="errors"></div>
    </div>
  </div>

  <script type="module">
    // ---------- Error capture ----------
    const statusEl = document.getElementById("status");
    const errorsEl = document.getElementById("errors");
    const drawerEl = document.getElementById("drawer");
    const openBtn = document.getElementById("openBtn");
    const closeBtn = document.getElementById("closeBtn");
    const handle = document.getElementById("handle");

    function showError(msg){
      errorsEl.style.display = "block";
      errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
      statusEl.textContent = "Error (see panel)";
    }
    window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
    window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

    // Drawer open/close
    function setDrawerClosed(isClosed){
      drawerEl.classList.toggle("closed", !!isClosed);
      openBtn.style.display = isClosed ? "inline-flex" : "none";
    }
    setDrawerClosed(false);
    openBtn.addEventListener("click", () => setDrawerClosed(false));
    closeBtn.addEventListener("click", () => setDrawerClosed(true));
    handle.addEventListener("click", () => drawerEl.classList.toggle("collapsed"));

    // ---------- Robust THREE import (tries local first, then CDNs) ----------
    async function importThree(){
      const candidates = [
        "./vendor/three.module.js", // ✅ best: commit this file in your repo
        "https://unpkg.com/three@0.161.0/build/three.module.js",
        "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js"
      ];
      let lastErr = null;
      for (const url of candidates){
        try{
          const mod = await import(url);
          statusEl.textContent = "Running";
          return mod;
        }catch(e){ lastErr = e; }
      }
      throw lastErr || new Error("Failed to import THREE from all sources.");
    }

    const THREE = await importThree();

    // ---------- Helpers ----------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const DEG = Math.PI / 180;
    const RAD = 180 / Math.PI;

    function isUIEventTarget(target){
      return !!(target && (target.closest?.("#drawer") || target.closest?.("#openBtn")));
    }
    function latLonToVec3(latDeg, lonDeg, radius=1.0){
      const lat = latDeg * DEG;
      const lon = lonDeg * DEG;
      const x = radius * Math.cos(lat) * Math.cos(lon);
      const y = radius * Math.sin(lat);
      const z = radius * Math.cos(lat) * Math.sin(lon);
      return new THREE.Vector3(x,y,z);
    }
    function vec3ToLatLon(v){
      const r = v.length();
      const lat = Math.asin(v.y / r) * RAD;
      const lon = Math.atan2(v.z, v.x) * RAD;
      return { lat, lon };
    }

    function greatCirclePoints(lat0Deg, lon0Deg, bearingDeg, stepDeg=1.0){
      const lat0 = lat0Deg * DEG;
      const lon0 = lon0Deg * DEG;
      const brng = bearingDeg * DEG;
      const pts = [];
      for(let d=-180; d<=180; d+=stepDeg){
        const δ = d * DEG;
        const sinLat = Math.sin(lat0)*Math.cos(δ) + Math.cos(lat0)*Math.sin(δ)*Math.cos(brng);
        const lat = Math.asin(clamp(sinLat, -1, 1));
        const y = Math.sin(brng)*Math.sin(δ)*Math.cos(lat0);
        const x = Math.cos(δ) - Math.sin(lat0)*Math.sin(lat);
        const lon = lon0 + Math.atan2(y, x);
        pts.push({ lat: lat*RAD, lon: ((lon*RAD + 540) % 360) - 180 });
      }
      return pts;
    }

    function rhumbPoints(lat0Deg, lon0Deg, bearingDeg, stepKm=240){
      const R = 6371;
      const φ1 = lat0Deg * DEG;
      const λ1 = lon0Deg * DEG;
      const θ = bearingDeg * DEG;

      const pts = [];
      const maxSteps = 120;
      for (const dir of [-1, +1]){
        let φ = φ1, λ = λ1;
        for (let i=0; i<maxSteps; i++){
          const d = dir * (stepKm / R);
          const Δφ = d * Math.cos(θ);
          let φ2 = φ + Δφ;
          φ2 = clamp(φ2, -Math.PI/2 + 1e-6, Math.PI/2 - 1e-6);

          const Δψ = Math.log(Math.tan(Math.PI/4 + φ2/2) / Math.tan(Math.PI/4 + φ/2));
          const q = Math.abs(Δψ) > 1e-12 ? (Δφ / Δψ) : Math.cos(φ);

          const Δλ = d * Math.sin(θ) / q;
          let λ2 = λ + Δλ;
          λ2 = ((λ2 + Math.PI) % (2*Math.PI)) - Math.PI;

          pts.push({ lat: φ2*RAD, lon: λ2*RAD });
          φ = φ2; λ = λ2;
        }
      }
      return pts;
    }

    function makeGlowTube(pointsVec3, radius, color, coreOpacity=1.0, haloOpacity=0.22){
      const curve = new THREE.CatmullRomCurve3(pointsVec3, false, "catmullrom", 0.15);
      const tubular = Math.max(220, pointsVec3.length*2);

      const coreGeom = new THREE.TubeGeometry(curve, tubular, radius, 10, false);
      const haloGeom = new THREE.TubeGeometry(curve, tubular, radius*2.8, 10, false);

      const coreMat = new THREE.MeshBasicMaterial({ color, transparent: coreOpacity < 1, opacity: coreOpacity, depthWrite:false });
      const haloMat = new THREE.MeshBasicMaterial({
        color,
        transparent:true,
        opacity: haloOpacity,
        blending: THREE.AdditiveBlending,
        depthWrite:false
      });

      const g = new THREE.Group();
      g.add(new THREE.Mesh(haloGeom, haloMat));
      g.add(new THREE.Mesh(coreGeom, coreMat));
      return g;
    }

    function makeLabelSprite(text, {fontSize=34, padding=16, color="rgba(255,255,255,0.78)", bg="rgba(0,0,0,0.22)"} = {}){
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      ctx.font = `700 ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
      const metrics = ctx.measureText(text);
      const w = Math.ceil(metrics.width + padding*2);
      const h = Math.ceil(fontSize + padding*2);
      canvas.width = w; canvas.height = h;

      // rounded bg
      ctx.fillStyle = bg;
      const r = Math.min(20, h/2);
      ctx.beginPath();
      ctx.moveTo(r, 0);
      ctx.arcTo(w, 0, w, h, r);
      ctx.arcTo(w, h, 0, h, r);
      ctx.arcTo(0, h, 0, 0, r);
      ctx.arcTo(0, 0, w, 0, r);
      ctx.closePath();
      ctx.fill();

      ctx.font = `700 ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
      ctx.fillStyle = color;
      ctx.textBaseline = "middle";
      ctx.fillText(text, padding, h/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = 4;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
      const spr = new THREE.Sprite(mat);

      const scale = 0.0060;
      spr.scale.set(w*scale, h*scale, 1);
      return spr;
    }

    // ---------- Texture loader with fallback + procedural placeholders ----------
    function makeProceduralStarsTexture(){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 512;
      const ctx = c.getContext("2d");
      ctx.fillStyle = "#000"; ctx.fillRect(0,0,c.width,c.height);
      for(let i=0;i<1400;i++){
        const x = Math.random()*c.width;
        const y = Math.random()*c.height;
        const r = Math.random() < 0.9 ? 1 : 2;
        const a = Math.random()*0.85 + 0.15;
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.fillRect(x,y,r,r);
      }
      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      return t;
    }

    function makeProceduralEarthDay(){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 256;
      const ctx = c.getContext("2d");
      // ocean
      ctx.fillStyle = "#0a1a2b";
      ctx.fillRect(0,0,c.width,c.height);
      // simple lat shading
      const g = ctx.createLinearGradient(0,0,0,c.height);
      g.addColorStop(0,"rgba(255,255,255,0.08)");
      g.addColorStop(0.5,"rgba(255,255,255,0.00)");
      g.addColorStop(1,"rgba(255,255,255,0.06)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,c.width,c.height);
      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      return t;
    }

    function makeProceduralClouds(){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 256;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height);
      for(let i=0;i<1200;i++){
        const x = Math.random()*c.width;
        const y = Math.random()*c.height;
        const r = Math.random()*10 + 4;
        const a = Math.random()*0.08;
        ctx.fillStyle = `rgba(255,255,255,${a})`;
        ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      }
      const t = new THREE.CanvasTexture(c);
      t.colorSpace = THREE.SRGBColorSpace;
      return t;
    }

    async function loadTextureAny(urls, {colorSpace=THREE.SRGBColorSpace} = {}){
      const loader = new THREE.TextureLoader();
      const tryLoad = (url) => new Promise((resolve, reject) => {
        loader.load(
          url,
          (tex)=>resolve(tex),
          undefined,
          ()=>reject(new Error("Failed: " + url))
        );
      });

      let lastErr = null;
      for (const u of urls){
        try{
          const tex = await tryLoad(u);
          tex.colorSpace = colorSpace;
          return { tex, usedFallback:false, url:u };
        }catch(e){ lastErr = e; }
      }
      return { tex:null, usedFallback:true, err:lastErr };
    }

    // ---------- NEW: Continents outline as TRUE line segments (lightweight) ----------
    function makeContinentsLineSegments(earthRadius){
      // Build a low-res land mask with a few simplified blobs (recognizable; not detailed)
      const w = 240, h = 120; // keep this small for iPhone performance
      const mask = new Uint8Array(w*h);

      const setEllipse = (cx, cy, rx, ry, rot=0) => {
        const cos = Math.cos(rot), sin = Math.sin(rot);
        const x0 = Math.max(0, Math.floor(cx - rx - 2));
        const x1 = Math.min(w-1, Math.ceil(cx + rx + 2));
        const y0 = Math.max(0, Math.floor(cy - ry - 2));
        const y1 = Math.min(h-1, Math.ceil(cy + ry + 2));
        for(let y=y0; y<=y1; y++){
          for(let x=x0; x<=x1; x++){
            const dx = x - cx;
            const dy = y - cy;
            const xr = dx*cos + dy*sin;
            const yr = -dx*sin + dy*cos;
            if ((xr*xr)/(rx*rx) + (yr*yr)/(ry*ry) <= 1) mask[y*w + x] = 1;
          }
        }
      };

      // Very simplified continents in equirectangular UV space (u in [0,w), v in [0,h))
      // North America
      setEllipse(62, 34, 34, 20, -0.25);
      setEllipse(82, 52, 22, 14,  0.15);
      // South America
      setEllipse(84, 86, 16, 26,  0.25);
      // Eurasia
      setEllipse(155, 34, 56, 22, 0.05);
      setEllipse(192, 50, 32, 14, 0.25);
      // Africa
      setEllipse(142, 78, 22, 28, -0.10);
      // Australia
      setEllipse(204, 92, 18, 10, 0.10);
      // Antarctica band
      for(let y=h-10; y<h; y++){
        for(let x=0; x<w; x++) mask[y*w + x] = 1;
      }

      // Create line segments on land/ocean boundaries (grid-based contour)
      // step=2 reduces segment count and smooths jaggies
      const step = 2;
      const positions = [];

      const isLand = (x,y) => mask[y*w + x] === 1;

      function uvToVec(u, v, r){
        const lon = (u * 360.0) - 180.0;
        const lat = 90.0 - (v * 180.0);
        const p = latLonToVec3(lat, lon, r);
        return p;
      }

      const r = earthRadius * 1.008;

      for(let y=0; y<h-step; y+=step){
        for(let x=0; x<w-step; x+=step){
          const a = isLand(x,y);
          const b = isLand(x+step,y);
          const c = isLand(x,y+step);

          // vertical boundary between (x,y) and (x+step,y)
          if (a !== b){
            const u = (x+step) / w;
            const v0 = y / h;
            const v1 = (y+step) / h;
            const p0 = uvToVec(u, v0, r);
            const p1 = uvToVec(u, v1, r);
            positions.push(p0.x,p0.y,p0.z, p1.x,p1.y,p1.z);
          }

          // horizontal boundary between (x,y) and (x,y+step)
          if (a !== c){
            const v = (y+step) / h;
            const u0 = x / w;
            const u1 = (x+step) / w;
            const p0 = uvToVec(u0, v, r);
            const p1 = uvToVec(u1, v, r);
            positions.push(p0.x,p0.y,p0.z, p1.x,p1.y,p1.z);
          }
        }
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));

      // Two-layer “neon outline” without fat-line addons (still lightweight)
      const matCore = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.42,
        blending: THREE.AdditiveBlending,
        depthWrite:false
      });
      const matHalo = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.12,
        blending: THREE.AdditiveBlending,
        depthWrite:false
      });

      const core = new THREE.LineSegments(geom, matCore);
      const halo = new THREE.LineSegments(geom, matHalo);

      const g = new THREE.Group();
      g.add(halo);
      g.add(core);
      return g;
    }

    // ---------- Main init ----------
    try{
      // Scene / Camera / Renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
      camera.position.set(0, 0, 4.2);

      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.03;
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.10));
      const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
      sunLight.position.set(5, 1.5, 2.5);
      scene.add(sunLight);

      // Textures (multi-source; safe fallbacks)
      statusEl.textContent = "Loading textures…";
      const baseA = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/";
      const baseB = "https://raw.githubusercontent.com/mrdoob/three.js/r161/examples/textures/";

      const dayTry = await loadTextureAny([ baseA+"planets/earth_atmos_2048.jpg", baseB+"planets/earth_atmos_2048.jpg" ]);
      const nightTry = await loadTextureAny([ baseA+"planets/earth_lights_2048.png", baseB+"planets/earth_lights_2048.png" ]);
      const specTry = await loadTextureAny([ baseA+"planets/earth_specular_2048.jpg", baseB+"planets/earth_specular_2048.jpg" ]);
      const cloudsTry = await loadTextureAny([ baseA+"planets/earth_clouds_1024.png", baseB+"planets/earth_clouds_1024.png" ]);
      const starsTry = await loadTextureAny([ baseA+"galaxy_starfield.png", baseB+"galaxy_starfield.png" ]);

      const dayMap   = dayTry.tex   || makeProceduralEarthDay();
      const nightMap = nightTry.tex || makeProceduralEarthDay(); // acceptable fallback
      const specMap  = specTry.tex  || makeProceduralEarthDay();
      const cloudMap = cloudsTry.tex|| makeProceduralClouds();
      const starMap  = starsTry.tex || makeProceduralStarsTexture();

      if (!starsTry.tex){
        showError("Texture fallback used for: stars\n(Your CDNs blocked/failed on this device/network)");
      }

      const maxAniso = renderer.capabilities.getMaxAnisotropy?.() || 1;
      [dayMap, nightMap, specMap, cloudMap, starMap].forEach((t) => {
        t.anisotropy = maxAniso;
        t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
      });

      // Stars sphere
      {
        const starGeo = new THREE.SphereGeometry(90, 48, 48);
        const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
        scene.add(new THREE.Mesh(starGeo, starMat));
      }

      const earthRadius = 1.0;
      const SEG = 96;

      // Earth base shader (day shading)
      const earthUniforms = {
        dayMap:    { value: dayMap },
        specMap:   { value: specMap },
        sunDir:    { value: new THREE.Vector3(1,0,0) },
        cameraPos: { value: new THREE.Vector3() }
      };

      const earthMat = new THREE.ShaderMaterial({
        uniforms: earthUniforms,
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          void main(){
            vUv = uv;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vPosW = worldPos.xyz;
            vNormalW = normalize(mat3(modelMatrix) * normal);
            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `,
        fragmentShader: `
          precision highp float;
          uniform sampler2D dayMap;
          uniform sampler2D specMap;
          uniform vec3 sunDir;
          uniform vec3 cameraPos;
          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;

          vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
          vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

          void main(){
            vec3 N = normalize(vNormalW);
            vec3 L = normalize(sunDir);
            vec3 V = normalize(cameraPos - vPosW);

            vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
            float lum = dot(dayCol, vec3(0.2126,0.7152,0.0722));
            vec3 sat = mix(vec3(lum), dayCol, 1.10);
            vec3 c = pow(max(sat, 0.0), vec3(0.92));

            float specMask = texture2D(specMap, vUv).r;
            float ndl = dot(N, L);
            float dayAmt = smoothstep(-0.05, 0.15, ndl);

            vec3 nightBase = c * 0.08;
            vec3 col = mix(nightBase, c, dayAmt);

            vec3 H = normalize(L + V);
            float spec = pow(max(dot(N, H), 0.0), 80.0) * specMask * 0.45 * dayAmt;
            col += vec3(spec);

            float rim = pow(1.0 - max(dot(N, V), 0.0), 2.1);
            col += vec3(0.06, 0.10, 0.16) * rim * (0.30 + 0.70 * dayAmt);

            gl_FragColor = vec4(linearToSrgb(col), 1.0);
          }
        `
      });

      const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);

      // Night lights (additive) – visible on dark side
      const lightsUniforms = {
        nightMap: { value: nightMap },
        sunDir:   { value: new THREE.Vector3(1,0,0) },
        gain:     { value: 2.4 }
      };

      const nightLights = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
        new THREE.ShaderMaterial({
          uniforms: lightsUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            void main(){
              vUv = uv;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform sampler2D nightMap;
            uniform vec3 sunDir;
            uniform float gain;
            varying vec2 vUv;
            varying vec3 vNormalW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);
              float nightAmt = 1.0 - dayAmt;

              vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
              float mask = smoothstep(0.08, 0.35, nightAmt);

              vec3 col = lights * mask;
              float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
              gl_FragColor = vec4(linearToSrgb(col), a);
            }
          `
        })
      );

      // Cloud shadow (multiply)
      const cloudShadow = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
        new THREE.MeshBasicMaterial({
          map: cloudMap,
          color: 0x000000,
          transparent: true,
          opacity: 0.26,
          blending: THREE.MultiplyBlending,
          depthWrite: false
        })
      );

      // Clouds
      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
        new THREE.MeshLambertMaterial({
          map: cloudMap,
          transparent: true,
          opacity: 0.78,
          depthWrite: false
        })
      );

      // Atmosphere rim (additive)
      const atmoUniforms = {
        sunDir:    { value: new THREE.Vector3(1,0,0) },
        cameraPos: { value: new THREE.Vector3() }
      };

      const atmosphere = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
        new THREE.ShaderMaterial({
          uniforms: atmoUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide,
          vertexShader: `
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 3.0);
              float daySide = smoothstep(-0.15, 0.25, dot(N, L));

              vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
              float alpha = rim * (0.12 + 0.55 * daySide);
              gl_FragColor = vec4(col, alpha);
            }
          `
        })
      );

      // Rotation group
      const globe = new THREE.Group();
      globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
      scene.add(globe);

      // Overlays
      const overlays = {
        rhumbLine: new THREE.Group(),
        geodesicLine: new THREE.Group(),
        perpLine: new THREE.Group(),
        corridors: new THREE.Group(),
        rhumbName: new THREE.Group(),
        geoName: new THREE.Group(),
        perpName: new THREE.Group(),
        continents: new THREE.Group(),
        stations: new THREE.Group(),
        magField: new THREE.Group(),
        aurora: new THREE.Group()
      };
      Object.values(overlays).forEach(g => globe.add(g));

      // Anchor Station (NO address in label)
      const ANCHOR = { name: "Anchor Station • EXIT 222", lat: 38.160833, lon: -79.073056 };
      const BEARING_B = 222;

      // Lines
      const gcPts = greatCirclePoints(ANCHOR.lat, ANCHOR.lon, BEARING_B, 1.0)
        .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
      const rhPts = rhumbPoints(ANCHOR.lat, ANCHOR.lon, BEARING_B, 240)
        .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));

      overlays.geodesicLine.add(makeGlowTube(gcPts, 0.0030, 0x5bbcff, 1.0, 0.22));
      overlays.rhumbLine.add(makeGlowTube(rhPts, 0.0030, 0xf6c24a, 1.0, 0.20));

      // Corridors (±1/±5/±10 km) – lightweight halos
      const kmToUnit = (km) => (km / 6371) * earthRadius;
      const corridorRadii = [
        { km: 1,  r: kmToUnit(1),  o: 0.14 },
        { km: 5,  r: kmToUnit(5),  o: 0.08 },
        { km: 10, r: kmToUnit(10), o: 0.06 }
      ];
      for (const c of corridorRadii){
        const tubeGC = makeGlowTube(gcPts, c.r, 0xf6c24a, 0.0, c.o);
        const tubeRH = makeGlowTube(rhPts, c.r, 0xf6c24a, 0.0, c.o*0.9);
        overlays.corridors.add(tubeGC, tubeRH);
      }

      // Perpendiculars (132° / 312°)
      function arcFromBearing(bearingDeg){
        const pts = greatCirclePoints(ANCHOR.lat, ANCHOR.lon, bearingDeg, 1.2)
          .filter((_, idx) => idx > 40 && idx < 260)
          .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
        return makeGlowTube(pts, 0.0025, 0x5bbcff, 1.0, 0.18);
      }
      overlays.perpLine.add(arcFromBearing(132), arcFromBearing(312));

      // Names (smaller + dimmer)
      {
        const a = makeLabelSprite("Rhumb 222°", { fontSize: 30, color:"rgba(255,255,255,0.72)", bg:"rgba(246,194,74,0.12)" });
        a.position.copy(latLonToVec3(24, -18, earthRadius*1.12));
        overlays.rhumbName.add(a);

        const b = makeLabelSprite("Geodesic 222°", { fontSize: 30, color:"rgba(255,255,255,0.72)", bg:"rgba(91,188,255,0.12)" });
        b.position.copy(latLonToVec3(-10, 70, earthRadius*1.12));
        overlays.geoName.add(b);

        const c = makeLabelSprite("Perpendiculars 132° / 312°", { fontSize: 30, color:"rgba(255,255,255,0.70)", bg:"rgba(91,188,255,0.10)" });
        c.position.copy(latLonToVec3(55, 110, earthRadius*1.14));
        overlays.perpName.add(c);
      }

      // ✅ Continents outline as TRUE line segments (recognizable, not detailed)
      overlays.continents.add(makeContinentsLineSegments(earthRadius));

      // Stations (smaller + dimmer)
      function makeStationMarker(label, lat, lon, color=0x7fffd4){
        const g = new THREE.Group();
        const p = latLonToVec3(lat, lon, earthRadius*1.02);

        const pin = new THREE.Mesh(
          new THREE.SphereGeometry(0.007, 16, 16),
          new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.92 })
        );
        pin.position.copy(p);

        const glow = new THREE.Mesh(
          new THREE.SphereGeometry(0.014, 16, 16),
          new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.12, blending:THREE.AdditiveBlending, depthWrite:false })
        );
        glow.position.copy(p);

        const tag = makeLabelSprite(label, { fontSize: 30, color:"rgba(255,255,255,0.72)", bg:"rgba(0,0,0,0.20)" });
        tag.position.copy(latLonToVec3(lat, lon, earthRadius*1.10));

        g.add(glow, pin, tag);
        return g;
      }

      overlays.stations.add(makeStationMarker(ANCHOR.name, ANCHOR.lat, ANCHOR.lon, 0x7fffd4));

      // Future stations (tap-to-drop)
      const STORAGE_KEY = "eden_future_stations_v1";
      function loadStations(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]"); } catch { return []; } }
      function saveStations(arr){ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }
      function rebuildFutureStations(){
        while (overlays.stations.children.length > 1) overlays.stations.remove(overlays.stations.children[1]);
        const list = loadStations();
        list.forEach((s, idx) => overlays.stations.add(makeStationMarker(`Future Station ${idx+1}`, s.lat, s.lon, 0xffffff)));
      }
      rebuildFutureStations();

      // Magnetic Field (simple dipole preview)
      function makeDipoleFieldLines(){
        const g = new THREE.Group();
        const col = 0x5bbcff;
        const axis = new THREE.Vector3(0,1,0);

        const Ls = [1.6, 2.2, 3.2, 4.6];
        for (const L of Ls){
          const pts = [];
          for (let t=-80; t<=80; t+=1.4){
            const th = (90 - t) * DEG;
            const r = L * Math.sin(th)*Math.sin(th);
            const rr = earthRadius * r;
            if (rr < earthRadius*1.06) continue;
            const x = rr * Math.sin(th);
            const y = rr * Math.cos(th);
            pts.push(new THREE.Vector3(x, y, 0));
          }
          const longitudes = 10;
          for (let i=0; i<longitudes; i++){
            const a = (i / longitudes) * Math.PI*2;
            const ring = pts.map(p => {
              const len = p.length();
              const v = p.clone().applyAxisAngle(axis, a);
              return v.normalize().multiplyScalar(len);
            }).filter(v => v.length() < earthRadius*7.0);
            const tube = makeGlowTube(ring, 0.0012, col, 0.0, 0.05);
            g.add(tube);
          }
        }
        return g;
      }
      overlays.magField.add(makeDipoleFieldLines());

      // Aurora (lightweight “curtains” using multiple noisy rings)
      function makeAurora(){
        const g = new THREE.Group();
        const baseLat = 67;
        const layers = 6;
        const color = 0xa078ff;

        for(let k=0; k<layers; k++){
          const lat = baseLat + (Math.random()*3 - 1.5);
          const pts = [];
          for(let lon=-180; lon<=180; lon+=2){
            const wobble = (Math.sin((lon + k*17) * DEG * 3.0) * 1.1) + (Math.sin((lon + k*33) * DEG * 7.0) * 0.5);
            pts.push(latLonToVec3(lat + wobble, lon, earthRadius * (1.045 + k*0.002)));
          }
          g.add(makeGlowTube(pts, 0.0016, color, 0.0, 0.10));
        }
        return g;
      }
      overlays.aurora.add(makeAurora());

      // ---------- Interaction ----------
      const el = renderer.domElement;
      let dragging=false, lastX=0, lastY=0, velY=0, velX=0;
      const AUTO_SPIN=0.00115, DRAG_SENS=0.0065, PITCH_SENS=0.0048, DAMPING=0.92, MAX_PITCH=0.55;

      let pinching=false, pinchStartDist=0, pinchStartZ=camera.position.z;
      const Z_MIN=2.2, Z_MAX=8.0;

      function getPoint(e){
        if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
        return { x:e.clientX, y:e.clientY };
      }
      function dist2(t1, t2){
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.sqrt(dx*dx + dy*dy);
      }
      function down(e){
        if (isUIEventTarget(e.target)) return;
        if (e.touches && e.touches.length === 2){
          pinching = true;
          pinchStartDist = dist2(e.touches[0], e.touches[1]);
          pinchStartZ = camera.position.z;
          return;
        }
        dragging=true;
        const p=getPoint(e);
        lastX=p.x; lastY=p.y;
      }
      function move(e){
        if (isUIEventTarget(e.target)) return;

        if (pinching && e.touches && e.touches.length === 2){
          const d = dist2(e.touches[0], e.touches[1]);
          const ratio = pinchStartDist > 0 ? (pinchStartDist / d) : 1.0;
          camera.position.z = clamp(pinchStartZ * ratio, Z_MIN, Z_MAX);
          return;
        }

        if(!dragging) return;
        const p=getPoint(e);
        const dx=p.x-lastX, dy=p.y-lastY;
        lastX=p.x; lastY=p.y;

        globe.rotation.y += dx*DRAG_SENS;
        globe.rotation.x += dy*PITCH_SENS;
        globe.rotation.x = clamp(globe.rotation.x, -MAX_PITCH, MAX_PITCH);

        velY = dx*DRAG_SENS;
        velX = dy*PITCH_SENS;
      }
      function up(){ dragging=false; pinching=false; }

      el.addEventListener("touchstart", down, { passive:true });
      el.addEventListener("touchmove", move, { passive:true });
      el.addEventListener("touchend", up, { passive:true });
      el.addEventListener("mousedown", down);
      window.addEventListener("mousemove", move);
      window.addEventListener("mouseup", up);

      window.addEventListener("wheel", (e) => {
        if (isUIEventTarget(e.target)) return;
        camera.position.z = clamp(camera.position.z + (e.deltaY * 0.0025), Z_MIN, Z_MAX);
      }, { passive:true });

      // Tap-to-add station
      const raycaster = new THREE.Raycaster();
      const ndc = new THREE.Vector2();
      function pointerToNDC(clientX, clientY){
        ndc.x = (clientX / innerWidth) * 2 - 1;
        ndc.y = -(clientY / innerHeight) * 2 + 1;
      }
      function addFutureStationFromTap(clientX, clientY){
        pointerToNDC(clientX, clientY);
        raycaster.setFromCamera(ndc, camera);
        const hits = raycaster.intersectObject(earth, true);
        if (!hits.length) return;

        const pWorld = hits[0].point.clone();
        const pLocal = globe.worldToLocal(pWorld.clone());
        const v = pLocal.clone().normalize();
        const ll = vec3ToLatLon(v);

        const list = loadStations();
        list.push({ lat: ll.lat, lon: ll.lon, t: Date.now() });
        saveStations(list);
        rebuildFutureStations();

        statusEl.textContent = `Saved Future Station ${list.length} @ ${ll.lat.toFixed(4)}, ${ll.lon.toFixed(4)}`;
      }

      let tapCandidate=null;
      el.addEventListener("touchstart", (e) => {
        if (isUIEventTarget(e.target)) { tapCandidate=null; return; }
        if (e.touches?.length === 1){
          tapCandidate = { x: e.touches[0].clientX, y: e.touches[0].clientY, t: performance.now() };
        } else tapCandidate=null;
      }, { passive:true });
      el.addEventListener("touchend", () => {
        if (!tapCandidate) return;
        const dt = performance.now() - tapCandidate.t;
        if (dt < 280 && !dragging && !pinching && state.stations){
          addFutureStationFromTap(tapCandidate.x, tapCandidate.y);
        }
        tapCandidate=null;
      }, { passive:true });

      // ---------- Layer toggles ----------
      const state = {
        rhumbLine: true,
        rhumbName: false,
        geodesicLine: true,
        geoName: false,
        perpLine: false,
        perpName: false,
        continents: false,
        stations: true,
        corridors: false,
        magField: false,
        aurora: false
      };

      function applyVisibility(){
        overlays.rhumbLine.visible = state.rhumbLine;
        overlays.rhumbName.visible = state.rhumbName;
        overlays.geodesicLine.visible = state.geodesicLine;
        overlays.geoName.visible = state.geoName;
        overlays.perpLine.visible = state.perpLine;
        overlays.perpName.visible = state.perpName;
        overlays.continents.visible = state.continents;
        overlays.stations.visible = state.stations;
        overlays.corridors.visible = state.corridors;
        overlays.magField.visible = state.magField;
        overlays.aurora.visible = state.aurora;
      }
      applyVisibility();

      function setPill(key, on){
        const b = document.querySelector(`.pill[data-key="${key}"]`);
        if (!b) return;
        b.classList.toggle("on", !!on);
      }
      Object.keys(state).forEach(k => setPill(k, state[k]));

      document.querySelectorAll(".pill").forEach(btn => {
        if (btn.classList.contains("spacer")) return;
        btn.addEventListener("click", () => {
          const key = btn.dataset.key;
          state[key] = !state[key];
          setPill(key, state[key]);
          applyVisibility();
        });
      });

      // ---------- Animate ----------
      const sunDrift = 0.00005;
      const cloudSpin = 0.0019;

      function animate(){
        requestAnimationFrame(animate);

        clouds.rotation.y += cloudSpin;
        cloudShadow.rotation.y += cloudSpin + 0.00012;

        if(!dragging && !pinching){
          globe.rotation.y += AUTO_SPIN;
          globe.rotation.y += velY;
          globe.rotation.x += velX;
          velY *= DAMPING;
          velX *= DAMPING;
          globe.rotation.x = clamp(globe.rotation.x, -MAX_PITCH, MAX_PITCH);
        }

        sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
        const sunDir = sunLight.position.clone().normalize();

        earthUniforms.sunDir.value.copy(sunDir);
        earthUniforms.cameraPos.value.copy(camera.position);

        lightsUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.cameraPos.value.copy(camera.position);

        renderer.render(scene, camera);
      }
      statusEl.textContent = "Running";
      animate();

      addEventListener("resize", () => {
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

    }catch(err){
      showError("Top-level error:\n" + (err?.stack || err?.message || err));
    }
  </script>
</body>
</html>
