<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover"
    />
    <title>MAP E.D.E.N. Globe</title>

    <style>
      :root{
        --glass: rgba(12,14,18,0.58);
        --stroke: rgba(255,255,255,0.12);
        --stroke2: rgba(255,255,255,0.14);
        --text: rgba(255,255,255,0.92);
        --muted: rgba(255,255,255,0.68);
        --muted2: rgba(255,255,255,0.45);

        --gold: #f6c24a;
        --blue: #5bbcff;
        --aqua: #7fffd4;
        --violet: #a078ff;
      }

      html, body { height: 100%; margin: 0; background:#000; overflow:hidden; touch-action:none; }
      canvas { display:block; width:100vw !important; height:100vh !important; }

      /* Floating OPEN button (brand-clean) */
      #openBtn{
        position: fixed;
        left: 18px;
        bottom: 18px;
        z-index: 10000;
        display: none;
        padding: 12px 16px;
        border-radius: 18px;
        color: var(--text);
        background: rgba(12,14,18,0.62);
        border: 1px solid rgba(255,255,255,0.14);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 14px 44px rgba(0,0,0,0.42);
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        font: 900 13px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        letter-spacing: 0.25px;
      }
      #openBtn:active { transform: translateY(1px); }

      /* Bottom Drawer */
      #drawer {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        bottom: 18px;
        width: min(760px, calc(100vw - 28px));
        z-index: 9999;
        color: var(--text);
        background: var(--glass);
        border: 1px solid var(--stroke);
        border-radius: 22px;
        padding: 14px 14px 14px;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 14px 44px rgba(0,0,0,0.42);
        user-select: none;
        max-height: calc(100vh - 28px);
        overflow: hidden;
      }

      #drawer.closed{
        transform: translateX(-50%) translateY(140%);
        opacity: 0;
        pointer-events: none;
        transition: transform 240ms ease, opacity 200ms ease;
      }
      #drawer:not(.closed){
        transition: transform 240ms ease, opacity 200ms ease;
      }

      #handle {
        width: 44px;
        height: 6px;
        border-radius: 999px;
        background: rgba(255,255,255,0.18);
        margin: 6px auto 10px;
        cursor: pointer;
      }

      #drawerTop{
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:12px;
      }

      #titleBlock{
        display:flex;
        flex-direction:column;
        gap:5px;
      }

      #title {
        font: 900 18px/1.1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        letter-spacing: 0.2px;
      }
      #subtitle{
        font: 650 12px/1.25 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        color: var(--muted);
      }

      #closeBtn{
        width: 40px;
        height: 40px;
        border-radius: 14px;
        border: 1px solid var(--stroke2);
        background: rgba(255,255,255,0.06);
        color: var(--text);
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:center;
        -webkit-tap-highlight-color: transparent;
        flex: 0 0 auto;
      }
      #closeBtn:active { transform: translateY(1px); }

      /* body scroll container (helps landscape) */
      #drawerBody{
        margin-top: 12px;
        overflow: auto;
        max-height: calc(100vh - 170px);
        padding-right: 2px;
        -webkit-overflow-scrolling: touch;
      }

      .grid2{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      /* Welcome • Mission • Switchboard (order REQUIRED) */
      .grid3{
        display:grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 12px;
      }

      .pill {
        display:inline-flex;
        align-items:center;
        justify-content:flex-start;
        gap:10px;
        padding: 12px 14px;
        border-radius: 18px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(255,255,255,0.06);
        color: var(--text);
        font: 900 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        letter-spacing: 0.15px;
        cursor:pointer;
        -webkit-tap-highlight-color: transparent;
        min-height: 46px;
      }
      .pill:active { transform: translateY(1px); }
      .pill .rightHint{
        margin-left:auto;
        color: rgba(255,255,255,0.60);
        font: 800 12px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        letter-spacing: 0.15px;
      }

      .dot {
        width: 10px; height: 10px;
        border-radius: 50%;
        background: rgba(255,255,255,0.16);
        box-shadow: 0 0 0 rgba(0,0,0,0);
        flex: 0 0 auto;
      }

      /* ON colors */
      .pill.on .dot{ background: rgba(120,255,200,0.88); box-shadow: 0 0 14px rgba(120,255,200,0.24); }
      .pill.on[data-key="rhumb222"] .dot{ background: rgba(246,194,74,0.95); box-shadow:0 0 14px rgba(246,194,74,0.24); }
      .pill.on[data-key="rhumb42"]  .dot{ background: rgba(246,194,74,0.78); box-shadow:0 0 14px rgba(246,194,74,0.18); }
      .pill.on[data-key="gc222"]    .dot{ background: rgba(91,188,255,0.92); box-shadow:0 0 14px rgba(91,188,255,0.22); }
      .pill.on[data-key="gc42"]     .dot{ background: rgba(91,188,255,0.75); box-shadow:0 0 14px rgba(91,188,255,0.16); }
      .pill.on[data-key="stations"] .dot{ background: rgba(127,255,212,0.86); box-shadow:0 0 14px rgba(127,255,212,0.22); }
      .pill.on[data-key="aurora"]   .dot{ background: rgba(160,120,255,0.90); box-shadow:0 0 14px rgba(160,120,255,0.22); }

      /* Switchboard glow (white) */
      .pill.switchboard.on{
        border-color: rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.10);
        box-shadow: 0 10px 26px rgba(0,0,0,0.20), 0 0 22px rgba(255,255,255,0.12);
      }
      .pill.switchboard.on .dot{
        background: rgba(255,255,255,0.92);
        box-shadow: 0 0 18px rgba(255,255,255,0.22);
      }

      #welcomePanel, #missionPanel{
        display:none;
        margin-top: 12px;
        padding: 12px 14px;
        border-radius: 18px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(0,0,0,0.20);
        color: rgba(255,255,255,0.88);
        font: 700 12px/1.45 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      }
      #welcomePanel strong, #missionPanel strong{ font-weight: 900; }

      /* Switch group hidden unless open */
      #switchGroup{ display:none; margin-top: 12px; }
      #switchGroup.open{ display:block; }

      #statusLine{
        margin-top:12px;
        color: var(--muted2);
        font: 800 11px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        display:flex;
        justify-content:space-between;
        gap:12px;
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
        padding-bottom: 2px;
      }

      #errors{
        margin-top: 10px;
        display:none;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(255,120,120,0.22);
        background: rgba(80,10,10,0.35);
        color: rgba(255,170,170,0.95);
        font: 650 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        white-space: pre-wrap;
      }

      #drawer.collapsed #drawerBody { display:none; }

      @media (max-width: 620px){
        .grid3{ grid-template-columns: 1fr 1fr 1fr; } /* keep 3 across where possible */
        #switchboardBtn{ }
      }

      @media (max-width: 520px){
        .grid3{ grid-template-columns: 1fr 1fr; }
        #switchboardBtn{ grid-column: 1 / span 2; }
      }

      @media (max-width: 420px){
        .pill { padding: 12px 12px; border-radius: 16px; font-size: 13px; }
        #drawerBody{ max-height: calc(100vh - 165px); }
      }

      @media (orientation: landscape){
        #drawer{
          width: min(920px, calc(100vw - 28px));
          bottom: 14px;
        }
        #drawerBody{
          max-height: calc(100vh - 145px);
        }
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <button id="openBtn" aria-label="Open MAP E.D.E.N.">MAP E.D.E.N.</button>

    <div id="drawer">
      <div id="handle" title="Tap to collapse/expand"></div>

      <div id="drawerTop">
        <div id="titleBlock">
          <div id="title">MAP E.D.E.N.</div>
          <div id="subtitle">Earth Diametric Energy Network • Tap Switchboard to open layers</div>
        </div>
        <button id="closeBtn" aria-label="Close drawer" title="Close">✕</button>
      </div>

      <div id="drawerBody">
        <!-- REQUIRED order: Welcome • Mission • Switchboard -->
        <div class="grid3">
          <button class="pill" id="welcomeBtn" data-key="welcome">
            <span class="dot"></span>Welcome
          </button>

          <button class="pill" id="missionBtn" data-key="mission">
            <span class="dot"></span>Mission
          </button>

          <button class="pill switchboard" id="switchboardBtn" data-key="switchboard">
            <span class="dot"></span>Switchboard
            <span class="rightHint" id="switchHint">Tap to open</span>
          </button>
        </div>

        <div id="welcomePanel">
          <strong>Welcome:</strong> Drag the globe to rotate • Pinch to zoom • Use Switchboard to toggle layers (Rhumb, Great Circle, Names, Stations, Night Lights, and more).
        </div>

        <div id="missionPanel">
          <strong>Mission:</strong> Turn the 42°/222° axis hypothesis into an evidence-first experiment by producing sensor datasets that are repeatable, controlled, and comparable across stations and time.
        </div>

        <div id="switchGroup">
          <div class="grid2">
            <button class="pill" data-key="rhumb222"><span class="dot"></span>Rhumb 222 SW</button>
            <button class="pill" data-key="rhumb42"><span class="dot"></span>Rhumb 42 NE</button>

            <button class="pill" data-key="gc222"><span class="dot"></span>Great Circle 222 SW</button>
            <button class="pill" data-key="gc42"><span class="dot"></span>Great Circle 42 NE</button>

            <button class="pill" data-key="names222"><span class="dot"></span>Names 222 SW</button>
            <button class="pill" data-key="names42"><span class="dot"></span>Names 42 NE</button>

            <button class="pill" data-key="perpLine"><span class="dot"></span>Perpendiculars</button>
            <button class="pill" data-key="continents"><span class="dot"></span>Continents</button>

            <button class="pill on" data-key="stations"><span class="dot"></span>Stations</button>
            <button class="pill" data-key="corridors"><span class="dot"></span>Corridors</button>

            <button class="pill" data-key="magField"><span class="dot"></span>Magnetic Field</button>
            <button class="pill" data-key="aurora"><span class="dot"></span>Aurora</button>

            <button class="pill on" data-key="nightLights"><span class="dot"></span>Night Lights</button>
            <button class="pill" data-key="perpName"><span class="dot"></span>Perp Name</button>
          </div>

          <div id="errors"></div>
        </div>

        <div id="statusLine">
          <span id="status">Booting…</span>
          <span id="stationLine">Exit 222 • Station 1 @ 38°9′39″ N, 79°4′24″ W</span>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      const statusEl = document.getElementById("status");
      const errorsEl = document.getElementById("errors");
      const drawerEl = document.getElementById("drawer");
      const openBtn = document.getElementById("openBtn");
      const closeBtn = document.getElementById("closeBtn");
      const handle = document.getElementById("handle");

      const welcomeBtn = document.getElementById("welcomeBtn");
      const welcomePanel = document.getElementById("welcomePanel");
      const missionBtn = document.getElementById("missionBtn");
      const missionPanel = document.getElementById("missionPanel");

      const switchboardBtn = document.getElementById("switchboardBtn");
      const switchGroup = document.getElementById("switchGroup");
      const switchHint = document.getElementById("switchHint");

      function showError(msg){
        if (!errorsEl) return;
        errorsEl.style.display = "block";
        errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
        statusEl.textContent = "Error (see panel)";
      }
      window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
      window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

      function setDrawerClosed(isClosed){
        drawerEl.classList.toggle("closed", !!isClosed);
        openBtn.style.display = isClosed ? "inline-flex" : "none";
      }
      setDrawerClosed(false);
      openBtn.addEventListener("click", () => setDrawerClosed(false));
      closeBtn.addEventListener("click", () => setDrawerClosed(true));
      handle.addEventListener("click", () => drawerEl.classList.toggle("collapsed"));

      // Welcome toggle
      welcomeBtn.addEventListener("click", ()=>{
        const isOn = welcomePanel.style.display === "block";
        welcomePanel.style.display = isOn ? "none" : "block";
        welcomeBtn.classList.toggle("on", !isOn);
      });

      // Mission toggle
      missionBtn.addEventListener("click", ()=>{
        const isOn = missionPanel.style.display === "block";
        missionPanel.style.display = isOn ? "none" : "block";
        missionBtn.classList.toggle("on", !isOn);
      });

      // Switchboard toggle (UI only)
      let switchboardOpen = false;
      function setSwitchboard(on){
        switchboardOpen = !!on;
        switchboardBtn.classList.toggle("on", switchboardOpen);
        switchGroup.classList.toggle("open", switchboardOpen);
        switchHint.textContent = switchboardOpen ? "Tap to close" : "Tap to open";
      }
      switchboardBtn.addEventListener("click", ()=> setSwitchboard(!switchboardOpen));
      setSwitchboard(false);

      const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
      const DEG = Math.PI/180;
      const RAD = 180/Math.PI;

      function isUIEventTarget(target){
        return !!(target && (target.closest?.("#drawer") || target.closest?.("#openBtn")));
      }

      function latLonToVec3(latDeg, lonDeg, radius=1.0){
        const lat = latDeg * DEG;
        const lon = lonDeg * DEG;
        return new THREE.Vector3(
          radius * Math.cos(lat) * Math.cos(lon),
          radius * Math.sin(lat),
          radius * Math.cos(lat) * Math.sin(lon)
        );
      }

      function greatCirclePoints(lat0Deg, lon0Deg, bearingDeg, stepDeg=1.0){
        const lat0 = lat0Deg * DEG;
        const lon0 = lon0Deg * DEG;
        const brng = bearingDeg * DEG;

        const pts = [];
        for(let d=-180; d<=180; d+=stepDeg){
          const δ = d * DEG;
          const sinLat = Math.sin(lat0)*Math.cos(δ) + Math.cos(lat0)*Math.sin(δ)*Math.cos(brng);
          const lat = Math.asin(clamp(sinLat, -1, 1));
          const y = Math.sin(brng)*Math.sin(δ)*Math.cos(lat0);
          const x = Math.cos(δ) - Math.sin(lat0)*Math.sin(lat);
          const lon = lon0 + Math.atan2(y, x);
          pts.push({ lat: lat*RAD, lon: ((lon*RAD + 540) % 360) - 180 });
        }
        return pts;
      }

      function rhumbPoints(lat0Deg, lon0Deg, bearingDeg, stepKm=250){
        const R=6371;
        const φ1=lat0Deg*DEG;
        const λ1=lon0Deg*DEG;
        const θ=bearingDeg*DEG;

        const pts=[];
        const maxSteps=100;
        for (const dir of [-1,+1]){
          let φ=φ1, λ=λ1;
          for (let i=0;i<maxSteps;i++){
            const d = dir*(stepKm/R);
            const Δφ = d*Math.cos(θ);
            let φ2 = clamp(φ+Δφ, -Math.PI/2+1e-6, Math.PI/2-1e-6);

            const Δψ = Math.log(Math.tan(Math.PI/4+φ2/2)/Math.tan(Math.PI/4+φ/2));
            const q = Math.abs(Δψ)>1e-12 ? (Δφ/Δψ) : Math.cos(φ);

            const Δλ = d*Math.sin(θ)/q;
            let λ2 = ((λ+Δλ+Math.PI)%(2*Math.PI))-Math.PI;

            pts.push({ lat: φ2*RAD, lon: λ2*RAD });
            φ=φ2; λ=λ2;
          }
        }
        return pts;
      }

      function makeGlowTube(pointsVec3, radius, coreColor, haloColor, coreOpacity=1.0, haloOpacity=0.22){
        if (!pointsVec3 || pointsVec3.length < 4) return new THREE.Group();
        const curve = new THREE.CatmullRomCurve3(pointsVec3, false, "catmullrom", 0.15);
        const segs = Math.max(220, pointsVec3.length);

        const coreGeom = new THREE.TubeGeometry(curve, segs, radius, 10, false);
        const haloGeom = new THREE.TubeGeometry(curve, segs, radius*2.2, 10, false);

        const coreMat = new THREE.MeshBasicMaterial({ color: coreColor, transparent: coreOpacity<1, opacity: coreOpacity, depthWrite:false });
        const haloMat = new THREE.MeshBasicMaterial({ color: haloColor, transparent:true, opacity: haloOpacity, blending: THREE.AdditiveBlending, depthWrite:false });

        const g = new THREE.Group();
        g.add(new THREE.Mesh(haloGeom, haloMat));
        g.add(new THREE.Mesh(coreGeom, coreMat));
        return g;
      }

      /**
       * LABEL SPRITES — IMPORTANT FIX:
       * Names layers must be TEXT ONLY (no borders/boxes on globe).
       * We force a fully transparent canvas background + no rounded rect unless bg is explicitly provided.
       */
      function makeLabelSprite(text, {
        fontSize=17,
        padding=8,
        color="rgba(255,255,255,0.90)",
        bg=null,                 // null => NO BOX
        opacity=0.80,
        scale=0.0039,
        glow=true,
        glowColor="rgba(255,255,255,0.14)",
        glowBlur=3
      } = {}){
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        ctx.font = `900 ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
        const m = ctx.measureText(text);

        const w = Math.ceil(m.width + padding*2);
        const h = Math.ceil(fontSize + padding*2);
        canvas.width = w;
        canvas.height = h;

        // Ensure absolutely no accidental background artifacts.
        ctx.clearRect(0,0,w,h);

        // Draw bg ONLY if explicitly requested (stations tag uses this, names do not)
        if (bg !== null){
          ctx.fillStyle = bg;
          const r = Math.min(18, h/2);
          ctx.beginPath();
          ctx.moveTo(r,0); ctx.arcTo(w,0,w,h,r); ctx.arcTo(w,h,0,h,r); ctx.arcTo(0,h,0,0,r); ctx.arcTo(0,0,w,0,r);
          ctx.closePath(); ctx.fill();
        }

        if (glow){
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = glowBlur;
        } else {
          ctx.shadowBlur = 0;
        }

        ctx.fillStyle = color;
        ctx.textBaseline = "middle";
        ctx.fillText(text, padding, h/2);

        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.premultiplyAlpha = true;

        const mat = new THREE.SpriteMaterial({
          map: tex,
          transparent: true,
          depthWrite: false,
          opacity,
          alphaTest: 0.01 // trims invisible edges better on iOS
        });

        const spr = new THREE.Sprite(mat);
        spr.scale.set(w*scale, h*scale, 1);
        return spr;
      }

      // ---------- Fallback textures ----------
      function solidTexture(hex="#222"){
        const c=document.createElement("canvas");
        c.width=2; c.height=2;
        const ctx=c.getContext("2d");
        ctx.fillStyle=hex; ctx.fillRect(0,0,2,2);
        const t=new THREE.CanvasTexture(c);
        t.colorSpace=THREE.SRGBColorSpace;
        return t;
      }

      function makeFallbackStars(){
        const c=document.createElement("canvas");
        c.width=1024; c.height=1024;
        const ctx=c.getContext("2d");
        ctx.fillStyle="#000"; ctx.fillRect(0,0,c.width,c.height);
        for(let i=0;i<2100;i++){
          const x=Math.random()*c.width, y=Math.random()*c.height;
          const a=0.2+Math.random()*0.8;
          const s=Math.random()>0.996?2:1;
          ctx.fillStyle=`rgba(255,255,255,${a})`;
          ctx.fillRect(x,y,s,s);
        }
        const t=new THREE.CanvasTexture(c);
        t.colorSpace=THREE.SRGBColorSpace;
        return t;
      }

      function makeFallbackEarthDay(){
        const c=document.createElement("canvas");
        c.width=1024; c.height=512;
        const ctx=c.getContext("2d");
        ctx.fillStyle="#0f2f66"; ctx.fillRect(0,0,c.width,c.height);
        ctx.globalAlpha=0.92; ctx.fillStyle="#2c7a4b";
        for(let i=0;i<34;i++){
          const x=Math.random()*c.width, y=Math.random()*c.height;
          const r=22+Math.random()*95;
          ctx.beginPath(); ctx.ellipse(x,y,r,r*0.62,Math.random()*Math.PI,0,Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha=0.10; ctx.fillStyle="#ffffff";
        for(let i=0;i<80;i++){
          const x=Math.random()*c.width, y=Math.random()*c.height;
          const r=22+Math.random()*110;
          ctx.beginPath(); ctx.ellipse(x,y,r,r*0.42,0,0,Math.PI*2); ctx.fill();
        }
        const t=new THREE.CanvasTexture(c);
        t.colorSpace=THREE.SRGBColorSpace;
        return t;
      }

      function makeFallbackNight(){
        const c=document.createElement("canvas");
        c.width=1024; c.height=512;
        const ctx=c.getContext("2d");
        ctx.fillStyle="#000"; ctx.fillRect(0,0,c.width,c.height);
        ctx.fillStyle="rgba(255,220,140,0.9)";
        for(let i=0;i<2200;i++){
          const x=Math.random()*c.width, y=Math.random()*c.height;
          if(Math.random()<0.986) continue;
          ctx.fillRect(x,y,1,1);
        }
        const t=new THREE.CanvasTexture(c);
        t.colorSpace=THREE.SRGBColorSpace;
        return t;
      }

      function makeFallbackClouds(){
        const c=document.createElement("canvas");
        c.width=1024; c.height=512;
        const ctx=c.getContext("2d");
        ctx.clearRect(0,0,c.width,c.height);
        ctx.fillStyle="rgba(255,255,255,0.38)";
        for(let i=0;i<130;i++){
          const x=Math.random()*c.width, y=Math.random()*c.height;
          const r=28+Math.random()*120;
          ctx.beginPath(); ctx.ellipse(x,y,r,r*0.48,0,0,Math.PI*2); ctx.fill();
        }
        const t=new THREE.CanvasTexture(c);
        t.colorSpace=THREE.SRGBColorSpace;
        return t;
      }

      async function loadTextureWithFallback(urls, fallbackTex, label){
        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin("anonymous");
        const tryOne = (url) => new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, () => reject(new Error("failed: " + url)));
        });

        for (const u of urls){
          try{
            const tex = await tryOne(u);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
          } catch { /* try next */ }
        }
        showError(`Texture fallback used for: ${label}\n(CDN blocked/failed on this device/network)`);
        return fallbackTex;
      }

      // ---------- Rotation/resize stability (FIX FREEZE/CRASH) ----------
      let resizeTimer = null;
      let resizing = false;
      let lastSize = { w: 0, h: 0 };

      function getSafeSize(){
        const vv = window.visualViewport;
        const w = Math.round((vv?.width  ?? window.innerWidth)  || 0);
        const h = Math.round((vv?.height ?? window.innerHeight) || 0);
        return { w, h };
      }

      function debounce(fn, ms){
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(fn, ms);
      }

      // ---------- Main ----------
      (async ()=>{
        try{
          statusEl.textContent = "Starting…";

          const scene = new THREE.Scene();

          const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
          camera.position.set(0, 0, 4.2);

          // Lower pixel ratio for iOS stability
          const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference: "high-performance" });
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.45));
          renderer.setSize(innerWidth, innerHeight);
          renderer.outputColorSpace = THREE.SRGBColorSpace;
          renderer.toneMapping = THREE.ACESFilmicToneMapping;
          renderer.toneMappingExposure = 1.18;
          document.body.appendChild(renderer.domElement);

          // iOS rotation/context stability
          renderer.domElement.addEventListener("webglcontextlost", (e)=>{
            e.preventDefault();
            statusEl.textContent = "WebGL context lost — recovering…";
          }, false);
          renderer.domElement.addEventListener("webglcontextrestored", ()=>{
            location.reload();
          }, false);

          scene.add(new THREE.AmbientLight(0xffffff, 0.18));
          const sunLight = new THREE.DirectionalLight(0xffffff, 1.35);
          sunLight.position.set(5, 1.5, 2.5);
          scene.add(sunLight);

          const BASES = [
            "https://threejs.org/examples/textures/",
            "https://unpkg.com/three@0.161.0/examples/textures/",
            "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/"
          ];
          const urls = (path)=>BASES.map(b=>b+path);

          statusEl.textContent = "Loading textures…";

          const dayMap   = await loadTextureWithFallback(urls("planets/earth_atmos_2048.jpg"), makeFallbackEarthDay(), "earth day");
          const nightMap = await loadTextureWithFallback(urls("planets/earth_lights_2048.png"), makeFallbackNight(), "earth night lights");
          const specMap  = await loadTextureWithFallback(urls("planets/earth_specular_2048.jpg"), solidTexture("#000"), "earth specular");
          const cloudMap = await loadTextureWithFallback(urls("planets/earth_clouds_1024.png"), makeFallbackClouds(), "earth clouds");
          const starMap  = await loadTextureWithFallback(urls("galaxy_starfield.png"), makeFallbackStars(), "stars");

          const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
          [dayMap, nightMap, specMap, cloudMap, starMap].forEach((t)=>{
            t.anisotropy = maxAniso;
            t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
          });

          statusEl.textContent = "Running";

          // Stars (lighter geometry for iOS)
          {
            const starGeo = new THREE.SphereGeometry(90, 44, 44);
            const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
            scene.add(new THREE.Mesh(starGeo, starMat));
          }

          const earthRadius = 1.0;
          const SEG = 72; // reduced from 96 for stability

          // Earth shader
          const earthUniforms = {
            dayMap:    { value: dayMap },
            specMap:   { value: specMap },
            sunDir:    { value: new THREE.Vector3(1,0,0) },
            cameraPos: { value: new THREE.Vector3() }
          };

          const earthMat = new THREE.ShaderMaterial({
            uniforms: earthUniforms,
            vertexShader: `
              varying vec2 vUv;
              varying vec3 vNormalW;
              varying vec3 vPosW;
              void main(){
                vUv = uv;
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vPosW = worldPos.xyz;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * worldPos;
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform sampler2D dayMap;
              uniform sampler2D specMap;
              uniform vec3 sunDir;
              uniform vec3 cameraPos;
              varying vec2 vUv;
              varying vec3 vNormalW;
              varying vec3 vPosW;

              vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
              vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);
                vec3 V = normalize(cameraPos - vPosW);

                vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
                dayCol.b *= 1.08;
                dayCol.g *= 1.02;

                float lum = dot(dayCol, vec3(0.2126,0.7152,0.0722));
                vec3 sat = mix(vec3(lum), dayCol, 1.12);
                vec3 c = pow(max(sat, 0.0), vec3(0.92));

                float specMask = texture2D(specMap, vUv).r;
                float ndl = dot(N, L);
                float dayAmt = smoothstep(-0.05, 0.15, ndl);

                vec3 nightBase = c * 0.10;
                vec3 col = mix(nightBase, c, dayAmt);

                vec3 H = normalize(L + V);
                float spec = pow(max(dot(N, H), 0.0), 82.0) * specMask * 0.52 * dayAmt;
                col += vec3(spec);

                float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
                col += vec3(0.06, 0.11, 0.18) * rim * (0.28 + 0.72 * dayAmt);

                gl_FragColor = vec4(linearToSrgb(col), 1.0);
              }
            `
          });

          const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);

          // Night lights (additive) — ensure it visibly toggles ON
          const lightsUniforms = {
            nightMap: { value: nightMap },
            sunDir:   { value: new THREE.Vector3(1,0,0) },
            gain:     { value: 2.9 }
          };

          const nightLights = new THREE.Mesh(
            new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
            new THREE.ShaderMaterial({
              uniforms: lightsUniforms,
              transparent: true,
              depthWrite: false,
              blending: THREE.AdditiveBlending,
              vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormalW;
                void main(){
                  vUv = uv;
                  vNormalW = normalize(mat3(modelMatrix) * normal);
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
              `,
              fragmentShader: `
                precision highp float;
                uniform sampler2D nightMap;
                uniform vec3 sunDir;
                uniform float gain;
                varying vec2 vUv;
                varying vec3 vNormalW;

                vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
                vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

                void main(){
                  vec3 N = normalize(vNormalW);
                  vec3 L = normalize(sunDir);

                  float ndl = dot(N, L);
                  float dayAmt = smoothstep(-0.05, 0.15, ndl);
                  float nightAmt = 1.0 - dayAmt;

                  vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
                  float mask = smoothstep(0.06, 0.34, nightAmt);

                  vec3 col = lights * mask;
                  float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
                  gl_FragColor = vec4(linearToSrgb(col), a);
                }
              `
            })
          );

          // Clouds
          const cloudShadow = new THREE.Mesh(
            new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
            new THREE.MeshBasicMaterial({
              map: cloudMap,
              color: 0x000000,
              transparent: true,
              opacity: 0.20,
              blending: THREE.MultiplyBlending,
              depthWrite: false
            })
          );

          const clouds = new THREE.Mesh(
            new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
            new THREE.MeshLambertMaterial({
              map: cloudMap,
              transparent: true,
              opacity: 0.92,
              depthWrite: false
            })
          );

          // Atmosphere
          const atmoUniforms = {
            sunDir:    { value: new THREE.Vector3(1,0,0) },
            cameraPos: { value: new THREE.Vector3() }
          };

          const atmosphere = new THREE.Mesh(
            new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
            new THREE.ShaderMaterial({
              uniforms: atmoUniforms,
              transparent: true,
              depthWrite: false,
              blending: THREE.AdditiveBlending,
              side: THREE.BackSide,
              vertexShader: `
                varying vec3 vNormalW;
                varying vec3 vPosW;
                void main(){
                  vec4 worldPos = modelMatrix * vec4(position, 1.0);
                  vPosW = worldPos.xyz;
                  vNormalW = normalize(mat3(modelMatrix) * normal);
                  gl_Position = projectionMatrix * viewMatrix * worldPos;
                }
              `,
              fragmentShader: `
                precision highp float;
                uniform vec3 sunDir;
                uniform vec3 cameraPos;
                varying vec3 vNormalW;
                varying vec3 vPosW;

                void main(){
                  vec3 N = normalize(vNormalW);
                  vec3 L = normalize(sunDir);
                  vec3 V = normalize(cameraPos - vPosW);

                  float rim = pow(1.0 - max(dot(N, V), 0.0), 3.1);
                  float daySide = smoothstep(-0.15, 0.25, dot(N, L));

                  vec3 col = vec3(0.18, 0.55, 1.00) * rim * (0.22 + 0.78 * daySide);
                  float alpha = rim * (0.14 + 0.58 * daySide);
                  gl_FragColor = vec4(col, alpha);
                }
              `
            })
          );

          // Globe group
          const globe = new THREE.Group();
          globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
          scene.add(globe);

          // Overlays
          const overlays = {
            rhumb222: new THREE.Group(),
            rhumb42:  new THREE.Group(),
            gc222:    new THREE.Group(),
            gc42:     new THREE.Group(),

            names222: new THREE.Group(),
            names42:  new THREE.Group(),

            perpLine: new THREE.Group(),
            perpName: new THREE.Group(),

            continents: new THREE.Group(),
            stations: new THREE.Group(),
            corridors: new THREE.Group(),
            magField: new THREE.Group(),
            aurora: new THREE.Group()
          };
          Object.values(overlays).forEach(g => globe.add(g));

          // Station 1
          const ANCHOR = {
            name: "Exit 222 • Station 1",
            lat: 38 + 9/60 + 39/3600,
            lon: -(79 + 4/60 + 24/3600)
          };

          const BEARING_222 = 222;
          const BEARING_42  = 42;

          const gc222Pts = greatCirclePoints(ANCHOR.lat, ANCHOR.lon, BEARING_222, 1.0)
            .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
          overlays.gc222.add(makeGlowTube(gc222Pts, 0.0032, 0x5bbcff, 0x5bbcff, 1.0, 0.22));

          const gc42Pts = greatCirclePoints(ANCHOR.lat, ANCHOR.lon, BEARING_42, 1.0)
            .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
          overlays.gc42.add(makeGlowTube(gc42Pts, 0.0030, 0x5bbcff, 0x5bbcff, 1.0, 0.17));

          const rh222Pts = rhumbPoints(ANCHOR.lat, ANCHOR.lon, BEARING_222, 240)
            .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
          overlays.rhumb222.add(makeGlowTube(rh222Pts, 0.0032, 0xf6c24a, 0xf6c24a, 1.0, 0.20));

          const rh42Pts = rhumbPoints(ANCHOR.lat, ANCHOR.lon, BEARING_42, 240)
            .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
          overlays.rhumb42.add(makeGlowTube(rh42Pts, 0.0030, 0xf6c24a, 0xf6c24a, 1.0, 0.15));

          // ===== NAMES (TEXT ONLY) — NO borders/boxes on globe =====
          // These are pure transparent canvases with text + subtle glow.
          {
            const common = {
              bg: null,               // <<<< NO BOX
              glow: true,
              glowBlur: 3,
              glowColor: "rgba(255,255,255,0.14)",
              opacity: 0.80,
              fontSize: 17,
              scale: 0.0039
            };

            const n1 = makeLabelSprite("Rhumb 222 SW", common);
            n1.position.copy(latLonToVec3(28, -20, earthRadius*1.11));
            overlays.names222.add(n1);

            const n2 = makeLabelSprite("Great Circle 222 SW", common);
            n2.position.copy(latLonToVec3(-8, 68, earthRadius*1.11));
            overlays.names222.add(n2);

            const n3 = makeLabelSprite("Rhumb 42 NE", common);
            n3.position.copy(latLonToVec3(46, 120, earthRadius*1.11));
            overlays.names42.add(n3);

            const n4 = makeLabelSprite("Great Circle 42 NE", common);
            n4.position.copy(latLonToVec3(5, -120, earthRadius*1.11));
            overlays.names42.add(n4);
          }

          // Perpendiculars
          function arcFromBearing(bearingDeg){
            const pts = greatCirclePoints(ANCHOR.lat, ANCHOR.lon, bearingDeg, 1.2)
              .filter((_, i) => i > 40 && i < 260)
              .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
            return makeGlowTube(pts, 0.0026, 0x5bbcff, 0x5bbcff, 1.0, 0.15);
          }
          overlays.perpLine.add(arcFromBearing(132), arcFromBearing(312));

          // Perp name (text only)
          {
            const pLabel = makeLabelSprite("132° / 312°", {
              bg: null, fontSize: 16, opacity: 0.78, scale: 0.0038, glowBlur: 3
            });
            pLabel.position.copy(latLonToVec3(56, 110, earthRadius*1.12));
            overlays.perpName.add(pLabel);
          }

          // Continents (text only)
          const CONT = [
            { name:"North America", lat: 45,  lon:-102 },
            { name:"South America", lat:-16,  lon:-60 },
            { name:"Europe",        lat: 52,  lon: 15 },
            { name:"Africa",        lat:  5,  lon: 20 },
            { name:"Asia",          lat: 45,  lon: 95 },
            { name:"Australia",     lat:-25,  lon: 135 },
            { name:"Antarctica",    lat:-80,  lon:  0 }
          ];
          for (const c of CONT){
            const s = makeLabelSprite(c.name, { bg:null, fontSize: 17, opacity: 0.80, scale: 0.0039, glowBlur: 3 });
            s.position.copy(latLonToVec3(c.lat, c.lon, earthRadius*1.10));
            overlays.continents.add(s);
          }

          // Corridors
          const kmToUnit = (km)=> (km/6371)*earthRadius;
          const corridorRadii = [
            { km: 1,  r: kmToUnit(1),  o: 0.13 },
            { km: 5,  r: kmToUnit(5),  o: 0.075 },
            { km: 10, r: kmToUnit(10), o: 0.055 }
          ];
          for (const c of corridorRadii){
            overlays.corridors.add(makeGlowTube(gc222Pts, c.r, 0xf6c24a, 0xf6c24a, 0.0, c.o));
            overlays.corridors.add(makeGlowTube(gc42Pts,  c.r, 0xf6c24a, 0xf6c24a, 0.0, c.o*0.9));
            overlays.corridors.add(makeGlowTube(rh222Pts, c.r, 0xf6c24a, 0xf6c24a, 0.0, c.o*0.95));
            overlays.corridors.add(makeGlowTube(rh42Pts,  c.r, 0xf6c24a, 0xf6c24a, 0.0, c.o*0.85));
          }

          // Station marker (tag uses subtle panel by design)
          function makeStationMarker(label, lat, lon, color=0x7fffd4){
            const g = new THREE.Group();
            const p = latLonToVec3(lat, lon, earthRadius*1.02);

            const pin = new THREE.Mesh(new THREE.SphereGeometry(0.010, 16, 16),
              new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.95 })
            );
            pin.position.copy(p);

            const glow = new THREE.Mesh(new THREE.SphereGeometry(0.020, 16, 16),
              new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.16, blending:THREE.AdditiveBlending, depthWrite:false })
            );
            glow.position.copy(p);

            const tag = makeLabelSprite(label, {
              fontSize: 17, padding: 12,
              bg:"rgba(0,0,0,0.22)",     // station tags can have a subtle bg
              opacity: 0.62,
              scale: 0.0039,
              glow: true,
              glowBlur: 4,
              glowColor:"rgba(255,255,255,0.14)"
            });
            tag.position.copy(latLonToVec3(lat, lon, earthRadius*1.12));

            g.add(glow, pin, tag);
            return g;
          }
          overlays.stations.add(makeStationMarker("Exit 222 • Station 1", ANCHOR.lat, ANCHOR.lon, 0x7fffd4));

          // Magnetic field (simple dipole preview)
          function makeDipoleFieldLines(){
            const g = new THREE.Group();
            const col = 0x5bbcff;
            const axis = new THREE.Vector3(0,1,0);
            const Ls = [1.6, 2.2, 3.2, 4.6];

            for (const L of Ls){
              const pts = [];
              for (let t=-80; t<=80; t+=1.2){
                const th = (90 - t) * DEG;
                const r = L * Math.sin(th)*Math.sin(th);
                const rr = earthRadius * r;
                if (rr < earthRadius*1.04) continue;
                const x = rr * Math.sin(th);
                const y = rr * Math.cos(th);
                pts.push(new THREE.Vector3(x, y, 0));
              }

              const longitudes = 8;
              for (let i=0; i<longitudes; i++){
                const a = (i/longitudes) * Math.PI*2;
                const ring = pts.map(p=>{
                  const len = p.length();
                  const v = p.clone().applyAxisAngle(axis, a);
                  return v.normalize().multiplyScalar(len);
                });
                g.add(makeGlowTube(ring, 0.00135, col, col, 0.0, 0.055));
              }
            }
            return g;
          }
          overlays.magField.add(makeDipoleFieldLines());

          // Aurora
          function makeAuroraBelt(latDeg=67, color=0xa078ff){
            const g = new THREE.Group();
            for (const lat of [latDeg, -latDeg]){
              const pts = [];
              for (let lon=-180; lon<=180; lon+=2) pts.push(latLonToVec3(lat, lon, earthRadius*1.05));
              g.add(makeGlowTube(pts, 0.0026, color, color, 0.0, 0.10));
            }
            return g;
          }
          overlays.aurora.add(makeAuroraBelt(67));

          // --------- Bloom (selective) ----------
          const BLOOM_LAYER = 1;
          const bloomLayer = new THREE.Layers(); bloomLayer.set(BLOOM_LAYER);

          nightLights.layers.enable(BLOOM_LAYER);
          atmosphere.layers.enable(BLOOM_LAYER);
          [overlays.rhumb222, overlays.rhumb42, overlays.gc222, overlays.gc42, overlays.perpLine, overlays.corridors, overlays.aurora].forEach(g=>{
            g.traverse(o => o.layers && o.layers.enable(BLOOM_LAYER));
          });

          const darkMaterial = new THREE.MeshBasicMaterial({ color:"black" });
          const materials = new Map();

          function darkenNonBloom(obj){
            if (obj.isMesh && !bloomLayer.test(obj.layers)){
              materials.set(obj.uuid, obj.material);
              obj.material = darkMaterial;
            }
          }
          function restoreMaterial(obj){
            if (materials.has(obj.uuid)){
              obj.material = materials.get(obj.uuid);
              materials.delete(obj.uuid);
            }
          }

          const renderScene = new RenderPass(scene, camera);
          const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.0, 0.70, 0.14);

          const bloomComposer = new EffectComposer(renderer);
          bloomComposer.renderToScreen = false;
          bloomComposer.addPass(renderScene);
          bloomComposer.addPass(bloomPass);

          const finalPass = new ShaderPass({
            uniforms: { tDiffuse: { value: null }, bloomTexture: { value: null } },
            vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
            fragmentShader: `uniform sampler2D tDiffuse; uniform sampler2D bloomTexture; varying vec2 vUv;
              void main(){ gl_FragColor = texture2D(tDiffuse,vUv) + texture2D(bloomTexture,vUv); }`
          });

          const finalComposer = new EffectComposer(renderer);
          finalComposer.addPass(renderScene);
          finalComposer.addPass(finalPass);
          finalComposer.addPass(new OutputPass());

          function renderBloom(){
            scene.traverse(darkenNonBloom);
            bloomComposer.render();
            finalPass.uniforms.bloomTexture.value = bloomComposer.readBuffer.texture;
            scene.traverse(restoreMaterial);
          }

          // --------- Interaction ----------
          let dragging=false, lastX=0, lastY=0, velY=0, velX=0;
          const AUTO_SPIN=0.0012, DRAG_SENS=0.0062, PITCH_SENS=0.0045, DAMPING=0.92, MAX_PITCH=0.55;

          let pinching=false, pinchStartDist=0, pinchStartZ=camera.position.z;
          const Z_MIN=2.2, Z_MAX=8.0;

          function getPoint(e){
            if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
            return { x:e.clientX, y:e.clientY };
          }
          function dist2(t1,t2){
            const dx=t1.clientX-t2.clientX, dy=t1.clientY-t2.clientY;
            return Math.sqrt(dx*dx+dy*dy);
          }

          function down(e){
            if (isUIEventTarget(e.target)) return;

            if (e.touches && e.touches.length === 2){
              pinching=true;
              pinchStartDist = dist2(e.touches[0], e.touches[1]);
              pinchStartZ = camera.position.z;
              return;
            }
            dragging=true;
            const p=getPoint(e);
            lastX=p.x; lastY=p.y;
          }

          function move(e){
            if (isUIEventTarget(e.target)) return;

            if (pinching && e.touches && e.touches.length === 2){
              const d = dist2(e.touches[0], e.touches[1]);
              const ratio = pinchStartDist > 0 ? (pinchStartDist / d) : 1.0;
              camera.position.z = clamp(pinchStartZ * ratio, Z_MIN, Z_MAX);
              return;
            }

            if(!dragging) return;
            const p=getPoint(e);
            const dx=p.x-lastX, dy=p.y-lastY;
            lastX=p.x; lastY=p.y;

            globe.rotation.y += dx*DRAG_SENS;
            globe.rotation.x = clamp(globe.rotation.x + dy*PITCH_SENS, -MAX_PITCH, MAX_PITCH);

            velY = dx*DRAG_SENS;
            velX = dy*PITCH_SENS;
          }

          function up(){ dragging=false; pinching=false; }

          const el = renderer.domElement;
          el.addEventListener("touchstart", down, { passive:true });
          el.addEventListener("touchmove", move, { passive:true });
          el.addEventListener("touchend", up, { passive:true });
          el.addEventListener("mousedown", down);
          window.addEventListener("mousemove", move);
          window.addEventListener("mouseup", up);

          window.addEventListener("wheel", (e)=>{
            if (isUIEventTarget(e.target)) return;
            camera.position.z = clamp(camera.position.z + (e.deltaY * 0.0025), Z_MIN, Z_MAX);
          }, { passive:true });

          // --------- Toggles ----------
          const state = {
            rhumb222: false,
            rhumb42:  false,
            gc222:    false,
            gc42:     false,
            names222: false,
            names42:  false,
            perpLine: false,
            perpName: false,
            continents:false,
            stations: true,
            corridors:false,
            magField: false,
            aurora:   false,
            nightLights: true
          };

          function applyVisibility(){
            overlays.rhumb222.visible = state.rhumb222;
            overlays.rhumb42.visible  = state.rhumb42;
            overlays.gc222.visible    = state.gc222;
            overlays.gc42.visible     = state.gc42;

            overlays.names222.visible = state.names222;
            overlays.names42.visible  = state.names42;

            overlays.perpLine.visible = state.perpLine;
            overlays.perpName.visible = state.perpName;

            overlays.continents.visible = state.continents;

            overlays.stations.visible  = state.stations;
            overlays.corridors.visible = state.corridors;

            overlays.magField.visible = state.magField;
            overlays.aurora.visible   = state.aurora;

            nightLights.visible = state.nightLights;
          }
          applyVisibility();

          function setPill(key, on){
            const b = document.querySelector(`.pill[data-key="${key}"]`);
            if (b) b.classList.toggle("on", !!on);
          }
          Object.keys(state).forEach(k => setPill(k, state[k]));

          document.querySelectorAll(".pill").forEach(btn=>{
            btn.addEventListener("click", ()=>{
              const key = btn.dataset.key;
              if (!(key in state)) return;
              state[key] = !state[key];
              setPill(key, state[key]);
              applyVisibility();
            });
          });

          // --------- Animate ----------
          const sunDrift = 0.00005;
          const cloudSpin = 0.0019;

          function animate(){
            requestAnimationFrame(animate);

            // During resizing (rotation), avoid heavy work for a few frames (prevents iOS freeze).
            if (resizing) return;

            clouds.rotation.y += cloudSpin;
            cloudShadow.rotation.y += cloudSpin + 0.00015;

            if(!dragging && !pinching){
              globe.rotation.y += AUTO_SPIN + velY;
              globe.rotation.x = clamp(globe.rotation.x + velX, -MAX_PITCH, MAX_PITCH);
              velY *= DAMPING;
              velX *= DAMPING;
            }

            sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
            const sunDir = sunLight.position.clone().normalize();

            earthUniforms.sunDir.value.copy(sunDir);
            earthUniforms.cameraPos.value.copy(camera.position);
            lightsUniforms.sunDir.value.copy(sunDir);
            atmoUniforms.sunDir.value.copy(sunDir);
            atmoUniforms.cameraPos.value.copy(camera.position);

            renderBloom();
            finalComposer.render();
          }
          animate();

          // --------- FIX rotation errors: debounced + "settle" resize ----------
          function applyResize(){
            const vv = window.visualViewport;
            const w = Math.round((vv?.width  ?? window.innerWidth)  || 0);
            const h = Math.round((vv?.height ?? window.innerHeight) || 0);
            if (w < 60 || h < 60) return;

            if (w === lastSize.w && h === lastSize.h) return;
            lastSize = { w, h };

            resizing = true;

            camera.aspect = w / h;
            camera.updateProjectionMatrix();

            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.45));
            renderer.setSize(w, h, false);

            bloomComposer.setSize(w, h);
            finalComposer.setSize(w, h);
            bloomPass.setSize(w, h);

            // give iOS a beat to stabilize before resuming draws
            setTimeout(()=>{ resizing = false; }, 140);
          }

          function queueResize(){
            debounce(applyResize, 220);
          }

          window.addEventListener("resize", queueResize, { passive:true });
          window.addEventListener("orientationchange", queueResize, { passive:true });
          window.visualViewport?.addEventListener("resize", queueResize, { passive:true });

          // settle pass (important for iOS)
          setTimeout(applyResize, 380);

          // Switchboard group hide/show already handled above
        } catch (err){
          showError("Top-level error:\n" + (err?.stack || err?.message || err));
        }
      })();
    </script>
  </body>
</html>
