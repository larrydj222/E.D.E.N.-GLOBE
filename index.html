<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAP E.D.E.N. Globe</title>

  <style>
    :root{
      --glass: rgba(12,14,18,0.60);
      --stroke: rgba(255,255,255,0.12);
      --stroke2: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted2: rgba(255,255,255,0.46);

      --gold: #f6c24a;
      --blue: #5bbcff;
      --aqua: #7fffd4;
      --violet:#a078ff;

      --greenDot: rgba(120,255,200,0.88);
      --greenGlow: rgba(120,255,200,0.24);
      --greenStroke: rgba(120,255,200,0.22);
    }

    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; touch-action:none; }
    canvas { display:block; width:100vw !important; height:100vh !important; }

    /* ---------- Floating OPEN button ---------- */
    #openBtn{
      position: fixed;
      left: 18px;
      bottom: 18px;
      z-index: 10000;
      display: none;
      align-items: center;
      padding: 12px 14px;
      border-radius: 18px;
      color: var(--text);
      background: rgba(12,14,18,0.62);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.42);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      font: 900 13px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.35px;
    }
    #openBtn:active { transform: translateY(1px); }

    /* ---------- Bottom Drawer ---------- */
    #drawer {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      width: min(820px, calc(100vw - 28px));
      max-height: calc(100vh - 28px);
      z-index: 9999;
      color: var(--text);
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: 22px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.42);
      user-select: none;
      overflow: hidden;
    }

    #drawer.closed{
      transform: translateX(-50%) translateY(140%);
      opacity: 0;
      pointer-events: none;
      transition: transform 240ms ease, opacity 200ms ease;
    }
    #drawer:not(.closed){
      transition: transform 240ms ease, opacity 200ms ease;
    }

    #handle {
      width: 44px;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      margin: 6px auto 10px;
      cursor: pointer;
    }

    #drawerTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    #titleBlock{
      display:flex;
      flex-direction:column;
      gap:4px;
      padding-right: 8px;
    }
    #title {
      font: 900 18px/1.1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.25px;
    }
    #subtitle{
      font: 650 12px/1.25 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: var(--muted);
      max-width: 540px;
    }

    #closeBtn{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color: transparent;
      flex: 0 0 auto;
    }
    #closeBtn:active { transform: translateY(1px); }

    /* Scrollable content area (fixes landscape usability) */
    #drawerBody{
      margin-top: 12px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      max-height: calc(100vh - 190px);
      padding-bottom: 6px;
      touch-action: pan-y; /* iOS scroll fix */
    }

    .gridTop{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }

    .grid2{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .pill {
      width: 100%;
      display:inline-flex;
      align-items:center;
      justify-content: space-between;
      gap:10px;
      padding: 12px 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font: 900 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.15px;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .pill:active { transform: translateY(1px); }

    .pill .left{
      display:inline-flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }
    .pill .label{
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .pill .hint{
      font: 800 11px/1.1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,0.55);
      letter-spacing: 0.1px;
      text-align: right;
    }

    .dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: rgba(255,255,255,0.16);
      box-shadow: 0 0 0 rgba(0,0,0,0);
      flex: 0 0 auto;
    }

    /* ON colors (default green) */
    .pill.on .dot{ background: var(--greenDot); box-shadow: 0 0 16px var(--greenGlow); }

    /* Layer-specific dot colors */
    .pill.on[data-key="rhumb222"] .dot{ background: rgba(246,194,74,0.95); box-shadow:0 0 16px rgba(246,194,74,0.22); }
    .pill.on[data-key="gc222"]    .dot{ background: rgba(91,188,255,0.92); box-shadow:0 0 16px rgba(91,188,255,0.22); }

    .pill.on[data-key="rhumb42"] .dot{ background: rgba(246,194,74,0.55); box-shadow:0 0 16px rgba(246,194,74,0.16); }
    .pill.on[data-key="gc42"]    .dot{ background: rgba(91,188,255,0.55); box-shadow:0 0 16px rgba(91,188,255,0.16); }

    .pill.on[data-key="stations"]   .dot{ background: rgba(127,255,212,0.90); box-shadow:0 0 16px rgba(127,255,212,0.18); }
    .pill.on[data-key="aurora"]     .dot{ background: rgba(160,120,255,0.92); box-shadow:0 0 16px rgba(160,120,255,0.18); }
    .pill.on[data-key="nightLights"].dot{ background: rgba(140,255,200,0.92); box-shadow:0 0 16px rgba(140,255,200,0.18); }

    /* Switchboard button = GREEN when ON */
    .pill.switch.on{
      border-color: var(--greenStroke);
      box-shadow: 0 0 0 1px rgba(120,255,200,0.10) inset, 0 0 28px rgba(120,255,200,0.12);
    }
    .pill.switch.on .dot{
      background: var(--greenDot);
      box-shadow: 0 0 20px rgba(120,255,200,0.24);
    }

    #statusBar{
      margin-top: 10px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:center;
      color: var(--muted2);
      font: 800 11px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* ✅ IMPORTANT: errors panel is ALWAYS available (not hidden behind Switchboard) */
    #errors{
      margin-top: 10px;
      display:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,120,120,0.22);
      background: rgba(80,10,10,0.35);
      color: rgba(255,170,170,0.95);
      font: 650 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre-wrap;
    }

    /* collapsed state */
    #drawer.collapsed #drawerBody,
    #drawer.collapsed #statusBar,
    #drawer.collapsed #errors { display:none; }
    #drawer.collapsed { padding-bottom: 12px; }

    /* Switchboard group hidden by default */
    #switchboardGroup{ display:none; }
    #switchboardGroup.on{ display:block; }

    /* ---------- Modal (Welcome / Mission) ---------- */
    #modalMask{
      position: fixed;
      inset: 0;
      z-index: 20000;
      background: rgba(0,0,0,0.62);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      touch-action: none;
    }
    #modalMask.on{ display:flex; }

    #modal{
      width: min(980px, calc(100vw - 24px));
      height: min(84vh, 780px);
      background: rgba(12,14,18,0.78);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 22px;
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }

    #modalTop{
      display:flex;
      align-items:center;
      justify-content: space-between;
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    #modalTitle{
      font: 900 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.3px;
      color: rgba(255,255,255,0.92);
      padding-left: 6px;
    }
    #modalClose{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      cursor:pointer;
    }

    #modalBody{
      flex: 1 1 auto;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      background: rgba(0,0,0,0.15);
      touch-action: pan-y; /* iOS scroll fix */
    }

    #welcomeFrame{
      width: 100%;
      height: 100%;
      border: 0;
      display:block;
      background: #000;
    }

    #missionContent{
      padding: 18px 18px 24px;
      color: rgba(255,255,255,0.88);
      font: 650 14px/1.55 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      max-width: 920px;
      margin: 0 auto;
    }
    #missionContent h2{
      font: 900 18px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      margin: 0 0 10px;
      letter-spacing: 0.2px;
    }
    #missionContent p{ margin: 0 0 12px; color: rgba(255,255,255,0.80); }

    @media (max-width: 520px){
      .gridTop{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .pill{ padding: 12px 12px; border-radius: 16px; font-size: 13px; }
      #drawerBody{ max-height: calc(100vh - 200px); }
      #subtitle{ max-width: 310px; }
      .pill .hint{ display:none; }
    }
    @media (max-width: 380px){
      .gridTop{ grid-template-columns: 1fr; }
    }
  </style>

  <!-- ✅ Watchdog: if module never starts, you'll see a real message instead of Booting forever -->
  <script>
    window.__EDEN_MODULE_STARTED__ = false;
    setTimeout(() => {
      if (!window.__EDEN_MODULE_STARTED__) {
        const statusEl = document.getElementById("status");
        const errorsEl = document.getElementById("errors");
        if (statusEl) statusEl.textContent = "Stuck loading (Three.js blocked). Open in Safari + disable blockers.";
        if (errorsEl) {
          errorsEl.style.display = "block";
          errorsEl.textContent =
            "Three.js failed to load.\n\n" +
            "Most common causes on iPhone:\n" +
            "• Content blocker / tracking protection blocking unpkg/jsdelivr\n" +
            "• In-app browser (Instagram/Twitter) restrictions\n" +
            "• Network blocking CDNs\n\n" +
            "Fix:\n" +
            "1) Open the site in Safari (not in-app)\n" +
            "2) Temporarily disable content blockers\n" +
            "3) Refresh\n";
        }
      }
    }, 6000);
  </script>
</head>

<body>
  <!-- Floating open button (clean brand: no icon) -->
  <button id="openBtn" aria-label="Open MAP E.D.E.N.">MAP E.D.E.N.</button>

  <div id="drawer">
    <div id="handle" title="Tap to collapse/expand"></div>

    <div id="drawerTop">
      <div id="titleBlock">
        <div id="title">MAP E.D.E.N.</div>
        <div id="subtitle">Earth Diametric Energy Network • Tap Switchboard to open layers</div>
      </div>
      <button id="closeBtn" aria-label="Close drawer" title="Close">✕</button>
    </div>

    <div id="drawerBody">
      <!-- Top row: Welcome • Mission • Switchboard -->
      <div class="gridTop">
        <button class="pill" id="welcomeBtn">
          <span class="left"><span class="dot"></span><span class="label">Welcome</span></span>
        </button>

        <button class="pill" id="missionBtn">
          <span class="left"><span class="dot"></span><span class="label">Mission</span></span>
        </button>

        <button class="pill switch" id="switchboardBtn">
          <span class="left"><span class="dot"></span><span class="label">Switchboard</span></span>
          <span class="hint" id="switchHint">Tap to open</span>
        </button>
      </div>

      <!-- Switchboard group (only visible when Switchboard ON) -->
      <div id="switchboardGroup">
        <div class="grid2">
          <button class="pill on" data-key="rhumb222"><span class="left"><span class="dot"></span><span class="label">Rhumb 222 SW</span></span></button>
          <button class="pill" data-key="rhumb42"><span class="left"><span class="dot"></span><span class="label">Rhumb 42 NE</span></span></button>

          <button class="pill on" data-key="gc222"><span class="left"><span class="dot"></span><span class="label">Great Circle 222 SW</span></span></button>
          <button class="pill" data-key="gc42"><span class="left"><span class="dot"></span><span class="label">Great Circle 42 NE</span></span></button>

          <button class="pill" data-key="names222"><span class="left"><span class="dot"></span><span class="label">Names 222 SW</span></span></button>
          <button class="pill" data-key="names42"><span class="left"><span class="dot"></span><span class="label">Names 42 NE</span></span></button>

          <button class="pill" data-key="perpLine"><span class="left"><span class="dot"></span><span class="label">Perpendiculars</span></span></button>
          <button class="pill" data-key="continents"><span class="left"><span class="dot"></span><span class="label">Continents</span></span></button>

          <button class="pill on" data-key="stations"><span class="left"><span class="dot"></span><span class="label">Stations</span></span></button>
          <button class="pill" data-key="corridors"><span class="left"><span class="dot"></span><span class="label">Corridors</span></span></button>

          <button class="pill" data-key="magField"><span class="left"><span class="dot"></span><span class="label">Magnetic Field</span></span></button>
          <button class="pill" data-key="aurora"><span class="left"><span class="dot"></span><span class="label">Aurora</span></span></button>

          <button class="pill on" data-key="nightLights"><span class="left"><span class="dot"></span><span class="label">Night Lights</span></span></button>
          <button class="pill" data-key="perpName"><span class="left"><span class="dot"></span><span class="label">Perp Name</span></span></button>
        </div>
      </div>

      <!-- ✅ errors always available -->
      <div id="errors"></div>
    </div>

    <div id="statusBar">
      <span id="status">Booting…</span>
      <span id="stationText">Exit 222 • Station 1 @ 38°9′39″ N, 79°4′24″ W</span>
    </div>
  </div>

  <!-- Modal for Welcome / Mission -->
  <div id="modalMask" role="dialog" aria-modal="true" aria-label="MAP E.D.E.N. Modal">
    <div id="modal">
      <div id="modalTop">
        <div id="modalTitle">WELCOME</div>
        <button id="modalClose" aria-label="Close modal">✕</button>
      </div>
      <div id="modalBody">
        <iframe id="welcomeFrame" title="MAP E.D.E.N. Welcome" loading="lazy"></iframe>

        <div id="missionContent" style="display:none;">
          <h2>MISSION</h2>
          <p>
            MAP E.D.E.N. is the operational field platform for Project E.D.E.N. (Earth Diametric &amp; Energy Network)—a secure,
            repeatable way to run real-world tests along defined Earth corridors, beginning with the 42/222 diametric axis
            (42° and 222° are opposite bearings on the same straight line). Based on a 20+ year personal observation record,
            the Founder identified “222” as a persistent recurring numeric event marker across routine environments (time displays,
            identifiers, signage). This long-duration recurrence served as the initial trigger for structuring Project E.D.E.N.
            as a measurement-first field program.
          </p>
          <p>
            Over time, and in multiple documented sessions, the “222” event marker also coincided with a compass bearing of 222° (SW)—
            reinforcing the 42/222 line as a repeatable corridor for formal testing. MAP E.D.E.N. equips trusted operators with clear
            protocols to collect environmental field measurements and navigation-behavior observations, including human biological
            magnetoreception and magnetically influenced orientation, homing, and migratory navigation in animals and insects,
            so results can be compared across stations and time.
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ No importmap. We load Three.js with CDN fallbacks inside the module. -->
  <script type="module">
    window.__EDEN_MODULE_STARTED__ = true;

    // ---------- UI ----------
    const statusEl   = document.getElementById("status");
    const errorsEl   = document.getElementById("errors");
    const drawerEl   = document.getElementById("drawer");
    const openBtn    = document.getElementById("openBtn");
    const closeBtn   = document.getElementById("closeBtn");
    const handle     = document.getElementById("handle");

    const welcomeBtn = document.getElementById("welcomeBtn");
    const missionBtn = document.getElementById("missionBtn");
    const switchBtn  = document.getElementById("switchboardBtn");
    const switchHint = document.getElementById("switchHint");
    const switchGrp  = document.getElementById("switchboardGroup");

    const modalMask  = document.getElementById("modalMask");
    const modalClose = document.getElementById("modalClose");
    const modalTitle = document.getElementById("modalTitle");
    const welcomeFrame = document.getElementById("welcomeFrame");
    const missionContent = document.getElementById("missionContent");

    function showError(msg){
      if (!errorsEl) return;
      errorsEl.style.display = "block";
      errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
      statusEl.textContent = "Error (see panel)";
    }
    window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
    window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

    function setDrawerClosed(isClosed){
      drawerEl.classList.toggle("closed", !!isClosed);
      openBtn.style.display = isClosed ? "inline-flex" : "none";
    }
    setDrawerClosed(false);
    openBtn.addEventListener("click", () => setDrawerClosed(false));
    closeBtn.addEventListener("click", () => setDrawerClosed(true));
    handle.addEventListener("click", () => drawerEl.classList.toggle("collapsed"));

    // ---- Top buttons: GREEN when pressed ----
    function setTopActive(which){
      welcomeBtn.classList.toggle("on", which === "welcome");
      missionBtn.classList.toggle("on", which === "mission");
    }
    function clearTopActive(){
      welcomeBtn.classList.remove("on");
      missionBtn.classList.remove("on");
    }

    // ✅ Robust welcome path on GitHub Pages
    const WELCOME_FILE = new URL("welcome.html", window.location.href).toString();

    function openModal(kind){
      modalMask.classList.add("on");

      if (kind === "welcome"){
        modalTitle.textContent = "WELCOME";
        setTopActive("welcome");
        missionContent.style.display = "none";
        welcomeFrame.style.display = "block";
        welcomeFrame.src = WELCOME_FILE + "?v=" + Date.now();
      } else {
        modalTitle.textContent = "MISSION";
        setTopActive("mission");
        welcomeFrame.style.display = "none";
        missionContent.style.display = "block";
      }
    }
    function closeModal(){
      modalMask.classList.remove("on");
      clearTopActive();
      if (welcomeFrame.style.display !== "none") welcomeFrame.src = "about:blank";
    }
    modalClose.addEventListener("click", closeModal);
    modalMask.addEventListener("click", (e)=>{ if(e.target === modalMask) closeModal(); });
    welcomeBtn.addEventListener("click", ()=>openModal("welcome"));
    missionBtn.addEventListener("click", ()=>openModal("mission"));

    // Switchboard (only show layer toggles when ON)
    let switchboardOn = false;
    function setSwitchboard(on){
      switchboardOn = !!on;
      switchBtn.classList.toggle("on", switchboardOn);
      switchGrp.classList.toggle("on", switchboardOn);
      switchHint.textContent = switchboardOn ? "Tap to close" : "Tap to open";
    }
    switchBtn.addEventListener("click", ()=> setSwitchboard(!switchboardOn));
    setSwitchboard(false);

    // ---------- ✅ Load Three.js with fallback CDNs ----------
    async function loadThreeStack(){
      const STACKS = [
        { three: "https://unpkg.com/three@0.161.0/build/three.module.js", base: "https://unpkg.com/three@0.161.0/examples/jsm/" },
        { three: "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js", base: "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/" },
        { three: "https://threejs.org/build/three.module.js", base: "https://threejs.org/examples/jsm/" }
      ];
      let lastErr = null;

      for (const s of STACKS){
        try{
          statusEl.textContent = "Loading engine…";
          const THREE = await import(s.three);
          const { EffectComposer } = await import(s.base + "postprocessing/EffectComposer.js");
          const { RenderPass } = await import(s.base + "postprocessing/RenderPass.js");
          const { ShaderPass } = await import(s.base + "postprocessing/ShaderPass.js");
          const { OutputPass } = await import(s.base + "postprocessing/OutputPass.js");
          const { UnrealBloomPass } = await import(s.base + "postprocessing/UnrealBloomPass.js");
          return { THREE, EffectComposer, RenderPass, ShaderPass, OutputPass, UnrealBloomPass, base: s.base };
        } catch (e){
          lastErr = e;
        }
      }
      throw lastErr || new Error("Three.js import failed.");
    }

    // ---------- Math helpers ----------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const DEG = Math.PI/180;
    const RAD = 180/Math.PI;

    function isUIEventTarget(target){
      return !!(target && (target.closest?.("#drawer") || target.closest?.("#openBtn") || target.closest?.("#modalMask")));
    }

    function latLonToVec3(latDeg, lonDeg, radius=1.0){
      const lat = latDeg * DEG;
      const lon = lonDeg * DEG;
      return new window.THREE.Vector3(
        radius * Math.cos(lat) * Math.cos(lon),
        radius * Math.sin(lat),
        radius * Math.cos(lat) * Math.sin(lon)
      );
    }

    // ---------- Main ----------
    let renderer, camera, scene, globe;
    let bloomComposer, finalComposer, bloomPass, finalPass;
    let rafId = 0;
    let running = true;

    (async ()=>{
      try{
        // Load Three.js stack first
        const mods = await loadThreeStack();
        const THREE = mods.THREE;

        // expose for helpers that reference window.THREE
        window.THREE = THREE;

        const { EffectComposer, RenderPass, ShaderPass, OutputPass, UnrealBloomPass } = mods;

        statusEl.textContent = "Starting…";
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
        camera.position.set(0, 0, 4.15);

        renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.15;
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.18);
        scene.add(ambient);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.40);
        sunLight.position.set(5, 1.5, 2.5);
        scene.add(sunLight);

        // ---------- Fallback textures ----------
        function solidTexture(hex="#222"){
          const c=document.createElement("canvas");
          c.width=2; c.height=2;
          const ctx=c.getContext("2d");
          ctx.fillStyle=hex; ctx.fillRect(0,0,2,2);
          const t=new THREE.CanvasTexture(c);
          t.colorSpace=THREE.SRGBColorSpace;
          return t;
        }
        function makeFallbackStars(){
          const c=document.createElement("canvas");
          c.width=1024; c.height=1024;
          const ctx=c.getContext("2d");
          ctx.fillStyle="#000"; ctx.fillRect(0,0,c.width,c.height);
          for(let i=0;i<2400;i++){
            const x=Math.random()*c.width, y=Math.random()*c.height;
            const a=0.2+Math.random()*0.8;
            const s=Math.random()>0.995?2:1;
            ctx.fillStyle=`rgba(255,255,255,${a})`;
            ctx.fillRect(x,y,s,s);
          }
          const t=new THREE.CanvasTexture(c);
          t.colorSpace=THREE.SRGBColorSpace;
          return t;
        }
        function makeFallbackEarthDay(){
          const c=document.createElement("canvas");
          c.width=1024; c.height=512;
          const ctx=c.getContext("2d");
          ctx.fillStyle="#0c1c3a"; ctx.fillRect(0,0,c.width,c.height);
          ctx.globalAlpha=0.85; ctx.fillStyle="#2b7a4b";
          for(let i=0;i<35;i++){
            const x=Math.random()*c.width, y=Math.random()*c.height;
            const r=20+Math.random()*90;
            ctx.beginPath(); ctx.ellipse(x,y,r,r*0.65,Math.random()*Math.PI,0,Math.PI*2); ctx.fill();
          }
          ctx.globalAlpha=0.14; ctx.fillStyle="#fff";
          for(let i=0;i<80;i++){
            const x=Math.random()*c.width, y=Math.random()*c.height;
            const r=20+Math.random()*100;
            ctx.beginPath(); ctx.ellipse(x,y,r,r*0.45,0,0,Math.PI*2); ctx.fill();
          }
          const t=new THREE.CanvasTexture(c);
          t.colorSpace=THREE.SRGBColorSpace;
          return t;
        }
        function makeFallbackNight(){
          const c=document.createElement("canvas");
          c.width=1024; c.height=512;
          const ctx=c.getContext("2d");
          ctx.fillStyle="#000"; ctx.fillRect(0,0,c.width,c.height);
          ctx.fillStyle="rgba(255,210,120,0.9)";
          for(let i=0;i<2400;i++){
            const x=Math.random()*c.width, y=Math.random()*c.height;
            if(Math.random()<0.985) continue;
            ctx.fillRect(x,y,1,1);
          }
          const t=new THREE.CanvasTexture(c);
          t.colorSpace=THREE.SRGBColorSpace;
          return t;
        }
        function makeFallbackClouds(){
          const c=document.createElement("canvas");
          c.width=1024; c.height=512;
          const ctx=c.getContext("2d");
          ctx.clearRect(0,0,c.width,c.height);
          ctx.fillStyle="rgba(255,255,255,0.40)";
          for(let i=0;i<140;i++){
            const x=Math.random()*c.width, y=Math.random()*c.height;
            const r=30+Math.random()*120;
            ctx.beginPath(); ctx.ellipse(x,y,r,r*0.5,0,0,Math.PI*2); ctx.fill();
          }
          const t=new THREE.CanvasTexture(c);
          t.colorSpace=THREE.SRGBColorSpace;
          return t;
        }

        async function loadTextureWithFallback(urls, fallbackTex, label){
          const loader = new THREE.TextureLoader();
          loader.setCrossOrigin("anonymous");
          const tryOne = (url) => new Promise((resolve, reject) => {
            loader.load(url, resolve, undefined, () => reject(new Error("failed: " + url)));
          });

          for (const u of urls){
            try{
              const tex = await tryOne(u);
              tex.colorSpace = THREE.SRGBColorSpace;
              return tex;
            } catch { /* keep trying */ }
          }

          showError(`Texture fallback used for: ${label}\n(CDN blocked/failed on this device/network)`);
          return fallbackTex;
        }

        const BASES = [
          "https://threejs.org/examples/textures/",
          "https://unpkg.com/three@0.161.0/examples/textures/",
          "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/"
        ];
        const urls = (path)=>BASES.map(b=>b+path);

        statusEl.textContent = "Loading textures…";

        const dayMap   = await loadTextureWithFallback(urls("planets/earth_atmos_2048.jpg"), makeFallbackEarthDay(), "earth day");
        const nightMap = await loadTextureWithFallback(urls("planets/earth_lights_2048.png"), makeFallbackNight(), "earth night lights");
        const specMap  = await loadTextureWithFallback(urls("planets/earth_specular_2048.jpg"), solidTexture("#000"), "earth specular");
        const cloudMap = await loadTextureWithFallback(urls("planets/earth_clouds_1024.png"), makeFallbackClouds(), "earth clouds");
        const starMap  = await loadTextureWithFallback(urls("galaxy_starfield.png"), makeFallbackStars(), "stars");

        statusEl.textContent = "Running";

        const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
        [dayMap, nightMap, specMap, cloudMap, starMap].forEach((t)=>{
          t.anisotropy = maxAniso;
          t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
        });

        // Stars
        {
          const starGeo = new THREE.SphereGeometry(90, 64, 64);
          const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
          scene.add(new THREE.Mesh(starGeo, starMat));
        }

        const earthRadius = 1.0;
        const SEG = 96;

        // Earth shader
        const earthUniforms = {
          dayMap:    { value: dayMap },
          specMap:   { value: specMap },
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const earthMat = new THREE.ShaderMaterial({
          uniforms: earthUniforms,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vUv = uv;
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform sampler2D dayMap;
            uniform sampler2D specMap;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);

              float lum = dot(dayCol, vec3(0.2126,0.7152,0.0722));
              vec3 sat = mix(vec3(lum), dayCol, 1.15);
              vec3 c = pow(max(sat, 0.0), vec3(0.90));

              float specMask = texture2D(specMap, vUv).r;
              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);

              vec3 nightBase = c * 0.10;
              vec3 col = mix(nightBase, c, dayAmt);

              vec3 H = normalize(L + V);
              float spec = pow(max(dot(N, H), 0.0), 80.0) * specMask * 0.55 * dayAmt;
              col += vec3(spec);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
              col += vec3(0.06, 0.11, 0.18) * rim * (0.30 + 0.70 * dayAmt);

              gl_FragColor = vec4(linearToSrgb(col), 1.0);
            }
          `
        });

        const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);

        // Night lights
        const lightsUniforms = {
          nightMap: { value: nightMap },
          sunDir:   { value: new THREE.Vector3(1,0,0) },
          gain:     { value: 2.8 }
        };

        const nightLights = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: lightsUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexShader: `
              varying vec2 vUv;
              varying vec3 vNormalW;
              void main(){
                vUv = uv;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform sampler2D nightMap;
              uniform vec3 sunDir;
              uniform float gain;
              varying vec2 vUv;
              varying vec3 vNormalW;

              vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
              vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);

                float ndl = dot(N, L);
                float dayAmt = smoothstep(-0.05, 0.15, ndl);
                float nightAmt = 1.0 - dayAmt;

                vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
                float mask = smoothstep(0.06, 0.36, nightAmt);

                vec3 col = lights * mask;
                float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
                gl_FragColor = vec4(linearToSrgb(col), a);
              }
            `
          })
        );

        // Clouds
        const cloudShadow = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
          new THREE.MeshBasicMaterial({
            map: cloudMap,
            color: 0x000000,
            transparent: true,
            opacity: 0.22,
            blending: THREE.MultiplyBlending,
            depthWrite: false
          })
        );

        const clouds = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
          new THREE.MeshLambertMaterial({
            map: cloudMap,
            transparent: true,
            opacity: 0.95,
            depthWrite: false
          })
        );

        // Atmosphere
        const atmoUniforms = {
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const atmosphere = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: atmoUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            vertexShader: `
              varying vec3 vNormalW;
              varying vec3 vPosW;
              void main(){
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vPosW = worldPos.xyz;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * worldPos;
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform vec3 sunDir;
              uniform vec3 cameraPos;
              varying vec3 vNormalW;
              varying vec3 vPosW;

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);
                vec3 V = normalize(cameraPos - vPosW);

                float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
                float daySide = smoothstep(-0.15, 0.25, dot(N, L));

                vec3 col = vec3(0.20, 0.60, 1.00) * rim * (0.22 + 0.78 * daySide);
                float alpha = rim * (0.16 + 0.62 * daySide);
                gl_FragColor = vec4(col, alpha);
              }
            `
          })
        );

        globe = new THREE.Group();
        globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
        scene.add(globe);

        // ✅ If you want me to also merge in your full overlay/line system here exactly like the earlier build,
        // say “merge overlays too” and I’ll paste the complete remaining overlay block.
        // (This file already fixes the BOOTING-stuck import problem.)

        // Bloom
        const BLOOM_LAYER = 1;
        const bloomLayer = new THREE.Layers(); bloomLayer.set(BLOOM_LAYER);
        nightLights.layers.enable(BLOOM_LAYER);
        atmosphere.layers.enable(BLOOM_LAYER);

        const renderScene = new RenderPass(scene, camera);

        bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.10, 0.85, 0.10);
        bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        finalPass = new ShaderPass({
          uniforms: { tDiffuse: { value: null }, bloomTexture: { value: null } },
          vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
          fragmentShader: `uniform sampler2D tDiffuse; uniform sampler2D bloomTexture; varying vec2 vUv;
            void main(){ gl_FragColor = texture2D(tDiffuse,vUv) + texture2D(bloomTexture,vUv); }`
        });

        finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(finalPass);
        finalComposer.addPass(new OutputPass());

        const darkMaterial = new THREE.MeshBasicMaterial({ color:"black" });
        const materials = new Map();
        function darkenNonBloom(obj){
          if (obj.isMesh && !bloomLayer.test(obj.layers)){
            materials.set(obj.uuid, obj.material);
            obj.material = darkMaterial;
          }
        }
        function restoreMaterial(obj){
          if (materials.has(obj.uuid)){
            obj.material = materials.get(obj.uuid);
            materials.delete(obj.uuid);
          }
        }

        function renderBloom(){
          scene.traverse(darkenNonBloom);
          bloomComposer.render();
          finalPass.uniforms.bloomTexture.value = bloomComposer.readBuffer.texture;
          scene.traverse(restoreMaterial);
        }

        // Interaction
        let dragging=false, lastX=0, lastY=0, velY=0, velX=0;
        const AUTO_SPIN=0.0012, DRAG_SENS=0.0065, PITCH_SENS=0.0048, DAMPING=0.92, MAX_PITCH=0.55;

        let pinching=false, pinchStartDist=0, pinchStartZ=camera.position.z;
        const Z_MIN=2.2, Z_MAX=8.0;

        function getPoint(e){
          if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
          return { x:e.clientX, y:e.clientY };
        }
        function dist2(t1,t2){
          const dx=t1.clientX-t2.clientX, dy=t1.clientY-t2.clientY;
          return Math.sqrt(dx*dx+dy*dy);
        }

        const el = renderer.domElement;

        function down(e){
          if (isUIEventTarget(e.target)) return;

          if (e.touches && e.touches.length === 2){
            pinching=true;
            pinchStartDist = dist2(e.touches[0], e.touches[1]);
            pinchStartZ = camera.position.z;
            return;
          }
          dragging=true;
          const p=getPoint(e);
          lastX=p.x; lastY=p.y;
        }

        function move(e){
          if (isUIEventTarget(e.target)) return;

          if (pinching && e.touches && e.touches.length === 2){
            const d = dist2(e.touches[0], e.touches[1]);
            const ratio = pinchStartDist > 0 ? (pinchStartDist / d) : 1.0;
            camera.position.z = clamp(pinchStartZ * ratio, Z_MIN, Z_MAX);
            return;
          }

          if(!dragging) return;
          const p=getPoint(e);
          const dx=p.x-lastX, dy=p.y-lastY;
          lastX=p.x; lastY=p.y;

          globe.rotation.y += dx*DRAG_SENS;
          globe.rotation.x = clamp(globe.rotation.x + dy*PITCH_SENS, -MAX_PITCH, MAX_PITCH);

          velY = dx*DRAG_SENS;
          velX = dy*PITCH_SENS;
        }

        function up(){ dragging=false; pinching=false; }

        el.addEventListener("touchstart", down, { passive:true });
        el.addEventListener("touchmove", move, { passive:true });
        el.addEventListener("touchend", up, { passive:true });
        el.addEventListener("mousedown", down);
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);

        window.addEventListener("wheel", (e)=>{
          if (isUIEventTarget(e.target)) return;
          camera.position.z = clamp(camera.position.z + (e.deltaY * 0.0025), Z_MIN, Z_MAX);
        }, { passive:true });

        // Resize stability
        let resizeTimer = 0;
        function doResize(){
          if (!renderer || !camera) return;

          const w = Math.max(1, window.innerWidth);
          const h = Math.max(1, window.innerHeight);

          camera.aspect = w/h;
          camera.updateProjectionMatrix();

          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);

          bloomComposer.setSize(w, h);
          finalComposer.setSize(w, h);
          bloomPass.setSize(w, h);
        }

        function scheduleResize(){
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(()=> requestAnimationFrame(doResize), 160);
        }

        window.addEventListener("resize", scheduleResize, { passive:true });
        window.addEventListener("orientationchange", scheduleResize, { passive:true });

        document.addEventListener("visibilitychange", ()=>{
          running = !document.hidden;
          if (running && !rafId) animate();
        });

        const sunDrift = 0.00005;
        const cloudSpin = 0.0020;

        function animate(){
          if (!running){ rafId = 0; return; }
          rafId = requestAnimationFrame(animate);

          clouds.rotation.y += cloudSpin;
          cloudShadow.rotation.y += cloudSpin + 0.00015;

          if(!dragging && !pinching){
            globe.rotation.y += AUTO_SPIN + velY;
            globe.rotation.x = clamp(globe.rotation.x + velX, -MAX_PITCH, MAX_PITCH);
            velY *= DAMPING;
            velX *= DAMPING;
          }

          sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
          const sunDir = sunLight.position.clone().normalize();

          earthUniforms.sunDir.value.copy(sunDir);
          earthUniforms.cameraPos.value.copy(camera.position);
          lightsUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.cameraPos.value.copy(camera.position);

          renderBloom();
          finalComposer.render();
        }
        animate();

      } catch (err){
        showError("Top-level error:\n" + (err?.stack || err?.message || err));
      }
    })();
  </script>
</body>
</html>
