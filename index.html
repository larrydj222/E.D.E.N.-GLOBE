<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>E.D.E.N. Globe</title>

    <style>
      html, body { height:100%; margin:0; background:#000; overflow:hidden; touch-action:none; }
      canvas { display:block; width:100vw !important; height:100vh !important; }

      #hud{
        position:fixed; left:10px; bottom:10px; z-index:9999;
        font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial;
        font-size:12px; line-height:1.25;
        color:#d7d7d7; background:rgba(0,0,0,0.55);
        border:1px solid rgba(255,255,255,0.12);
        border-radius:10px; padding:10px 12px; max-width:88vw;
        backdrop-filter:blur(6px);
        user-select:none;
      }
      #hud b{ color:#fff; }
      #errors{ margin-top:8px; color:#ff9c9c; white-space:pre-wrap; display:none; }
      #hint{ margin-top:6px; color:#a9c7ff; }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <div id="hud">
      <div><b>Status:</b> <span id="status">Booting…</span></div>
      <div id="hint">Tap anywhere to toggle HUD. Use <b>?hud=1</b> to keep it on.</div>
      <div id="errors"></div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // ---------------- HUD / Errors ----------------
      const hud = document.getElementById("hud");
      const statusEl = document.getElementById("status");
      const errorsEl = document.getElementById("errors");
      const urlParams = new URLSearchParams(location.search);
      const FORCE_HUD = urlParams.get("hud") === "1";

      function setHUD(status, details=""){
        statusEl.textContent = status;
        errorsEl.style.display = details ? "block" : "none";
        errorsEl.textContent = details || "";
      }
      function showError(msg){
        errorsEl.style.display = "block";
        errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
        statusEl.textContent = "Error (see panel)";
        hud.style.display = "block";
      }

      window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
      window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

      window.addEventListener("click", () => {
        hud.style.display = (hud.style.display === "none") ? "block" : "none";
      });

      function autoHideHUD(){
        if (FORCE_HUD) return;
        setTimeout(() => { hud.style.display = "none"; }, 2200);
      }

      // ---------------- E.D.E.N. Axis Settings ----------------
      // Anchor (Staunton capture). If you want exact geocode, tell me and I’ll lock it.
      const ANCHOR_LAT = 38.160833;     // deg
      const ANCHOR_LON = -79.073056;    // deg

      // Axis headings (True bearings)
      const AXIS_BEARING = 42;          // deg
      // Opposite is 222 automatically included by full loops

      // Visual styling
      const GOLD = new THREE.Color(0xffd36b);   // Rhumb
      const BLUE = new THREE.Color(0x4db3ff);   // Great circle

      // ---------------- Scene tuning ----------------
      const BLOOM_STRENGTH  = 1.20;
      const BLOOM_RADIUS    = 0.85;
      const BLOOM_THRESHOLD = 0.10;

      const LIGHTS_GAIN   = 2.55;

      // Continents definition (stronger normal + slight contrast)
      const NORMAL_SCALE  = 1.10;
      const DAY_CONTRAST  = 1.10;

      // Axis geometry placement
      const AXIS_ALT = 1.020;      // slightly above surface
      const AXIS_OUTER_R = 0.010;  // glow tube radius
      const AXIS_INNER_R = 0.004;  // core tube radius

      // Motion
      const AUTO_SPIN  = 0.00125;
      const DRAG_SENS  = 0.0065;
      const PITCH_SENS = 0.0048;
      const DAMPING    = 0.92;
      const MAX_PITCH  = 0.55;

      // ---------------- Helpers ----------------
      const DEG2RAD = Math.PI / 180;
      function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
      function wrapLonRad(lam){
        // wrap to [-PI, PI]
        const TWO_PI = Math.PI * 2;
        lam = (lam + Math.PI) % TWO_PI;
        if (lam < 0) lam += TWO_PI;
        return lam - Math.PI;
      }

      function makeFallbackTexture(hex = "#222"){
        const c = document.createElement("canvas");
        c.width = c.height = 2;
        const ctx = c.getContext("2d");
        ctx.fillStyle = hex;
        ctx.fillRect(0,0,2,2);
        const t = new THREE.CanvasTexture(c);
        t.needsUpdate = true;
        return t;
      }

      function applyTexSettings(tex, { colorSpace=null, maxAniso=1, linear=true } = {}){
        if (colorSpace) tex.colorSpace = colorSpace;
        tex.anisotropy = maxAniso;
        tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        if (linear){
          tex.minFilter = THREE.LinearMipmapLinearFilter;
          tex.magFilter = THREE.LinearFilter;
        }
      }

      function latLonToVec3(latDeg, lonDeg, radius){
        const lat = latDeg * DEG2RAD;
        const lon = lonDeg * DEG2RAD;
        const cosLat = Math.cos(lat);
        return new THREE.Vector3(
          radius * cosLat * Math.cos(lon),
          radius * Math.sin(lat),
          radius * cosLat * Math.sin(lon)
        );
      }

      // Great-circle destination formula (from start, initial bearing, angular distance)
      function greatCirclePoint(lat1, lon1, bearingRad, delta){
        const sinLat1 = Math.sin(lat1), cosLat1 = Math.cos(lat1);
        const sinD = Math.sin(delta), cosD = Math.cos(delta);
        const sinBr = Math.sin(bearingRad), cosBr = Math.cos(bearingRad);

        const sinLat2 = sinLat1 * cosD + cosLat1 * sinD * cosBr;
        const lat2 = Math.asin(clamp(sinLat2, -1, 1));

        const y = sinBr * sinD * cosLat1;
        const x = cosD - sinLat1 * Math.sin(lat2);
        const lon2 = wrapLonRad(lon1 + Math.atan2(y, x));
        return { lat: lat2, lon: lon2 };
      }

      // Rhumb line stepping (loxodrome)
      function rhumbStep(lat1, lon1, bearingRad, d){
        // d is angular distance step (radians)
        const dPhi = d * Math.cos(bearingRad);
        let lat2 = lat1 + dPhi;

        // prevent singularities at poles
        lat2 = clamp(lat2, (-89.9)*DEG2RAD, (89.9)*DEG2RAD);

        const dPsi = Math.log(
          Math.tan(Math.PI/4 + lat2/2) / Math.tan(Math.PI/4 + lat1/2)
        );
        const q = (Math.abs(dPsi) > 1e-12) ? (dPhi / dPsi) : Math.cos(lat1);

        const dLam = d * Math.sin(bearingRad) / q;
        const lon2 = wrapLonRad(lon1 + dLam);
        return { lat: lat2, lon: lon2 };
      }

      function buildGreatCirclePoints(latDeg, lonDeg, bearingDeg, radius, stepDeg=0.75){
        const lat1 = latDeg * DEG2RAD;
        const lon1 = lonDeg * DEG2RAD;
        const br = bearingDeg * DEG2RAD;

        const pts = [];
        const step = stepDeg * DEG2RAD;
        for (let d = 0; d <= Math.PI*2 + step*0.5; d += step){
          const p = greatCirclePoint(lat1, lon1, br, d);
          // convert rad back to deg for vec
          const latOut = p.lat / DEG2RAD;
          const lonOut = p.lon / DEG2RAD;
          pts.push(latLonToVec3(latOut, lonOut, radius));
        }
        return pts;
      }

      function buildRhumbPoints(latDeg, lonDeg, bearingDeg, radius, stepDeg=0.35, maxSteps=5000){
        const lat1 = latDeg * DEG2RAD;
        const lon1 = lonDeg * DEG2RAD;
        const br = bearingDeg * DEG2RAD;

        const step = stepDeg * DEG2RAD;

        // forward
        let lat = lat1, lon = lon1;
        const fwd = [latLonToVec3(latDeg, lonDeg, radius)];
        for (let i=0; i<maxSteps; i++){
          const p = rhumbStep(lat, lon, br, step);
          lat = p.lat; lon = p.lon;
          fwd.push(latLonToVec3(lat/DEG2RAD, lon/DEG2RAD, radius));
          if (Math.abs(lat) > (89.7*DEG2RAD)) break; // near pole
        }

        // backward (bearing + 180)
        lat = lat1; lon = lon1;
        const back = [];
        const brBack = wrapLonRad(br + Math.PI); // bearing rad wrap ok
        for (let i=0; i<maxSteps; i++){
          const p = rhumbStep(lat, lon, brBack, step);
          lat = p.lat; lon = p.lon;
          back.push(latLonToVec3(lat/DEG2RAD, lon/DEG2RAD, radius));
          if (Math.abs(lat) > (89.7*DEG2RAD)) break;
        }

        // combine: reverse(back) + fwd
        back.reverse();
        return back.concat(fwd);
      }

      function makeGlowTube(points, color, outerR, innerR){
        const curve = new THREE.CatmullRomCurve3(points, false, "catmullrom", 0.05);
        const tubularSegments = Math.max(300, points.length * 2);

        const outer = new THREE.Mesh(
          new THREE.TubeGeometry(curve, tubularSegments, outerR, 14, false),
          new THREE.MeshBasicMaterial({
            color,
            transparent:true,
            opacity:0.22,
            blending:THREE.AdditiveBlending,
            depthWrite:false
          })
        );

        const inner = new THREE.Mesh(
          new THREE.TubeGeometry(curve, tubularSegments, innerR, 10, false),
          new THREE.MeshBasicMaterial({
            color,
            transparent:true,
            opacity:0.92,
            blending:THREE.AdditiveBlending,
            depthWrite:false
          })
        );

        const g = new THREE.Group();
        g.add(outer, inner);
        return g;
      }

      async function tryLoadTexture(url){
        return new Promise((resolve, reject) => {
          const loader = new THREE.TextureLoader();
          loader.setCrossOrigin("anonymous");
          loader.load(url, resolve, undefined, reject);
        });
      }
      async function loadFirst(urls){
        for (const u of urls){
          try{
            const tex = await tryLoadTexture(u);
            return { tex, used: u };
          } catch {}
        }
        return { tex: null, used: "(fallback)" };
      }

      // ---------------- Main ----------------
      try {
        setHUD("Booting…");

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
        camera.position.set(0, 0, 4.2);

        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:"high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.setClearColor(0x000000, 1);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        renderer.domElement.addEventListener("webglcontextlost", (e) => {
          e.preventDefault();
          showError("WebGL context lost.\nTry reloading the page.");
        }, false);

        const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.10));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
        sunLight.position.set(5, 1.5, 2.5);
        scene.add(sunLight);

        // Fallback textures (renders instantly)
        const dayMap    = makeFallbackTexture("#1f2b3a");
        const nightMap  = makeFallbackTexture("#000");
        const specMap   = makeFallbackTexture("#111");
        const normalMap = makeFallbackTexture("#8080ff");
        const cloudMap  = makeFallbackTexture("#222");
        const starMap   = makeFallbackTexture("#000");

        applyTexSettings(dayMap,   { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(nightMap, { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(cloudMap, { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(starMap,  { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(specMap,   { colorSpace: THREE.NoColorSpace, maxAniso });
        applyTexSettings(normalMap, { colorSpace: THREE.NoColorSpace, maxAniso });

        // Stars background
        {
          const starGeo = new THREE.SphereGeometry(90, 64, 64);
          const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
          scene.add(new THREE.Mesh(starGeo, starMat));
        }

        const earthRadius = 1.0;
        const SEG = 96;

        // Earth shader with normal map (continents definition)
        const earthUniforms = {
          dayMap:      { value: dayMap },
          specMap:     { value: specMap },
          normalMap:   { value: normalMap },
          normalScale: { value: NORMAL_SCALE },
          dayContrast: { value: DAY_CONTRAST },
          sunDir:      { value: new THREE.Vector3(1,0,0) },
          cameraPos:   { value: new THREE.Vector3() }
        };

        const earthMat = new THREE.ShaderMaterial({
          uniforms: earthUniforms,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vUv = uv;
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;

            uniform sampler2D dayMap;
            uniform sampler2D specMap;
            uniform sampler2D normalMap;
            uniform float normalScale;
            uniform float dayContrast;

            uniform vec3 sunDir;
            uniform vec3 cameraPos;

            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            vec3 perturbNormal(vec3 surfPos, vec3 surfNorm, vec2 uv){
              vec3 map = texture2D(normalMap, uv).xyz * 2.0 - 1.0;
              map.xy *= normalScale;

              vec3 dp1 = dFdx(surfPos);
              vec3 dp2 = dFdy(surfPos);
              vec2 duv1 = dFdx(uv);
              vec2 duv2 = dFdy(uv);

              vec3 dp2perp = cross(dp2, surfNorm);
              vec3 dp1perp = cross(surfNorm, dp1);
              vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
              vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

              float invmax = inversesqrt(max(dot(T,T), dot(B,B)));
              mat3 TBN = mat3(T*invmax, B*invmax, surfNorm);
              return normalize(TBN * map);
            }

            void main(){
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              vec3 N0 = normalize(vNormalW);
              vec3 N = perturbNormal(vPosW, N0, vUv);

              vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
              dayCol = pow(dayCol, vec3(1.0/dayContrast));

              float specMask = texture2D(specMap, vUv).r;

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);

              vec3 nightBase = dayCol * 0.09;
              vec3 col = mix(nightBase, dayCol, dayAmt);

              vec3 H = normalize(L + V);
              float spec = pow(max(dot(N, H), 0.0), 95.0) * specMask * 0.55 * dayAmt;
              col += vec3(spec);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
              col += vec3(0.06, 0.10, 0.18) * rim * (0.30 + 0.70 * dayAmt);

              gl_FragColor = vec4(linearToSrgb(col), 1.0);
            }
          `
        });

        const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);
        scene.add(earth);

        // Night lights (bloom target)
        const lightsUniforms = {
          nightMap: { value: nightMap },
          sunDir:   { value: new THREE.Vector3(1,0,0) },
          gain:     { value: LIGHTS_GAIN }
        };

        const nightLights = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: lightsUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexShader: `
              varying vec2 vUv;
              varying vec3 vNormalW;
              void main(){
                vUv = uv;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform sampler2D nightMap;
              uniform vec3 sunDir;
              uniform float gain;
              varying vec2 vUv;
              varying vec3 vNormalW;

              vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
              vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);

                float ndl = dot(N, L);
                float dayAmt = smoothstep(-0.05, 0.15, ndl);
                float nightAmt = 1.0 - dayAmt;

                vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
                float mask = smoothstep(0.05, 0.35, nightAmt);

                vec3 col = lights * mask;
                float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
                gl_FragColor = vec4(linearToSrgb(col), a);
              }
            `
          })
        );
        scene.add(nightLights);

        // Clouds
        const cloudShadow = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
          new THREE.MeshBasicMaterial({
            map: cloudMap,
            color: 0x000000,
            transparent: true,
            opacity: 0.28,
            blending: THREE.MultiplyBlending,
            depthWrite: false
          })
        );
        scene.add(cloudShadow);

        const clouds = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
          new THREE.MeshLambertMaterial({
            map: cloudMap,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
          })
        );
        scene.add(clouds);

        // Atmosphere (bloom target)
        const atmoUniforms = {
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const atmosphere = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: atmoUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            vertexShader: `
              varying vec3 vNormalW;
              varying vec3 vPosW;
              void main(){
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vPosW = worldPos.xyz;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * worldPos;
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform vec3 sunDir;
              uniform vec3 cameraPos;
              varying vec3 vNormalW;
              varying vec3 vPosW;

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);
                vec3 V = normalize(cameraPos - vPosW);

                float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
                float daySide = smoothstep(-0.15, 0.25, dot(N, L));

                vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
                float alpha = rim * (0.18 + 0.62 * daySide);
                gl_FragColor = vec4(col, alpha);
              }
            `
          })
        );
        scene.add(atmosphere);

        // ---------------- E.D.E.N. Axis Geometry ----------------
        const axisRadius = earthRadius * AXIS_ALT;

        // Great circle (geodesic) in BLUE glow
        const gcPts = buildGreatCirclePoints(ANCHOR_LAT, ANCHOR_LON, AXIS_BEARING, axisRadius, 0.75);
        const greatCircle = makeGlowTube(gcPts, BLUE, AXIS_OUTER_R, AXIS_INNER_R);

        // Rhumb line (loxodrome) in GOLD glow
        const rhPts = buildRhumbPoints(ANCHOR_LAT, ANCHOR_LON, AXIS_BEARING, axisRadius, 0.35, 5000);
        const rhumbLine = makeGlowTube(rhPts, GOLD, AXIS_OUTER_R, AXIS_INNER_R);

        // Anchor marker
        const anchorMarker = new THREE.Mesh(
          new THREE.SphereGeometry(0.018, 18, 18),
          new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent:true,
            opacity:0.95,
            blending: THREE.AdditiveBlending,
            depthWrite:false
          })
        );
        anchorMarker.position.copy(latLonToVec3(ANCHOR_LAT, ANCHOR_LON, earthRadius * 1.026));

        // Group rotation (everything rotates together)
        const globe = new THREE.Group();
        scene.remove(earth, nightLights, cloudShadow, clouds, atmosphere);
        globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
        globe.add(greatCircle, rhumbLine, anchorMarker);
        scene.add(globe);

        // ---------------- Selective Bloom ----------------
        const BLOOM_LAYER = 1;
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_LAYER);

        // Bloom targets
        nightLights.layers.enable(BLOOM_LAYER);
        atmosphere.layers.enable(BLOOM_LAYER);
        greatCircle.traverse(o => o.layers && o.layers.enable(BLOOM_LAYER));
        rhumbLine.traverse(o => o.layers && o.layers.enable(BLOOM_LAYER));
        anchorMarker.layers.enable(BLOOM_LAYER);

        const darkMaterial = new THREE.MeshBasicMaterial({ color:"black" });
        const materials = new Map();
        function darkenNonBloom(obj){
          if (obj.isMesh && !bloomLayer.test(obj.layers)){
            materials.set(obj.uuid, obj.material);
            obj.material = darkMaterial;
          }
        }
        function restoreMaterial(obj){
          if (materials.has(obj.uuid)){
            obj.material = materials.get(obj.uuid);
            materials.delete(obj.uuid);
          }
        }

        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(innerWidth, innerHeight),
          BLOOM_STRENGTH,
          BLOOM_RADIUS,
          BLOOM_THRESHOLD
        );

        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        const finalPass = new ShaderPass({
          uniforms: { tDiffuse: { value: null }, bloomTexture: { value: null } },
          vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
          fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main(){
              vec4 base = texture2D(tDiffuse, vUv);
              vec4 bloom = texture2D(bloomTexture, vUv);
              gl_FragColor = base + bloom;
            }
          `
        });

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(finalPass);
        finalComposer.addPass(new OutputPass());

        function renderBloom(){
          scene.traverse(darkenNonBloom);
          bloomComposer.render();
          finalPass.uniforms.bloomTexture.value = bloomComposer.readBuffer.texture;
          scene.traverse(restoreMaterial);
        }

        // ---------------- Touch + Inertia ----------------
        let dragging=false, lastX=0, lastY=0, velY=0, velX=0;

        function getPoint(e){
          if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
          return { x:e.clientX, y:e.clientY };
        }
        function down(e){ dragging=true; const p=getPoint(e); lastX=p.x; lastY=p.y; }
        function move(e){
          if(!dragging) return;
          const p=getPoint(e);
          const dx=p.x-lastX, dy=p.y-lastY;
          lastX=p.x; lastY=p.y;

          globe.rotation.y += dx*DRAG_SENS;
          globe.rotation.x += dy*PITCH_SENS;
          globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));

          velY = dx*DRAG_SENS;
          velX = dy*PITCH_SENS;
        }
        function up(){ dragging=false; }

        const el = renderer.domElement;
        el.addEventListener("touchstart", down, { passive:true });
        el.addEventListener("touchmove", move, { passive:true });
        el.addEventListener("touchend", up, { passive:true });
        el.addEventListener("mousedown", down);
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);

        // ---------------- Animation ----------------
        const sunDrift = 0.00005;
        const cloudSpin = 0.0020;

        function animate(){
          requestAnimationFrame(animate);

          clouds.rotation.y += cloudSpin;
          cloudShadow.rotation.y += cloudSpin + 0.00015;

          if(!dragging){
            globe.rotation.y += AUTO_SPIN;
            globe.rotation.y += velY;
            globe.rotation.x += velX;
            velY *= DAMPING;
            velX *= DAMPING;
            globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));
          }

          sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
          const sunDir = sunLight.position.clone().normalize();

          earthUniforms.sunDir.value.copy(sunDir);
          earthUniforms.cameraPos.value.copy(camera.position);

          lightsUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.cameraPos.value.copy(camera.position);

          renderBloom();
          finalComposer.render();
        }
        animate();

        addEventListener("resize", () => {
          camera.aspect = innerWidth/innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
          bloomComposer.setSize(innerWidth, innerHeight);
          finalComposer.setSize(innerWidth, innerHeight);
          bloomPass.setSize(innerWidth, innerHeight);
        });

        // ---------------- Async texture upgrade (multi-CDN hot swap) ----------------
        setHUD("Loading textures…");

        const cdnJS = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/";
        const cdn3J = "https://threejs.org/examples/textures/";

        const sources = {
          day:    [cdnJS+"planets/earth_atmos_2048.jpg",     cdn3J+"planets/earth_atmos_2048.jpg"],
          night:  [cdnJS+"planets/earth_lights_2048.png",    cdn3J+"planets/earth_lights_2048.png"],
          spec:   [cdnJS+"planets/earth_specular_2048.jpg",  cdn3J+"planets/earth_specular_2048.jpg"],
          normal: [cdnJS+"planets/earth_normal_2048.jpg",    cdn3J+"planets/earth_normal_2048.jpg"],
          clouds: [cdnJS+"planets/earth_clouds_1024.png",    cdn3J+"planets/earth_clouds_1024.png"],
          stars:  [cdnJS+"galaxy_starfield.png",             cdn3J+"galaxy_starfield.png"]
        };

        const [dayRes, nightRes, specRes, normalRes, cloudRes, starsRes] = await Promise.all([
          loadFirst(sources.day),
          loadFirst(sources.night),
          loadFirst(sources.spec),
          loadFirst(sources.normal),
          loadFirst(sources.clouds),
          loadFirst(sources.stars),
        ]);

        if (dayRes.tex){
          applyTexSettings(dayRes.tex, { colorSpace: THREE.SRGBColorSpace, maxAniso });
          earthUniforms.dayMap.value = dayRes.tex;
        }
        if (nightRes.tex){
          applyTexSettings(nightRes.tex, { colorSpace: THREE.SRGBColorSpace, maxAniso });
          lightsUniforms.nightMap.value = nightRes.tex;
        }
        if (specRes.tex){
          applyTexSettings(specRes.tex, { colorSpace: THREE.NoColorSpace, maxAniso });
          earthUniforms.specMap.value = specRes.tex;
        }
        if (normalRes.tex){
          applyTexSettings(normalRes.tex, { colorSpace: THREE.NoColorSpace, maxAniso });
          earthUniforms.normalMap.value = normalRes.tex;
        }
        if (cloudRes.tex){
          applyTexSettings(cloudRes.tex, { colorSpace: THREE.SRGBColorSpace, maxAniso });
          cloudShadow.material.map = cloudRes.tex;
          clouds.material.map = cloudRes.tex;
          cloudShadow.material.needsUpdate = true;
          clouds.material.needsUpdate = true;
        }
        if (starsRes.tex){
          applyTexSettings(starsRes.tex, { colorSpace: THREE.SRGBColorSpace, maxAniso });
          scene.traverse((o) => {
            if (o.isMesh && o.material && o.material.map === starMap){
              o.material.map = starsRes.tex;
              o.material.needsUpdate = true;
            }
          });
        }

        setHUD(
          "Running",
          `Anchor: ${ANCHOR_LAT.toFixed(6)}, ${ANCHOR_LON.toFixed(6)}\nAxis bearings: 42° / 222°\n\nTextures:\nday: ${dayRes.used}\nnight: ${nightRes.used}\nspec: ${specRes.used}\nnormal: ${normalRes.used}\ncloud: ${cloudRes.used}\nstars: ${starsRes.used}`
        );
        autoHideHUD();

      } catch (err) {
        showError("Top-level error:\n" + (err?.stack || err?.message || err));
      }
    </script>
  </body>
</html>
