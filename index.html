<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>E.D.E.N. Globe</title>

  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }

    /* Minimal HUD (optional) */
    #hud {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 10;
      max-width: min(640px, calc(100vw - 24px));
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.25;
      color: rgba(255,255,255,0.85);
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #hud .label { opacity: 0.7; }
    #hud .err { color: #ff6b6b; }
    #hud .ok { color: #7CFC98; }
  </style>

  <!-- Import map so "three" resolves correctly on GitHub Pages -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>
  <div id="hud">
    <div><span class="label">Status:</span> <span id="status" class="ok">Loading…</span></div>
    <div id="detail" class="label">If you see errors, screenshot and send them here.</div>
    <div id="topErr" class="err"></div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

    // ----------------------------
    // Quick controls (tweak taste)
    // ----------------------------
    const SETTINGS = {
      // Bloom setup (your requested knobs)
      bloomStrength: 1.15,     // more/less glow
      bloomThreshold: 0.10,    // higher = glow only brightest pixels
      bloomRadius: 0.55,

      // City lights intensity
      lightsGain: 2.4,         // brighter city lights

      // Spin behavior
      earthSpin: 0.035,        // base rotation speed
      cloudsSpin: 0.055,       // clouds slightly faster
      terminatorDrift: 0.03,   // slow day/night shift (sun direction drift)

      // Atmosphere
      atmIntensity: 0.85,
      atmPower: 2.3,

      // Cloud shadows
      cloudShadowOpacity: 0.18
    };

    // If you ever want to host textures inside your repo instead of remote:
    // 1) create a /textures folder
    // 2) upload the files named below
    // 3) set USE_LOCAL_TEXTURES = true
    const USE_LOCAL_TEXTURES = false;

    // Remote textures (high-res day map for sharper continents)
    // These are three.js example textures mirrored on a static host.
    const REMOTE_BASE = "https://posibras.com/threejs/examples/textures/planets/";
    const TEX = {
      day:     "earth_atmos_4096.jpg",
      night:   "earth_lights_2048.png",
      normal:  "earth_normal_2048.jpg",
      spec:    "earth_specular_2048.jpg",
      clouds:  "earth_clouds_2048.png"
    };

    // Local texture paths (if USE_LOCAL_TEXTURES = true)
    const LOCAL_BASE = "./textures/";

    // HUD helpers
    const $status = document.getElementById("status");
    const $detail = document.getElementById("detail");
    const $topErr = document.getElementById("topErr");
    function setStatus(text, ok = true) {
      $status.textContent = text;
      $status.className = ok ? "ok" : "err";
    }
    function setTopError(msg) {
      $topErr.textContent = msg ? ("Top-level error:\n" + msg) : "";
    }

    // ----------------------------
    // Scene / Renderer / Camera
    // ----------------------------
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      35,
      window.innerWidth / window.innerHeight,
      0.01,
      200
    );
    camera.position.set(0, 0, 3.4);

    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: false,
      powerPreference: "high-performance"
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    document.body.appendChild(renderer.domElement);

    // ----------------------------
    // Post Processing (Bloom)
    // ----------------------------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      SETTINGS.bloomStrength,
      SETTINGS.bloomRadius,
      SETTINGS.bloomThreshold
    );
    composer.addPass(bloomPass);

    // ----------------------------
    // Lighting (for realism)
    // ----------------------------
    const ambient = new THREE.AmbientLight(0xffffff, 0.18);
    scene.add(ambient);

    // "Sun" light — we will drift its direction slowly for the terminator
    const sunLight = new THREE.DirectionalLight(0xffffff, 1.4);
    sunLight.position.set(2.2, 0.2, 1.6);
    scene.add(sunLight);

    // ----------------------------
    // Procedural Stars (no texture = no starfield loading errors)
    // ----------------------------
    function addStars() {
      const starCount = 2200;
      const radius = 60;
      const positions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        // Random points on a sphere
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = radius + (Math.random() * 10);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i * 3 + 0] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      const mat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.06,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.85
      });

      const stars = new THREE.Points(geo, mat);
      scene.add(stars);
      return stars;
    }
    addStars();

    // ----------------------------
    // Texture loading
    // ----------------------------
    const loader = new THREE.TextureLoader();
    loader.crossOrigin = "anonymous";

    const maxAniso = renderer.capabilities.getMaxAnisotropy();

    function loadTex(name) {
      const base = USE_LOCAL_TEXTURES ? LOCAL_BASE : REMOTE_BASE;
      const url = base + name;

      return new Promise((resolve, reject) => {
        loader.load(
          url,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = maxAniso;
            tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
            resolve(tex);
          },
          undefined,
          (err) => reject(new Error("Texture failed to load: " + url))
        );
      });
    }

    // ----------------------------
    // Earth: surface shader (day/night terminator + spec)
    // ----------------------------
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);

    const earthGeo = new THREE.SphereGeometry(1.0, 128, 128);

    function makeEarthMaterial({ dayMap, nightMap, normalMap, specMap }) {
      // Custom shader so we can do a real terminator mix + controllable night lights
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          dayMap:   { value: dayMap },
          nightMap: { value: nightMap },
          normalMap:{ value: normalMap },
          specMap:  { value: specMap },

          lightDir: { value: new THREE.Vector3().copy(sunLight.position).normalize() },
          lightsGain:{ value: SETTINGS.lightsGain },

          // terminator smoothing
          terminatorSoftness: { value: 0.22 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          void main() {
            vUv = uv;
            vec4 wp = modelMatrix * vec4(position, 1.0);
            vPosW = wp.xyz;
            vNormalW = normalize(mat3(modelMatrix) * normal);
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          precision highp float;

          uniform sampler2D dayMap;
          uniform sampler2D nightMap;
          uniform sampler2D normalMap;
          uniform sampler2D specMap;

          uniform vec3 lightDir;
          uniform float lightsGain;
          uniform float terminatorSoftness;

          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;

          // Tangent-space normal map without explicit tangents (approx via derivatives)
          vec3 perturbNormal(vec3 N, vec3 V, vec2 uv) {
            vec3 mapN = texture2D(normalMap, uv).xyz * 2.0 - 1.0;

            vec3 Q1 = dFdx(vPosW);
            vec3 Q2 = dFdy(vPosW);
            vec2 st1 = dFdx(uv);
            vec2 st2 = dFdy(uv);

            vec3 S = normalize(Q1 * st2.t - Q2 * st1.t);
            vec3 T = normalize(-Q1 * st2.s + Q2 * st1.s);
            mat3 TBN = mat3(S, T, N);

            return normalize(TBN * mapN);
          }

          void main() {
            vec3 V = normalize(cameraPosition - vPosW);
            vec3 N = normalize(vNormalW);
            N = perturbNormal(N, V, vUv);

            vec3 L = normalize(lightDir);

            float ndl = dot(N, L);

            // Soft terminator: smooth blend from night->day around ndl≈0
            float t = smoothstep(-terminatorSoftness, terminatorSoftness, ndl);

            vec3 dayCol = texture2D(dayMap, vUv).rgb;
            vec3 nightCol = texture2D(nightMap, vUv).rgb * lightsGain;

            // Base albedo mix
            vec3 base = mix(nightCol, dayCol, t);

            // Simple lighting model
            float diffuse = clamp(ndl, 0.0, 1.0);
            vec3 color = base * (0.22 + 0.78 * diffuse);

            // Specular (oceans pop more with spec map)
            float specMask = texture2D(specMap, vUv).r;
            vec3 R = reflect(-L, N);
            float spec = pow(max(dot(R, V), 0.0), 48.0) * specMask;
            color += vec3(1.0) * spec * 0.25;

            gl_FragColor = vec4(color, 1.0);
          }
        `
      });

      return mat;
    }

    // Atmosphere rim shader
    function makeAtmosphere() {
      const atmGeo = new THREE.SphereGeometry(1.045, 128, 128);
      const atmMat = new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        uniforms: {
          intensity: { value: SETTINGS.atmIntensity },
          power: { value: SETTINGS.atmPower }
        },
        vertexShader: `
          varying vec3 vNormalW;
          varying vec3 vPosW;
          void main() {
            vec4 wp = modelMatrix * vec4(position, 1.0);
            vPosW = wp.xyz;
            vNormalW = normalize(mat3(modelMatrix) * normal);
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader: `
          precision highp float;
          uniform float intensity;
          uniform float power;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          void main() {
            vec3 V = normalize(cameraPosition - vPosW);
            float rim = 1.0 - max(dot(normalize(vNormalW), V), 0.0);
            rim = pow(rim, power);
            vec3 col = vec3(0.35, 0.65, 1.0) * rim * intensity;
            gl_FragColor = vec4(col, rim);
          }
        `
      });

      return new THREE.Mesh(atmGeo, atmMat);
    }

    // Clouds layer + shadow layer
    function makeClouds(cloudTex) {
      cloudTex.colorSpace = THREE.SRGBColorSpace;
      cloudTex.anisotropy = maxAniso;

      const cloudsGeo = new THREE.SphereGeometry(1.012, 128, 128);
      const cloudsMat = new THREE.MeshPhongMaterial({
        map: cloudTex,
        transparent: true,
        opacity: 0.9,
        depthWrite: false
      });
      const clouds = new THREE.Mesh(cloudsGeo, cloudsMat);

      // Cloud shadow: same map, but dark and multiplied onto Earth
      const shadowGeo = new THREE.SphereGeometry(1.001, 128, 128);
      const shadowMat = new THREE.MeshBasicMaterial({
        map: cloudTex,
        color: 0x000000,
        transparent: true,
        opacity: SETTINGS.cloudShadowOpacity,
        blending: THREE.MultiplyBlending,
        depthWrite: false
      });
      const shadow = new THREE.Mesh(shadowGeo, shadowMat);

      return { clouds, shadow };
    }

    // ----------------------------
    // Build everything
    // ----------------------------
    try {
      setStatus("Loading textures…", true);

      const [dayMap, nightMap, normalMap, specMap, cloudMap] = await Promise.all([
        loadTex(TEX.day),
        loadTex(TEX.night),
        loadTex(TEX.normal),
        loadTex(TEX.spec),
        loadTex(TEX.clouds)
      ]);

      // Sharpen continents: correct filtering + anisotropy
      dayMap.minFilter = THREE.LinearMipmapLinearFilter;
      dayMap.magFilter = THREE.LinearFilter;

      const earthMat = makeEarthMaterial({ dayMap, nightMap, normalMap, specMap });
      const earth = new THREE.Mesh(earthGeo, earthMat);
      earthGroup.add(earth);

      const atmosphere = makeAtmosphere();
      earthGroup.add(atmosphere);

      const { clouds, shadow } = makeClouds(cloudMap);
      earthGroup.add(shadow);
      earthGroup.add(clouds);

      // Subtle tilt for a nicer look
      earthGroup.rotation.z = THREE.MathUtils.degToRad(23.4);

      setStatus("Running", true);
      $detail.textContent = "Tip: pull-to-refresh if you just deployed a change.";

      // ----------------------------
      // Animate
      // ----------------------------
      const clock = new THREE.Clock();

      function animate() {
        const t = clock.getElapsedTime();

        // Earth spins
        earth.rotation.y += SETTINGS.earthSpin * 0.01;

        // Clouds drift a little faster
        clouds.rotation.y += SETTINGS.cloudsSpin * 0.01;
        shadow.rotation.y += SETTINGS.cloudsSpin * 0.01;

        // Drift sun direction slowly (day/night terminator movement)
        const drift = t * SETTINGS.terminatorDrift * 0.08;
        const sunDir = new THREE.Vector3(
          Math.cos(drift) * 2.2,
          0.25,
          Math.sin(drift) * 1.6
        ).normalize();

        sunLight.position.copy(sunDir);
        earthMat.uniforms.lightDir.value.copy(sunDir);

        // Render with bloom
        composer.render();

        requestAnimationFrame(animate);
      }

      // Resize
      function onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;

        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        renderer.setSize(w, h);
        composer.setSize(w, h);
        bloomPass.setSize(w, h);
      }
      window.addEventListener("resize", onResize, { passive: true });

      animate();

    } catch (e) {
      console.error(e);
      setStatus("Error (see panel)", false);
      setTopError(e?.message || String(e));
      $detail.textContent = "If you see errors, screenshot and send them here.";

      // Also show something so the page isn't blank
      renderer.setClearColor(0x000000, 1);
      renderer.render(scene, camera);
    }

    // Safety net
    window.addEventListener("error", (ev) => {
      setStatus("Error (see panel)", false);
      setTopError(ev?.message || "Unknown error");
    });
  </script>
</body>
</html>
