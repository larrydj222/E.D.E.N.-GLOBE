<!-- index.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAP E.D.E.N. Globe</title>

  <style>
    :root{
      --glass: rgba(12,14,18,0.58);
      --stroke: rgba(255,255,255,0.12);
      --stroke2: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.68);
      --muted2: rgba(255,255,255,0.45);

      --gold: #f6c24a;   /* rhumb */
      --blue: #5bbcff;   /* great circle */
      --aqua: #7fffd4;   /* stations */
      --violet: #a078ff; /* aurora */
    }

    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; touch-action:none; }
    canvas { display:block; width:100vw !important; height:100vh !important; }

    /* ---------- Floating OPEN button ---------- */
    #openBtn{
      position: fixed;
      left: 18px;
      bottom: 18px;
      z-index: 10000;
      display: none; /* shown only when drawer closed */
      align-items: center;
      padding: 12px 14px;
      border-radius: 18px;
      color: var(--text);
      background: rgba(12,14,18,0.62);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.42);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      font: 900 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.2px;
    }
    #openBtn:active { transform: translateY(1px); }

    /* ---------- Bottom Drawer ---------- */
    #drawer {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      width: min(720px, calc(100vw - 28px));
      z-index: 9999;
      color: var(--text);
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: 22px;
      padding: 14px 14px 16px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.42);
      user-select: none;
    }

    #drawer.closed{
      transform: translateX(-50%) translateY(140%);
      opacity: 0;
      pointer-events: none;
      transition: transform 240ms ease, opacity 200ms ease;
    }
    #drawer:not(.closed){
      transition: transform 240ms ease, opacity 200ms ease;
    }

    #handle {
      width: 44px;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      margin: 6px auto 10px;
      cursor: pointer;
    }

    #drawerTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }

    #titleBlock{
      display:flex;
      flex-direction:column;
      gap:4px;
    }

    #title {
      font: 900 18px/1.1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.2px;
    }
    #subtitle{
      font: 650 12px/1.25 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: var(--muted);
    }

    #closeBtn{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color: transparent;
      flex: 0 0 auto;
      font: 900 16px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
    }
    #closeBtn:active { transform: translateY(1px); }

    #rowWrap {
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top: 10px;
    }

    /* Top row (Welcome/Mission/Switchboard) */
    #topRow{
      display:flex;
      gap:10px;
      flex-wrap:nowrap;
    }

    .row {
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }

    .pill {
      flex: 1 1 0;
      min-width: 160px;
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 12px 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font: 900 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.15px;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      white-space: nowrap;
      justify-content:center;
    }
    .pill:active { transform: translateY(1px); }

    .pill.small { min-width: 0; padding: 12px 12px; }

    .dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: rgba(255,255,255,0.16);
      box-shadow: 0 0 0 rgba(0,0,0,0);
      flex: 0 0 auto;
    }

    /* Toggle "on" */
    .pill.on .dot{ background: rgba(120,255,200,0.88); box-shadow: 0 0 18px rgba(120,255,200,0.30); }

    /* Specific on colors */
    .pill.on[data-key="rhumb222"] .dot{ background: rgba(246,194,74,0.95); box-shadow:0 0 18px rgba(246,194,74,0.30); }
    .pill.on[data-key="rhumb42"]  .dot{ background: rgba(246,194,74,0.95); box-shadow:0 0 18px rgba(246,194,74,0.30); }

    .pill.on[data-key="gc222"]    .dot{ background: rgba(91,188,255,0.90); box-shadow:0 0 18px rgba(91,188,255,0.26); }
    .pill.on[data-key="gc42"]     .dot{ background: rgba(91,188,255,0.90); box-shadow:0 0 18px rgba(91,188,255,0.26); }

    .pill.on[data-key="names222"] .dot{ background: rgba(91,188,255,0.78); box-shadow:0 0 18px rgba(91,188,255,0.18); }
    .pill.on[data-key="names42"]  .dot{ background: rgba(91,188,255,0.78); box-shadow:0 0 18px rgba(91,188,255,0.18); }

    .pill.on[data-key="stations"] .dot{ background: rgba(127,255,212,0.86); box-shadow:0 0 18px rgba(127,255,212,0.24); }
    .pill.on[data-key="aurora"]   .dot{ background: rgba(160,120,255,0.90); box-shadow:0 0 18px rgba(160,120,255,0.26); }

    /* Switchboard (white glow) */
    #switchboardBtn{
      border: 1px solid rgba(255,255,255,0.18);
    }
    #switchboardBtn.on{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.34);
      box-shadow: 0 0 22px rgba(255,255,255,0.26), 0 12px 34px rgba(0,0,0,0.34);
    }
    #switchboardBtn .dot{ background: rgba(255,255,255,0.20); }
    #switchboardBtn.on .dot{ background: rgba(255,255,255,0.95); box-shadow: 0 0 18px rgba(255,255,255,0.30); }

    /* Subrows only visible when switchboard open */
    #subRows{ display:none; }
    #subRows.open{ display:flex; flex-direction:column; gap:10px; }

    #statusLine{
      margin-top:10px;
      color: var(--muted2);
      font: 700 11px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      display:flex;
      justify-content:space-between;
      gap:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    #errors{
      margin-top: 10px;
      display:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,120,120,0.22);
      background: rgba(80,10,10,0.35);
      color: rgba(255,170,170,0.95);
      font: 650 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre-wrap;
    }

    /* collapsed state */
    #drawer.collapsed #rowWrap,
    #drawer.collapsed #statusLine,
    #drawer.collapsed #errors { display:none; }
    #drawer.collapsed { padding-bottom: 12px; }

    /* Welcome modal */
    #welcomeModal{
      position: fixed;
      inset: 0;
      display:none;
      z-index: 12000;
      background: rgba(0,0,0,0.62);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      padding: 18px;
      box-sizing: border-box;
    }
    #welcomeModal.open{ display:block; }

    #welcomeCard{
      width: min(980px, calc(100vw - 36px));
      height: min(760px, calc(100vh - 36px));
      margin: 0 auto;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(12,14,18,0.68);
      box-shadow: 0 18px 64px rgba(0,0,0,0.55);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    #welcomeHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    #welcomeTitle{
      font: 900 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,0.92);
      letter-spacing: 0.2px;
    }
    #welcomeClose{
      width: 40px; height: 40px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      cursor:pointer;
      font: 900 16px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
    }
    #welcomeBody{
      flex:1;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      background: transparent;
    }
    #welcomeFrame{
      width: 100%;
      height: 100%;
      border: 0;
      display:block;
      background: transparent;
    }

    @media (max-width: 520px){
      .pill { min-width: 140px; padding: 12px 12px; border-radius: 16px; font-size: 13px; }
      #topRow .pill{ padding: 12px 10px; }
    }
  </style>

  <!-- Import Map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <button id="openBtn" aria-label="Open MAP E.D.E.N.">MAP E.D.E.N.</button>

  <div id="drawer">
    <div id="handle" title="Tap to collapse/expand"></div>

    <div id="drawerTop">
      <div id="titleBlock">
        <div id="title">MAP E.D.E.N.</div>
        <div id="subtitle">Earth Diametric Energy Network • Drag globe to rotate • Pinch/scroll to zoom</div>
      </div>
      <button id="closeBtn" aria-label="Close drawer" title="Close">✕</button>
    </div>

    <div id="rowWrap">

      <!-- Welcome / Mission / Switchboard -->
      <div id="topRow">
        <button class="pill small" id="welcomeBtn"><span class="dot"></span>Welcome</button>
        <button class="pill small" id="missionBtn"><span class="dot"></span>Mission</button>
        <button class="pill small" id="switchboardBtn"><span class="dot"></span>Switchboard</button>
      </div>

      <!-- Switchboard-only buttons -->
      <div id="subRows">
        <div class="row">
          <button class="pill on" data-key="rhumb222"><span class="dot"></span>Rhumb 222 SW</button>
          <button class="pill" data-key="rhumb42"><span class="dot"></span>Rhumb 42 NE</button>
        </div>

        <div class="row">
          <button class="pill on" data-key="gc222"><span class="dot"></span>Great Circle 222 SW</button>
          <button class="pill" data-key="gc42"><span class="dot"></span>Great Circle 42 NE</button>
        </div>

        <div class="row">
          <button class="pill" data-key="names222"><span class="dot"></span>Names 222 SW</button>
          <button class="pill" data-key="names42"><span class="dot"></span>Names 42 NE</button>
        </div>

        <div class="row">
          <button class="pill" data-key="perps"><span class="dot"></span>Perpendiculars</button>
          <button class="pill" data-key="continents"><span class="dot"></span>Continents</button>
        </div>

        <div class="row">
          <button class="pill on" data-key="stations"><span class="dot"></span>Stations</button>
          <button class="pill" data-key="corridors"><span class="dot"></span>Corridors</button>
        </div>

        <div class="row">
          <button class="pill" data-key="magField"><span class="dot"></span>Magnetic Field</button>
          <button class="pill" data-key="aurora"><span class="dot"></span>Aurora</button>
        </div>

        <div class="row">
          <button class="pill" data-key="nightLights"><span class="dot"></span>Night Lights</button>
          <button class="pill" data-key="perpName"><span class="dot"></span>Perp Name</button>
        </div>
      </div>

      <div id="statusLine">
        <span id="status">Booting…</span>
        <span id="hint">Tip: Toggle Switchboard to reveal the layer controls.</span>
      </div>

      <div id="errors"></div>
    </div>
  </div>

  <!-- Welcome Modal -->
  <div id="welcomeModal" role="dialog" aria-modal="true" aria-label="Welcome to MAP E.D.E.N.">
    <div id="welcomeCard">
      <div id="welcomeHead">
        <div id="welcomeTitle">Welcome • MAP E.D.E.N.</div>
        <button id="welcomeClose" aria-label="Close Welcome">✕</button>
      </div>
      <div id="welcomeBody">
        <iframe id="welcomeFrame" title="Welcome Content" loading="lazy"></iframe>
      </div>
    </div>
  </div>

  <script type="module">
    const statusEl = document.getElementById("status");
    const errorsEl = document.getElementById("errors");
    const drawerEl = document.getElementById("drawer");
    const openBtn  = document.getElementById("openBtn");
    const closeBtn = document.getElementById("closeBtn");
    const handle   = document.getElementById("handle");

    const welcomeBtn   = document.getElementById("welcomeBtn");
    const missionBtn   = document.getElementById("missionBtn");
    const switchBtn    = document.getElementById("switchboardBtn");
    const subRowsEl    = document.getElementById("subRows");

    const welcomeModal = document.getElementById("welcomeModal");
    const welcomeClose = document.getElementById("welcomeClose");
    const welcomeFrame = document.getElementById("welcomeFrame");

    function showError(msg){
      errorsEl.style.display = "block";
      errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
      statusEl.textContent = "Error (see panel)";
    }
    window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
    window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

    function setDrawerClosed(isClosed){
      drawerEl.classList.toggle("closed", !!isClosed);
      openBtn.style.display = isClosed ? "inline-flex" : "none";
    }
    setDrawerClosed(false);
    openBtn.addEventListener("click", () => setDrawerClosed(false));
    closeBtn.addEventListener("click", () => setDrawerClosed(true));
    handle.addEventListener("click", () => drawerEl.classList.toggle("collapsed"));

    // Welcome modal behavior
    function openWelcome(){
      if(!welcomeFrame.src) welcomeFrame.src = "welcome.html"; // same folder
      welcomeModal.classList.add("open");
    }
    function closeWelcome(){
      welcomeModal.classList.remove("open");
    }
    welcomeBtn.addEventListener("click", openWelcome);
    welcomeClose.addEventListener("click", closeWelcome);
    welcomeModal.addEventListener("click", (e)=>{ if(e.target === welcomeModal) closeWelcome(); });

    // Mission (simple alert panel inside status line)
    missionBtn.addEventListener("click", ()=>{
      statusEl.textContent =
        "Mission: Turn the 42°/222° axis hypothesis into an evidence-first experiment using repeatable, controlled, comparable sensor datasets.";
    });

    // Switchboard toggle (show/hide all sub buttons in this drawer)
    let switchOn = false;
    function setSwitchboard(on){
      switchOn = !!on;
      switchBtn.classList.toggle("on", switchOn);
      subRowsEl.classList.toggle("open", switchOn);
      subRowsEl.style.display = switchOn ? "flex" : "none";
      statusEl.textContent = switchOn ? "Switchboard ON" : "Switchboard OFF";
    }
    setSwitchboard(false);
    switchBtn.addEventListener("click", ()=> setSwitchboard(!switchOn));

    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const DEG = Math.PI/180;
    const RAD = 180/Math.PI;

    function isUIEventTarget(target){
      return !!(target && (target.closest?.("#drawer") || target.closest?.("#openBtn") || target.closest?.("#welcomeModal")));
    }

    function latLonToVec3(latDeg, lonDeg, radius=1.0){
      const lat = latDeg * DEG;
      const lon = lonDeg * DEG;
      return new THREE.Vector3(
        radius * Math.cos(lat) * Math.cos(lon),
        radius * Math.sin(lat),
        radius * Math.cos(lat) * Math.sin(lon)
      );
    }

    function greatCirclePoints(lat0Deg, lon0Deg, bearingDeg, stepDeg=1.0){
      const lat0 = lat0Deg * DEG;
      const lon0 = lon0Deg * DEG;
      const brng = bearingDeg * DEG;

      const pts = [];
      for(let d=-180; d<=180; d+=stepDeg){
        const δ = d * DEG;
        const sinLat = Math.sin(lat0)*Math.cos(δ) + Math.cos(lat0)*Math.sin(δ)*Math.cos(brng);
        const lat = Math.asin(clamp(sinLat, -1, 1));
        const y = Math.sin(brng)*Math.sin(δ)*Math.cos(lat0);
        const x = Math.cos(δ) - Math.sin(lat0)*Math.sin(lat);
        const lon = lon0 + Math.atan2(y, x);
        pts.push({ lat: lat*RAD, lon: ((lon*RAD + 540) % 360) - 180 });
      }
      return pts;
    }

    function rhumbPoints(lat0Deg, lon0Deg, bearingDeg, stepKm=250){
      const R=6371;
      const φ1=lat0Deg*DEG;
      const λ1=lon0Deg*DEG;
      const θ=bearingDeg*DEG;

      const pts=[];
      const maxSteps=120;
      for (const dir of [-1,+1]){
        let φ=φ1, λ=λ1;
        for (let i=0;i<maxSteps;i++){
          const d = dir*(stepKm/R);
          const Δφ = d*Math.cos(θ);
          let φ2 = clamp(φ+Δφ, -Math.PI/2+1e-6, Math.PI/2-1e-6);

          const Δψ = Math.log(Math.tan(Math.PI/4+φ2/2)/Math.tan(Math.PI/4+φ/2));
          const q = Math.abs(Δψ)>1e-12 ? (Δφ/Δψ) : Math.cos(φ);

          const Δλ = d*Math.sin(θ)/q;
          let λ2 = ((λ+Δλ+Math.PI)%(2*Math.PI))-Math.PI;

          pts.push({ lat: φ2*RAD, lon: λ2*RAD });
          φ=φ2; λ=λ2;
        }
      }
      return pts;
    }

    function makeGlowTube(pointsVec3, radius, color, coreOpacity=1.0, haloOpacity=0.28){
      if (!pointsVec3 || pointsVec3.length < 4) return new THREE.Group();
      const curve = new THREE.CatmullRomCurve3(pointsVec3, false, "catmullrom", 0.15);
      const segs = Math.max(300, pointsVec3.length*2);

      const coreGeom = new THREE.TubeGeometry(curve, segs, radius, 10, false);
      const haloGeom = new THREE.TubeGeometry(curve, segs, radius*2.6, 10, false);

      const coreMat = new THREE.MeshBasicMaterial({ color, transparent: coreOpacity<1, opacity: coreOpacity, depthWrite:false });
      const haloMat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity: haloOpacity, blending: THREE.AdditiveBlending, depthWrite:false });

      const g = new THREE.Group();
      g.add(new THREE.Mesh(haloGeom, haloMat));
      g.add(new THREE.Mesh(coreGeom, coreMat));
      return g;
    }

    // Text sprite: NO borders/boxes (clean names)
    function makeTextSprite(text, {fontSize=20, glow=4, color="rgba(255,255,255,0.92)", glowColor="rgba(255,255,255,0.22)", scale=0.0048} = {}){
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      ctx.font = `900 ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
      const m = ctx.measureText(text);
      const pad = 10;
      const w = Math.ceil(m.width + pad*2);
      const h = Math.ceil(fontSize + pad*2);
      canvas.width = w; canvas.height = h;

      ctx.font = `900 ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = "middle";

      // subtle glow
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = glow;
      ctx.fillStyle = color;
      ctx.fillText(text, pad, h/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;

      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false });
      const spr = new THREE.Sprite(mat);
      spr.scale.set(w*scale, h*scale, 1);
      return spr;
    }

    function solidTexture(hex="#222"){
      const c=document.createElement("canvas");
      c.width=2; c.height=2;
      const ctx=c.getContext("2d");
      ctx.fillStyle=hex; ctx.fillRect(0,0,2,2);
      const t=new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }

    function makeFallbackStars(){
      const c=document.createElement("canvas");
      c.width=1024; c.height=1024;
      const ctx=c.getContext("2d");
      ctx.fillStyle="#000"; ctx.fillRect(0,0,c.width,c.height);
      for(let i=0;i<2400;i++){
        const x=Math.random()*c.width, y=Math.random()*c.height;
        const a=0.2+Math.random()*0.8;
        const s=Math.random()>0.995?2:1;
        ctx.fillStyle=`rgba(255,255,255,${a})`;
        ctx.fillRect(x,y,s,s);
      }
      const t=new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }

    function makeFallbackEarthDay(){
      const c=document.createElement("canvas");
      c.width=1024; c.height=512;
      const ctx=c.getContext("2d");
      ctx.fillStyle="#0e1e3a"; ctx.fillRect(0,0,c.width,c.height);
      ctx.globalAlpha=0.92; ctx.fillStyle="#2b7d4f";
      for(let i=0;i<35;i++){
        const x=Math.random()*c.width, y=Math.random()*c.height;
        const r=20+Math.random()*90;
        ctx.beginPath(); ctx.ellipse(x,y,r,r*0.65,Math.random()*Math.PI,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha=0.12; ctx.fillStyle="#fff";
      for(let i=0;i<80;i++){
        const x=Math.random()*c.width, y=Math.random()*c.height;
        const r=20+Math.random()*100;
        ctx.beginPath(); ctx.ellipse(x,y,r,r*0.45,0,0,Math.PI*2); ctx.fill();
      }
      const t=new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }

    function makeFallbackNight(){
      const c=document.createElement("canvas");
      c.width=1024; c.height=512;
      const ctx=c.getContext("2d");
      ctx.fillStyle="#000"; ctx.fillRect(0,0,c.width,c.height);
      ctx.fillStyle="rgba(255,210,120,0.9)";
      for(let i=0;i<2400;i++){
        const x=Math.random()*c.width, y=Math.random()*c.height;
        if(Math.random()<0.985) continue;
        ctx.fillRect(x,y,1,1);
      }
      const t=new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }

    function makeFallbackClouds(){
      const c=document.createElement("canvas");
      c.width=1024; c.height=512;
      const ctx=c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height);
      ctx.fillStyle="rgba(255,255,255,0.38)";
      for(let i=0;i<140;i++){
        const x=Math.random()*c.width, y=Math.random()*c.height;
        const r=30+Math.random()*120;
        ctx.beginPath(); ctx.ellipse(x,y,r,r*0.5,0,0,Math.PI*2); ctx.fill();
      }
      const t=new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }

    async function loadTextureWithFallback(urls, fallbackTex, label){
      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin("anonymous");
      const tryOne = (url) => new Promise((resolve, reject) => {
        loader.load(url, resolve, undefined, () => reject(new Error("failed: " + url)));
      });

      for (const u of urls){
        try{
          const tex = await tryOne(u);
          tex.colorSpace = THREE.SRGBColorSpace;
          return tex;
        } catch { /* keep trying */ }
      }

      showError(`Texture fallback used for: ${label}\n(Your CDNs blocked/failed on this device/network)`);
      return fallbackTex;
    }

    // ---------- Main ----------
    (async ()=>{
      try{
        statusEl.textContent = "Starting…";

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
        camera.position.set(0, 0, 4.2);

        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.12; // brighter globe
        document.body.appendChild(renderer.domElement);

        const canvas = renderer.domElement;
        let contextLost = false;
        canvas.addEventListener("webglcontextlost", (e)=>{
          e.preventDefault();
          contextLost = true;
          statusEl.textContent = "WebGL context lost — rotate back or reload.";
        }, false);
        canvas.addEventListener("webglcontextrestored", ()=>{
          if(contextLost){
            statusEl.textContent = "Restored — reloading…";
            try{ window.location.reload(); } catch {}
          }
        }, false);

        scene.add(new THREE.AmbientLight(0xffffff, 0.14));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
        sunLight.position.set(5, 1.5, 2.5);
        scene.add(sunLight);

        // Texture URLs (3 CDNs)
        const BASES = [
          "https://threejs.org/examples/textures/",
          "https://unpkg.com/three@0.161.0/examples/textures/",
          "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/"
        ];
        const urls = (path)=>BASES.map(b=>b+path);

        statusEl.textContent = "Loading textures…";

        const dayMap   = await loadTextureWithFallback(urls("planets/earth_atmos_2048.jpg"),   makeFallbackEarthDay(), "earth day");
        const nightMap = await loadTextureWithFallback(urls("planets/earth_lights_2048.png"),  makeFallbackNight(),    "earth night lights");
        const specMap  = await loadTextureWithFallback(urls("planets/earth_specular_2048.jpg"),solidTexture("#000"),   "earth specular");
        const cloudMap = await loadTextureWithFallback(urls("planets/earth_clouds_1024.png"),  makeFallbackClouds(),   "earth clouds");
        const starMap  = await loadTextureWithFallback(urls("galaxy_starfield.png"),          makeFallbackStars(),    "stars");

        const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
        [dayMap, nightMap, specMap, cloudMap, starMap].forEach((t)=>{
          t.anisotropy = maxAniso;
          t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
        });

        statusEl.textContent = "Running";

        // Stars
        {
          const starGeo = new THREE.SphereGeometry(90, 64, 64);
          const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
          scene.add(new THREE.Mesh(starGeo, starMat));
        }

        const earthRadius = 1.0;
        const SEG = 96;

        // Earth shader (stable)
        const earthUniforms = {
          dayMap:    { value: dayMap },
          specMap:   { value: specMap },
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const earthMat = new THREE.ShaderMaterial({
          uniforms: earthUniforms,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vUv = uv;
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform sampler2D dayMap;
            uniform sampler2D specMap;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
              float lum = dot(dayCol, vec3(0.2126,0.7152,0.0722));
              vec3 sat = mix(vec3(lum), dayCol, 1.14);     // more vivid oceans
              vec3 c = pow(max(sat, 0.0), vec3(0.92));

              float specMask = texture2D(specMap, vUv).r;
              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);

              vec3 nightBase = c * 0.11;
              vec3 col = mix(nightBase, c, dayAmt);

              vec3 H = normalize(L + V);
              float spec = pow(max(dot(N, H), 0.0), 80.0) * specMask * 0.48 * dayAmt;
              col += vec3(spec);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
              col += vec3(0.06, 0.10, 0.18) * rim * (0.26 + 0.74 * dayAmt);

              gl_FragColor = vec4(linearToSrgb(col), 1.0);
            }
          `
        });

        const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);

        // Night lights (additive; toggled by button)
        const lightsUniforms = {
          nightMap: { value: nightMap },
          sunDir:   { value: new THREE.Vector3(1,0,0) },
          gain:     { value: 2.7 }
        };

        const nightLights = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: lightsUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexShader: `
              varying vec2 vUv;
              varying vec3 vNormalW;
              void main(){
                vUv = uv;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform sampler2D nightMap;
              uniform vec3 sunDir;
              uniform float gain;
              varying vec2 vUv;
              varying vec3 vNormalW;

              vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
              vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);

                float ndl = dot(N, L);
                float dayAmt = smoothstep(-0.05, 0.15, ndl);
                float nightAmt = 1.0 - dayAmt;

                vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
                float mask = smoothstep(0.05, 0.35, nightAmt);

                vec3 col = lights * mask;
                float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
                gl_FragColor = vec4(linearToSrgb(col), a);
              }
            `
          })
        );

        // Clouds (fresh + bright)
        const cloudShadow = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
          new THREE.MeshBasicMaterial({
            map: cloudMap,
            color: 0x000000,
            transparent: true,
            opacity: 0.24,
            blending: THREE.MultiplyBlending,
            depthWrite: false
          })
        );

        const clouds = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
          new THREE.MeshLambertMaterial({
            map: cloudMap,
            transparent: true,
            opacity: 0.90,
            depthWrite: false
          })
        );

        // Atmosphere
        const atmoUniforms = {
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const atmosphere = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: atmoUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            vertexShader: `
              varying vec3 vNormalW;
              varying vec3 vPosW;
              void main(){
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vPosW = worldPos.xyz;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * worldPos;
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform vec3 sunDir;
              uniform vec3 cameraPos;
              varying vec3 vNormalW;
              varying vec3 vPosW;

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);
                vec3 V = normalize(cameraPos - vPosW);

                float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
                float daySide = smoothstep(-0.15, 0.25, dot(N, L));

                vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.22 + 0.78 * daySide);
                float alpha = rim * (0.16 + 0.58 * daySide);
                gl_FragColor = vec4(col, alpha);
              }
            `
          })
        );

        // Globe group
        const globe = new THREE.Group();
        globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
        scene.add(globe);

        // --------- Layers / overlays ----------
        const overlays = {
          rhumb222:   new THREE.Group(),
          rhumb42:    new THREE.Group(),
          gc222:      new THREE.Group(),
          gc42:       new THREE.Group(),
          names222:   new THREE.Group(),
          names42:    new THREE.Group(),
          perps:      new THREE.Group(),
          perpName:   new THREE.Group(),
          continents: new THREE.Group(),
          stations:   new THREE.Group(),
          corridors:  new THREE.Group(),
          magField:   new THREE.Group(),
          aurora:     new THREE.Group()
        };
        Object.values(overlays).forEach(g => globe.add(g));

        // Station 1 (DMS: 38°9′39″ N, 79°4′24″ W)
        const station = { name:"Exit 222 Station 1", lat: 38.1608333333, lon: -79.0733333333 };

        // Bearings
        const BR_222 = 222;
        const BR_42  = 42;

        // Build curves
        const gc222 = greatCirclePoints(station.lat, station.lon, BR_222, 1.0)
          .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
        const gc42 = greatCirclePoints(station.lat, station.lon, BR_42, 1.0)
          .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
        const rh222 = rhumbPoints(station.lat, station.lon, BR_222, 240)
          .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
        const rh42 = rhumbPoints(station.lat, station.lon, BR_42, 240)
          .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));

        overlays.gc222.add(makeGlowTube(gc222, 0.0032, 0x5bbcff, 1.0, 0.30));
        overlays.gc42.add(makeGlowTube(gc42, 0.0032, 0x5bbcff, 1.0, 0.30));
        overlays.rhumb222.add(makeGlowTube(rh222, 0.0032, 0xf6c24a, 1.0, 0.28));
        overlays.rhumb42.add(makeGlowTube(rh42, 0.0032, 0xf6c24a, 1.0, 0.28));

        // Perpendiculars around the station (132 / 312) - from the 222 axis
        function arcFromBearing(bearingDeg){
          const pts = greatCirclePoints(station.lat, station.lon, bearingDeg, 1.2)
            .filter((_, i) => i > 40 && i < 260)
            .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
          return makeGlowTube(pts, 0.0026, 0x5bbcff, 1.0, 0.22);
        }
        overlays.perps.add(arcFromBearing(132), arcFromBearing(312));

        // Name labels (NO borders)
        function placeLabelOnCurve(label, curvePts, idx, group, glowColor){
          const i = clamp(idx, 0, curvePts.length-1) | 0;
          const p = curvePts[i].clone().normalize().multiplyScalar(earthRadius*1.13);
          const spr = makeTextSprite(label, {fontSize:20, glow:4, glowColor});
          spr.position.copy(p);
          group.add(spr);
        }
        placeLabelOnCurve("222 SW", gc222, 220, overlays.names222, "rgba(91,188,255,0.20)");
        placeLabelOnCurve("222 SW", rh222, 220, overlays.names222, "rgba(246,194,74,0.18)");
        placeLabelOnCurve("42 NE",  gc42,  220, overlays.names42,  "rgba(91,188,255,0.20)");
        placeLabelOnCurve("42 NE",  rh42,  220, overlays.names42,  "rgba(246,194,74,0.18)");

        // Perp name (clean)
        {
          const pLabel = makeTextSprite("132° / 312°", {fontSize:20, glow:4, glowColor:"rgba(91,188,255,0.18)"});
          pLabel.position.copy(latLonToVec3(55, 110, earthRadius*1.14));
          overlays.perpName.add(pLabel);
        }

        // Continents (names only)
        const CONT = [
          { name:"North America", lat: 45,  lon:-102 },
          { name:"South America", lat:-16,  lon:-60 },
          { name:"Europe",        lat: 52,  lon: 15 },
          { name:"Africa",        lat:  5,  lon: 20 },
          { name:"Asia",          lat: 45,  lon: 95 },
          { name:"Australia",     lat:-25,  lon: 135 },
          { name:"Antarctica",    lat:-80,  lon:  0 }
        ];
        for (const c of CONT){
          const s = makeTextSprite(c.name, {fontSize:20, glow:4, glowColor:"rgba(255,255,255,0.16)"});
          s.position.copy(latLonToVec3(c.lat, c.lon, earthRadius*1.12));
          overlays.continents.add(s);
        }

        // Corridors (±1/±5/±10 km) around BOTH line types
        const kmToUnit = (km)=> (km/6371)*earthRadius;
        const corridorRadii = [
          { km: 1,  r: kmToUnit(1),  o: 0.18 },
          { km: 5,  r: kmToUnit(5),  o: 0.10 },
          { km: 10, r: kmToUnit(10), o: 0.07 }
        ];
        for (const c of corridorRadii){
          overlays.corridors.add(makeGlowTube(gc222, c.r, 0xf6c24a, 0.0, c.o));
          overlays.corridors.add(makeGlowTube(rh222, c.r, 0xf6c24a, 0.0, c.o*0.9));
          overlays.corridors.add(makeGlowTube(gc42,  c.r, 0x5bbcff, 0.0, c.o*0.8));
          overlays.corridors.add(makeGlowTube(rh42,  c.r, 0x5bbcff, 0.0, c.o*0.75));
        }

        // Station marker (ONLY ONE station)
        function makeStationMarker(label, lat, lon, color=0x7fffd4){
          const g = new THREE.Group();
          const p = latLonToVec3(lat, lon, earthRadius*1.02);

          const pin = new THREE.Mesh(new THREE.SphereGeometry(0.010, 18, 18),
            new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.95 })
          );
          pin.position.copy(p);

          const glow = new THREE.Mesh(new THREE.SphereGeometry(0.020, 18, 18),
            new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.18, blending:THREE.AdditiveBlending, depthWrite:false })
          );
          glow.position.copy(p);

          const tag = makeTextSprite(label, {fontSize:20, glow:4, glowColor:"rgba(127,255,212,0.20)"});
          tag.position.copy(latLonToVec3(lat, lon, earthRadius*1.14));

          g.add(glow, pin, tag);
          return g;
        }
        overlays.stations.add(
          makeStationMarker("Exit 222 Station 1 @ 38°9′39″ N, 79°4′24″ W", station.lat, station.lon, 0x7fffd4)
        );

        // Magnetic field (simple dipole preview)
        function makeDipoleFieldLines(){
          const g = new THREE.Group();
          const col = 0x5bbcff;
          const axis = new THREE.Vector3(0,1,0);
          const Ls = [1.6, 2.2, 3.2, 4.6];

          for (const L of Ls){
            const pts = [];
            for (let t=-80; t<=80; t+=1.2){
              const θ = (90 - t) * DEG;
              const r = L * Math.sin(θ)*Math.sin(θ);
              const rr = earthRadius * r;
              if (rr < earthRadius*1.04) continue;
              const x = rr * Math.sin(θ);
              const y = rr * Math.cos(θ);
              pts.push(new THREE.Vector3(x, y, 0));
            }

            const longitudes = 10;
            for (let i=0; i<longitudes; i++){
              const a = (i/longitudes) * Math.PI*2;
              const ring = pts.map(p=>{
                const len = p.length();
                const v = p.clone().applyAxisAngle(axis, a);
                return v.normalize().multiplyScalar(len);
              });
              const ringClamped = ring.filter(v => v.length() < earthRadius*7.5);
              g.add(makeGlowTube(ringClamped, 0.0014, col, 0.0, 0.06));
            }
          }
          return g;
        }
        overlays.magField.add(makeDipoleFieldLines());

        // Aurora belt preview
        function makeAuroraBelt(latDeg=67, color=0xa078ff){
          const g = new THREE.Group();
          for (const lat of [latDeg, -latDeg]){
            const pts = [];
            for (let lon=-180; lon<=180; lon+=2) pts.push(latLonToVec3(lat, lon, earthRadius*1.05));
            g.add(makeGlowTube(pts, 0.0026, color, 0.0, 0.12));
          }
          return g;
        }
        overlays.aurora.add(makeAuroraBelt(67));

        // --------- Bloom (selective) ----------
        const BLOOM_LAYER = 1;
        const bloomLayer = new THREE.Layers(); bloomLayer.set(BLOOM_LAYER);

        atmosphere.layers.enable(BLOOM_LAYER);
        nightLights.layers.enable(BLOOM_LAYER);

        // Glow items
        [overlays.rhumb222, overlays.rhumb42, overlays.gc222, overlays.gc42, overlays.perps, overlays.corridors, overlays.aurora].forEach(g=>{
          g.traverse(o => o.layers && o.layers.enable(BLOOM_LAYER));
        });

        const darkMaterial = new THREE.MeshBasicMaterial({ color:"black" });
        const materials = new Map();

        function darkenNonBloom(obj){
          if (obj.isMesh && !bloomLayer.test(obj.layers)){
            materials.set(obj.uuid, obj.material);
            obj.material = darkMaterial;
          }
        }
        function restoreMaterial(obj){
          if (materials.has(obj.uuid)){
            obj.material = materials.get(obj.uuid);
            materials.delete(obj.uuid);
          }
        }

        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.18, 0.82, 0.10);
        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        const finalPass = new ShaderPass({
          uniforms: { tDiffuse: { value: null }, bloomTexture: { value: null } },
          vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
          fragmentShader: `uniform sampler2D tDiffuse; uniform sampler2D bloomTexture; varying vec2 vUv;
            void main(){ gl_FragColor = texture2D(tDiffuse,vUv) + texture2D(bloomTexture,vUv); }`
        });

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(finalPass);
        finalComposer.addPass(new OutputPass());

        function renderBloom(){
          scene.traverse(darkenNonBloom);
          bloomComposer.render();
          finalPass.uniforms.bloomTexture.value = bloomComposer.readBuffer.texture;
          scene.traverse(restoreMaterial);
        }

        // --------- Interaction ----------
        let dragging=false, lastX=0, lastY=0, velY=0, velX=0;
        const AUTO_SPIN=0.0013, DRAG_SENS=0.0065, PITCH_SENS=0.0048, DAMPING=0.92, MAX_PITCH=0.55;

        let pinching=false, pinchStartDist=0, pinchStartZ=camera.position.z;
        const Z_MIN=2.2, Z_MAX=8.0;

        function getPoint(e){
          if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
          return { x:e.clientX, y:e.clientY };
        }
        function dist2(t1,t2){
          const dx=t1.clientX-t2.clientX, dy=t1.clientY-t2.clientY;
          return Math.sqrt(dx*dx+dy*dy);
        }

        function down(e){
          if (isUIEventTarget(e.target)) return;

          if (e.touches && e.touches.length === 2){
            pinching=true;
            pinchStartDist = dist2(e.touches[0], e.touches[1]);
            pinchStartZ = camera.position.z;
            return;
          }
          dragging=true;
          const p=getPoint(e);
          lastX=p.x; lastY=p.y;
        }

        function move(e){
          if (isUIEventTarget(e.target)) return;

          if (pinching && e.touches && e.touches.length === 2){
            const d = dist2(e.touches[0], e.touches[1]);
            const ratio = pinchStartDist > 0 ? (pinchStartDist / d) : 1.0;
            camera.position.z = clamp(pinchStartZ * ratio, Z_MIN, Z_MAX);
            return;
          }

          if(!dragging) return;
          const p=getPoint(e);
          const dx=p.x-lastX, dy=p.y-lastY;
          lastX=p.x; lastY=p.y;

          globe.rotation.y += dx*DRAG_SENS;
          globe.rotation.x = clamp(globe.rotation.x + dy*PITCH_SENS, -MAX_PITCH, MAX_PITCH);

          velY = dx*DRAG_SENS;
          velX = dy*PITCH_SENS;
        }

        function up(){ dragging=false; pinching=false; }

        const el = renderer.domElement;
        el.addEventListener("touchstart", down, { passive:true });
        el.addEventListener("touchmove", move, { passive:true });
        el.addEventListener("touchend", up, { passive:true });
        el.addEventListener("mousedown", down);
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);

        window.addEventListener("wheel", (e)=>{
          if (isUIEventTarget(e.target)) return;
          camera.position.z = clamp(camera.position.z + (e.deltaY * 0.0025), Z_MIN, Z_MAX);
        }, { passive:true });

        // --------- Toggles ----------
        const state = {
          rhumb222: true,
          rhumb42: false,
          gc222: true,
          gc42: false,
          names222: false,
          names42: false,
          perps: false,
          continents: false,
          stations: true,
          corridors: false,
          magField: false,
          aurora: false,
          nightLights: false,
          perpName: false
        };

        function applyVisibility(){
          overlays.rhumb222.visible   = state.rhumb222;
          overlays.rhumb42.visible    = state.rhumb42;
          overlays.gc222.visible      = state.gc222;
          overlays.gc42.visible       = state.gc42;
          overlays.names222.visible   = state.names222;
          overlays.names42.visible    = state.names42;
          overlays.perps.visible      = state.perps;
          overlays.continents.visible = state.continents;
          overlays.stations.visible   = state.stations;
          overlays.corridors.visible  = state.corridors;
          overlays.magField.visible   = state.magField;
          overlays.aurora.visible     = state.aurora;
          nightLights.visible         = state.nightLights;
          overlays.perpName.visible   = state.perpName;
        }
        applyVisibility();

        function setPill(key, on){
          const b = document.querySelector(`.pill[data-key="${key}"]`);
          if (b) b.classList.toggle("on", !!on);
        }
        Object.keys(state).forEach(k => setPill(k, state[k]));

        document.querySelectorAll(".pill[data-key]").forEach(btn=>{
          btn.addEventListener("click", ()=>{
            const key = btn.dataset.key;
            if (!(key in state)) return;
            state[key] = !state[key];
            setPill(key, state[key]);
            applyVisibility();
          });
        });

        // --------- Animate ----------
        const sunDrift = 0.00005;
        const cloudSpin = 0.0020;

        function animate(){
          requestAnimationFrame(animate);

          clouds.rotation.y += cloudSpin;
          cloudShadow.rotation.y += cloudSpin + 0.00015;

          if(!dragging && !pinching){
            globe.rotation.y += AUTO_SPIN + velY;
            globe.rotation.x = clamp(globe.rotation.x + velX, -MAX_PITCH, MAX_PITCH);
            velY *= DAMPING;
            velX *= DAMPING;
          }

          sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
          const sunDir = sunLight.position.clone().normalize();

          earthUniforms.sunDir.value.copy(sunDir);
          earthUniforms.cameraPos.value.copy(camera.position);
          lightsUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.cameraPos.value.copy(camera.position);

          renderBloom();
          finalComposer.render();
        }
        animate();

        // --------- Resize/orientation robustness (prevents iOS freeze) ----------
        let resizeTimer = null;
        function safeResize(){
          const w = Math.max(1, window.innerWidth | 0);
          const h = Math.max(1, window.innerHeight | 0);
          if (w < 20 || h < 20) return;

          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);

          bloomComposer.setSize(w, h);
          finalComposer.setSize(w, h);
          bloomPass.setSize(w, h);
        }
        function scheduleResize(){
          if (resizeTimer) clearTimeout(resizeTimer);
          resizeTimer = setTimeout(()=> requestAnimationFrame(safeResize), 120);
        }
        window.addEventListener("resize", scheduleResize, { passive:true });
        window.addEventListener("orientationchange", scheduleResize, { passive:true });
        if (window.visualViewport){
          window.visualViewport.addEventListener("resize", scheduleResize, { passive:true });
        }

      } catch (err){
        showError("Top-level error:\n" + (err?.stack || err?.message || err));
      }
    })();
  </script>
</body>
</html>
