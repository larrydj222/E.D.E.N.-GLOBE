<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>E.D.E.N. Globe</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        background: #000;
        overflow: hidden;
        touch-action: none;
      }
      canvas { display:block; width:100vw!important; height:100vh!important; }
      #hud {
        position: fixed;
        left: 12px;
        bottom: 12px;
        max-width: min(720px, calc(100vw - 24px));
        font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        color: rgba(255,255,255,.92);
        background: rgba(0,0,0,.40);
        border: 1px solid rgba(255,255,255,.14);
        border-radius: 12px;
        padding: 10px 12px;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        user-select: none;
        pointer-events: none;
        white-space: pre-wrap;
      }
      #hud b { color:#fff; }
      #hud .ok { color:#9affb0; }
      #hud .warn { color:#ffd27a; }
      #hud .err { color:#ff7a7a; }
    </style>
  </head>
  <body>
    <div id="hud"><b>Status:</b> <span class="warn">Loading…</span></div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
      import { EffectComposer } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/RenderPass.js";
      import { ShaderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/ShaderPass.js";
      import { OutputPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/OutputPass.js";
      import { UnrealBloomPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js";

      // ---------- HUD helpers ----------
      const hud = document.getElementById("hud");
      function setHUD(statusText, cls="ok", details="") {
        hud.innerHTML =
          `<b>Status:</b> <span class="${cls}">${statusText}</span>` +
          (details ? `\n${details}` : "");
      }
      window.addEventListener("error", (e) => {
        setHUD("Error (see panel)", "err", `Top-level error: ${e.message || e.type || "Unknown error"}`);
      });

      // ---------- Scene / Camera / Renderer ----------
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 5000);
      camera.position.set(0, 0, 4.2);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      document.body.appendChild(renderer.domElement);

      // ---------- Lights ----------
      scene.add(new THREE.AmbientLight(0xffffff, 0.10));

      const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
      sunLight.position.set(5, 1.5, 2.5);
      scene.add(sunLight);

      // ---------- Textures (stable public folder) ----------
      // This folder contains the exact files you listed (4096 day + 2048 normal/spec/lights/clouds).  [oai_citation:1‡posibras.com](https://posibras.com/threejs/examples/textures/planets/)
      const TEX = {
        day4096: "https://posibras.com/threejs/examples/textures/planets/earth_atmos_4096.jpg",
        night:   "https://posibras.com/threejs/examples/textures/planets/earth_lights_2048.png",
        normal:  "https://posibras.com/threejs/examples/textures/planets/earth_normal_2048.jpg",
        spec:    "https://posibras.com/threejs/examples/textures/planets/earth_specular_2048.jpg",
        clouds:  "https://posibras.com/threejs/examples/textures/planets/earth_clouds_2048.png"
      };

      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin("anonymous");

      function loadTex(url, { srgb=false } = {}) {
        return new Promise((resolve, reject) => {
          loader.load(
            url,
            (t) => {
              if (srgb) t.colorSpace = THREE.SRGBColorSpace;
              // keep data maps linear:
              // (normal/spec are data maps; leaving colorSpace default is correct)
              t.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
              t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
              resolve(t);
            },
            undefined,
            (err) => reject(new Error(`Texture failed to load: ${url}`))
          );
        });
      }

      let dayMap, nightMap, normalMap, specMap, cloudMap;

      try {
        setHUD("Loading textures…", "warn",
          "If you see errors, screenshot them and send here."
        );

        [dayMap, nightMap, normalMap, specMap, cloudMap] = await Promise.all([
          loadTex(TEX.day4096, { srgb:true }),
          loadTex(TEX.night,   { srgb:true }),
          loadTex(TEX.normal,  { srgb:false }),
          loadTex(TEX.spec,    { srgb:false }),
          loadTex(TEX.clouds,  { srgb:true })
        ]);

        setHUD("Running", "ok", "All textures loaded.");
      } catch (e) {
        setHUD("Error (texture load)", "err", e.message || String(e));
        throw e;
      }

      // ---------- Procedural stars (NO star texture → removes the old 404 issue) ----------
      // (Your previous star texture path was 404. )
      {
        const starCount = 1800;
        const radius = 90;
        const positions = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
          // random direction on sphere
          const u = Math.random();
          const v = Math.random();
          const theta = 2 * Math.PI * u;
          const phi = Math.acos(2 * v - 1);
          const r = radius;

          const x = r * Math.sin(phi) * Math.cos(theta);
          const y = r * Math.cos(phi);
          const z = r * Math.sin(phi) * Math.sin(theta);

          positions[i*3+0] = x;
          positions[i*3+1] = y;
          positions[i*3+2] = z;
        }

        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

        const starMat = new THREE.PointsMaterial({
          size: 0.18,
          sizeAttenuation: true,
          transparent: true,
          opacity: 0.85
        });

        scene.add(new THREE.Points(starGeo, starMat));
      }

      // ---------- Globe ----------
      const earthRadius = 1.0;
      const SEG = 96;

      // Earth shader (keeps your day/night vibe) + adds NORMAL MAP for sharper continents
      const earthUniforms = {
        dayMap:    { value: dayMap },
        specMap:   { value: specMap },
        normalMap: { value: normalMap },
        normalScale: { value: new THREE.Vector2(0.85, 0.85) }, // ✅ sharper landforms
        sunDir:    { value: new THREE.Vector3(1, 0, 0) },
        cameraPos: { value: new THREE.Vector3() }
      };

      const earthMat = new THREE.ShaderMaterial({
        uniforms: earthUniforms,
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          void main() {
            vUv = uv;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vPosW = worldPos.xyz;
            vNormalW = normalize(mat3(modelMatrix) * normal);
            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `,
        fragmentShader: `
          precision highp float;

          uniform sampler2D dayMap;
          uniform sampler2D specMap;
          uniform sampler2D normalMap;
          uniform vec2 normalScale;
          uniform vec3 sunDir;
          uniform vec3 cameraPos;

          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;

          vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
          vec3 linearToSrgb(vec3 c){ return pow(max(c, 0.0), vec3(1.0/2.2)); }

          // Derivative-based normal mapping (no tangents needed)
          vec3 perturbNormal2Arb(vec3 surf_pos, vec3 surf_norm, vec3 mapN) {
            vec3 q0 = dFdx(surf_pos);
            vec3 q1 = dFdy(surf_pos);
            vec2 st0 = dFdx(vUv);
            vec2 st1 = dFdy(vUv);

            vec3 S = normalize(q0 * st1.t - q1 * st0.t);
            vec3 T = normalize(-q0 * st1.s + q1 * st0.s);
            mat3 tsn = mat3(S, T, surf_norm);

            return normalize(tsn * mapN);
          }

          void main() {
            // base normal
            vec3 N0 = normalize(vNormalW);

            // normal map sample
            vec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;
            mapN.xy *= normalScale;
            mapN = normalize(mapN);

            vec3 N = perturbNormal2Arb(vPosW, N0, mapN);

            vec3 L = normalize(sunDir);
            vec3 V = normalize(cameraPos - vPosW);

            vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
            float specMask = texture2D(specMap, vUv).r;

            float ndl = dot(N, L);
            float dayAmt = smoothstep(-0.05, 0.15, ndl);

            vec3 nightBase = dayCol * 0.07;
            vec3 col = mix(nightBase, dayCol, dayAmt);

            vec3 H = normalize(L + V);
            float spec = pow(max(dot(N, H), 0.0), 90.0) * specMask * 0.55 * dayAmt;
            col += vec3(spec);

            float rim = pow(1.0 - max(dot(N, V), 0.0), 2.25);
            col += vec3(0.06, 0.10, 0.18) * rim * (0.30 + 0.70 * dayAmt);

            gl_FragColor = vec4(linearToSrgb(col), 1.0);
          }
        `
      });

      const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);
      scene.add(earth);

      // Night lights mesh (additive) — blooms
      const lightsUniforms = {
        nightMap: { value: nightMap },
        sunDir:   { value: new THREE.Vector3(1, 0, 0) },
        gain:     { value: 2.8 } // brighter city lights
      };

      const nightLights = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
        new THREE.ShaderMaterial({
          uniforms: lightsUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            void main(){
              vUv = uv;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform sampler2D nightMap;
            uniform vec3 sunDir;
            uniform float gain;
            varying vec2 vUv;
            varying vec3 vNormalW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);
              float nightAmt = 1.0 - dayAmt;

              vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
              float mask = smoothstep(0.06, 0.38, nightAmt);

              vec3 col = lights * mask;
              float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
              gl_FragColor = vec4(linearToSrgb(col), a);
            }
          `
        })
      );
      scene.add(nightLights);

      // Cloud shadows (multiply)
      const cloudShadow = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
        new THREE.MeshBasicMaterial({
          map: cloudMap,
          color: 0x000000,
          transparent: true,
          opacity: 0.26,
          blending: THREE.MultiplyBlending,
          depthWrite: false
        })
      );
      scene.add(cloudShadow);

      // Clouds (visible)
      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
        new THREE.MeshLambertMaterial({
          map: cloudMap,
          transparent: true,
          opacity: 0.85,
          depthWrite: false
        })
      );
      scene.add(clouds);

      // Atmosphere rim — blooms
      const atmoUniforms = {
        sunDir:    { value: new THREE.Vector3(1, 0, 0) },
        cameraPos: { value: new THREE.Vector3() }
      };

      const atmosphere = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
        new THREE.ShaderMaterial({
          uniforms: atmoUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide,
          vertexShader: `
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main() {
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            void main() {
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
              float daySide = smoothstep(-0.15, 0.25, dot(N, L));

              vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
              float alpha = rim * (0.18 + 0.62 * daySide);
              gl_FragColor = vec4(col, alpha);
            }
          `
        })
      );
      scene.add(atmosphere);

      // Rotation group
      const globe = new THREE.Group();
      scene.remove(earth, nightLights, cloudShadow, clouds, atmosphere);
      globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
      scene.add(globe);

      // ---------- Selective Bloom ----------
      const BLOOM_LAYER = 1;
      const bloomLayer = new THREE.Layers();
      bloomLayer.set(BLOOM_LAYER);

      nightLights.layers.enable(BLOOM_LAYER);
      atmosphere.layers.enable(BLOOM_LAYER);

      const darkMaterial = new THREE.MeshBasicMaterial({ color: "black" });
      const materials = new Map();

      function darkenNonBloom(obj) {
        if (obj.isMesh && !bloomLayer.test(obj.layers)) {
          materials.set(obj.uuid, obj.material);
          obj.material = darkMaterial;
        }
      }
      function restoreMaterial(obj) {
        if (materials.has(obj.uuid)) {
          obj.material = materials.get(obj.uuid);
          materials.delete(obj.uuid);
        }
      }

      const renderScene = new RenderPass(scene, camera);

      // Upgraded bloom taste
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(innerWidth, innerHeight),
        1.25, // strength
        0.85, // radius
        0.18  // threshold
      );

      const bloomComposer = new EffectComposer(renderer);
      bloomComposer.renderToScreen = false;
      bloomComposer.addPass(renderScene);
      bloomComposer.addPass(bloomPass);

      const finalPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          bloomTexture: { value: bloomComposer.renderTarget2.texture }
        },
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform sampler2D bloomTexture;
          varying vec2 vUv;
          void main(){
            vec4 base = texture2D(tDiffuse, vUv);
            vec4 bloom = texture2D(bloomTexture, vUv);
            gl_FragColor = base + bloom;
          }
        `
      });

      const finalComposer = new EffectComposer(renderer);
      finalComposer.addPass(renderScene);
      finalComposer.addPass(finalPass);
      finalComposer.addPass(new OutputPass());

      function renderBloom() {
        scene.traverse(darkenNonBloom);
        bloomComposer.render();
        scene.traverse(restoreMaterial);
      }

      // ---------- Touch drag + inertia ----------
      let dragging = false, lastX = 0, lastY = 0;
      let velY = 0, velX = 0;

      const AUTO_SPIN = 0.0013;
      const DRAG_SENS = 0.0065;
      const PITCH_SENS = 0.0048;
      const DAMPING = 0.92;
      const MAX_PITCH = 0.55;

      function getPoint(e) {
        if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }

      function pointerDown(e) {
        dragging = true;
        const p = getPoint(e);
        lastX = p.x; lastY = p.y;
      }

      function pointerMove(e) {
        if (!dragging) return;
        const p = getPoint(e);
        const dx = p.x - lastX;
        const dy = p.y - lastY;
        lastX = p.x; lastY = p.y;

        globe.rotation.y += dx * DRAG_SENS;
        globe.rotation.x += dy * PITCH_SENS;
        globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));

        velY = dx * DRAG_SENS;
        velX = dy * PITCH_SENS;
      }

      function pointerUp() { dragging = false; }

      const el = renderer.domElement;
      el.addEventListener("touchstart", pointerDown, { passive: true });
      el.addEventListener("touchmove", pointerMove, { passive: true });
      el.addEventListener("touchend", pointerUp, { passive: true });
      el.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      // ---------- Animation ----------
      const sunDrift = 0.00005;
      const cloudSpin = 0.0020;

      function animate() {
        requestAnimationFrame(animate);

        clouds.rotation.y += cloudSpin;
        cloudShadow.rotation.y += cloudSpin + 0.00015;

        if (!dragging) {
          globe.rotation.y += AUTO_SPIN;
          globe.rotation.y += velY;
          globe.rotation.x += velX;
          velY *= DAMPING;
          velX *= DAMPING;
          globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));
        }

        sunLight.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), sunDrift);
        const sunDir = sunLight.position.clone().normalize();

        earthUniforms.sunDir.value.copy(sunDir);
        earthUniforms.cameraPos.value.copy(camera.position);

        lightsUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.cameraPos.value.copy(camera.position);

        renderBloom();
        finalComposer.render();
      }
      animate();

      // ---------- Resize ----------
      addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);

        bloomComposer.setSize(innerWidth, innerHeight);
        finalComposer.setSize(innerWidth, innerHeight);
        bloomPass.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
