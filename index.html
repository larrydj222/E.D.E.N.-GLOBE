<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAP E.D.E.N.</title>
  <link rel="stylesheet" href="./app.css" />
</head>

<body>
  <div id="app">
    <!-- Globe -->
    <div id="globeWrap">
      <canvas id="globeCanvas"></canvas>
      <!-- CSS2D labels container -->
      <div id="labelsLayer" aria-hidden="true"></div>
    </div>

    <!-- Floating open button (clean: no hamburger) -->
    <button id="openPanelBtn" class="fab" type="button" aria-label="Open MAP E.D.E.N. panel">
      MAP E.D.E.N.
    </button>

    <!-- Bottom sheet panel -->
    <section id="panel" class="sheet" aria-hidden="true">
      <header class="sheetHeader">
        <div class="sheetGrab" aria-hidden="true"></div>

        <div class="sheetTitle">
          <h1>MAP E.D.E.N.</h1>
          <p>Earth Diametric Energy Network • Tap Switchboard to open layers</p>
        </div>

        <button id="closePanelBtn" class="closeBtn" type="button" aria-label="Close panel">×</button>
      </header>

      <!-- Tabs row -->
      <div class="tabsRow">
        <button id="tabWelcome" class="tabBtn isActive" type="button">Welcome</button>
        <button id="tabMission" class="tabBtn" type="button">Mission</button>
        <button id="tabSwitchboard" class="tabBtn tabBtnGlow" type="button">
          Switchboard <span id="switchboardHint" class="hint">Tap to open</span>
        </button>
      </div>

      <!-- Tab bodies -->
      <div class="sheetBody">
        <!-- Welcome: loads your provided HTML file in an iframe (scroll both ways) -->
        <div id="viewWelcome" class="view isActive">
          <iframe
            id="welcomeFrame"
            title="MAP E.D.E.N. Welcome"
            src="./welcome.html"
            loading="lazy"
            sandbox="allow-same-origin"
          ></iframe>
        </div>

        <!-- Mission: extracted from welcome.html (same-origin) + fast read -->
        <div id="viewMission" class="view">
          <div class="readPane" id="missionContent">
            <div class="loading">Loading Mission…</div>
          </div>
        </div>

        <!-- Switchboard controls -->
        <div id="viewSwitchboard" class="view">
          <div class="switchboardTop">
            <div class="statusLine">
              <span id="runState">Running</span>
              <span class="dot">•</span>
              <span id="stationLine">Exit 222 • Station 1 @ 38°9′39″ N, 79°4′24″ W</span>
            </div>

            <div class="toggleRow">
              <button id="switchboardToggle" class="pillToggle" type="button" aria-pressed="false">
                Switchboard
              </button>
              <span class="toggleHint" id="switchboardToggleHint">Off</span>
            </div>
          </div>

          <!-- Layer buttons (only visible when Switchboard ON) -->
          <div id="layerGrid" class="grid isHidden" aria-hidden="true">
            <button class="layerBtn" data-layer="rhumb222">Rhumb 222 SW</button>
            <button class="layerBtn" data-layer="rhumb42">Rhumb 42 NE</button>

            <button class="layerBtn" data-layer="gc222">Great Circle 222 SW</button>
            <button class="layerBtn" data-layer="gc42">Great Circle 42 NE</button>

            <button class="layerBtn" data-layer="names222">Names 222 SW</button>
            <button class="layerBtn" data-layer="names42">Names 42 NE</button>

            <button class="layerBtn" data-layer="perps">Perpendiculars</button>
            <button class="layerBtn" data-layer="continents">Continents</button>

            <button class="layerBtn" data-layer="stations">Stations</button>
            <button class="layerBtn" data-layer="corridors">Corridors</button>

            <button class="layerBtn" data-layer="magfield">Magnetic Field</button>
            <button class="layerBtn" data-layer="aurora">Aurora</button>

            <button class="layerBtn" data-layer="night">Night Lights</button>
            <button class="layerBtn" data-layer="perpName">Perp Name</button>
          </div>

          <div id="toast" class="toast isHidden" role="status" aria-live="polite"></div>
        </div>
      </div>
    </section>
  </div>

  <script type="module" src="./app.js"></script>
</body>
</html>
:root{
  --bg:#05070b;
  --glass: rgba(18,24,34,.62);
  --glass2: rgba(20,28,40,.72);
  --stroke: rgba(255,255,255,.10);
  --stroke2: rgba(255,255,255,.14);
  --text: rgba(255,255,255,.92);
  --muted: rgba(255,255,255,.68);

  --pill: rgba(25,34,48,.55);
  --pillOn: rgba(255,255,255,.10);

  --shadow: 0 14px 55px rgba(0,0,0,.55);
  --radius: 26px;
}

*{ box-sizing:border-box; }
html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
body{ overflow:hidden; }

#app{ position:relative; height:100%; width:100%; }
#globeWrap{
  position:absolute; inset:0;
  overflow:hidden;
  background: radial-gradient(900px 600px at 55% 45%, rgba(90,160,255,.20), rgba(0,0,0,0) 60%),
              radial-gradient(800px 500px at 20% 80%, rgba(255,255,255,.06), rgba(0,0,0,0) 70%);
}
#globeCanvas{ width:100%; height:100%; display:block; }
#labelsLayer{
  position:absolute; inset:0;
  pointer-events:none;
}

/* Floating open button */
.fab{
  position:absolute;
  left:18px;
  bottom:24px;
  z-index:40;

  padding:12px 16px;
  border-radius:999px;
  border:1px solid var(--stroke2);
  background: rgba(10,14,20,.55);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  color: rgba(255,255,255,.92);
  font-weight:700;
  letter-spacing:.04em;
  box-shadow: var(--shadow);
}
.fab:active{ transform: translateY(1px); }

/* Bottom sheet */
.sheet{
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:16px;
  width:min(980px, calc(100vw - 24px));
  max-height: min(78vh, 720px);
  z-index:50;

  border-radius: var(--radius);
  border:1px solid var(--stroke);
  background: linear-gradient(180deg, rgba(24,32,45,.72), rgba(10,14,20,.70));
  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
  box-shadow: var(--shadow);

  display:none;
  overflow:hidden;
}
.sheet.isOpen{ display:flex; flex-direction:column; }

.sheetHeader{
  padding:16px 18px 10px;
  position:relative;
  border-bottom:1px solid rgba(255,255,255,.06);
}
.sheetGrab{
  width:44px; height:6px; border-radius:999px;
  background: rgba(255,255,255,.16);
  margin:0 auto 10px;
}
.sheetTitle h1{
  margin:0;
  font-size: 34px;
  letter-spacing:.06em;
}
.sheetTitle p{
  margin:6px 0 0;
  color: var(--muted);
  font-weight:600;
  font-size:16px;
}
.closeBtn{
  position:absolute;
  right:14px;
  top:16px;
  width:52px; height:52px;
  border-radius:18px;
  border:1px solid var(--stroke2);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.88);
  font-size:28px;
}
.closeBtn:active{ transform: translateY(1px); }

.tabsRow{
  display:flex;
  gap:10px;
  padding:12px 14px;
  border-bottom:1px solid rgba(255,255,255,.06);
  flex-wrap:wrap;
}
.tabBtn{
  flex:1 1 140px;
  min-width:140px;
  padding:14px 16px;
  border-radius: 18px;
  border:1px solid var(--stroke);
  background: rgba(0,0,0,.18);
  color: rgba(255,255,255,.86);
  font-weight:800;
  letter-spacing:.02em;
  display:flex;
  align-items:center;
  justify-content:space-between;
}
.tabBtn .hint{
  font-weight:700;
  color: rgba(255,255,255,.55);
  font-size:14px;
}
.tabBtn.isActive{
  background: rgba(255,255,255,.08);
  border-color: rgba(255,255,255,.18);
}
.tabBtnGlow.isOn{
  border-color: rgba(255,255,255,.28);
  box-shadow: 0 0 22px rgba(255,255,255,.16);
}

/* Body */
.sheetBody{
  padding:14px;
  overflow:auto;
  -webkit-overflow-scrolling: touch;
}

.view{ display:none; }
.view.isActive{ display:block; }

#welcomeFrame{
  width:100%;
  height: min(58vh, 520px);
  border:0;
  border-radius:18px;
  background: rgba(0,0,0,.25);
  overflow:auto; /* allow both directions */
}

/* Mission read pane */
.readPane{
  padding:16px;
  border-radius:18px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.20);
  overflow:auto;
  max-height: min(56vh, 520px);
}
.readPane h2{
  margin:0 0 10px;
  letter-spacing:.10em;
  text-transform:uppercase;
  font-size:14px;
  color: rgba(255,255,255,.85);
}
.readPane p{
  margin:0 0 14px;
  color: rgba(255,255,255,.72);
  line-height:1.7;
}
.loading{ color: rgba(255,255,255,.65); }

/* Switchboard view */
.statusLine{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:center;
  font-weight:700;
  color: rgba(255,255,255,.72);
  padding: 2px 2px 10px;
}
.statusLine .dot{ opacity:.6; }

.toggleRow{
  display:flex;
  align-items:center;
  gap:12px;
  margin-bottom:12px;
}
.pillToggle{
  padding:12px 16px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.18);
  color: rgba(255,255,255,.88);
  font-weight:900;
  letter-spacing:.03em;
}
.pillToggle.isOn{
  background: rgba(255,255,255,.10);
  border-color: rgba(255,255,255,.28);
  box-shadow: 0 0 24px rgba(255,255,255,.14);
}
.toggleHint{ color: rgba(255,255,255,.62); font-weight:800; }

.grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:12px;
}
.grid.isHidden{ display:none; }
.layerBtn{
  padding:16px 16px;
  border-radius: 20px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.16);
  color: rgba(255,255,255,.90);
  font-weight:900;
  letter-spacing:.02em;
  text-align:left;
}
.layerBtn.isOn{
  border-color: rgba(255,255,255,.22);
  background: rgba(255,255,255,.08);
  box-shadow: 0 0 18px rgba(255,255,255,.08);
}
.layerBtn:active{ transform: translateY(1px); }

/* Toast */
.toast{
  margin-top:12px;
  padding:12px 14px;
  border-radius:14px;
  border:1px solid rgba(255,80,80,.25);
  background: rgba(60,10,10,.45);
  color: rgba(255,220,220,.92);
  font-weight:700;
}
.toast.isHidden{ display:none; }

/* LABELS (Names/Continents/etc) — smaller + subtle glow */
.label{
  position:absolute;
  transform: translate(-50%,-50%);
  white-space:nowrap;
  font-weight:800;
  font-size:12px;
  letter-spacing:.02em;
  color: rgba(255,255,255,.88);
  text-shadow: 0 0 6px rgba(255,255,255,.18);
}

/* Continents can have a very light “pill” if you want */
.label--continent{
  padding:4px 8px;
  border-radius:999px;
  background: rgba(0,0,0,.18);
  border:1px solid rgba(255,255,255,.08);
}

/* IMPORTANT: Names layers must be text-only (NO borders / NO backgrounds) */
.label--names{
  padding:0;
  border:0;
  background: transparent;
  border-radius:0;
}

/* Landscape tweaks: keep globe controllable + panel scrollable */
@media (orientation: landscape){
  .sheet{
    max-height: min(70vh, 560px);
  }
  #welcomeFrame{
    height: min(46vh, 420px);
  }
}
/* MAP E.D.E.N. — app.js
   - Single WebGL context (prevents iOS rotate crashes)
   - Debounced resize/orientation updates
   - Switchboard toggles layer buttons (show/hide)
   - Names layers = text-only labels (no borders)
   - Welcome loads welcome.html (your uploaded HTML)  [oai_citation:1‡MAP E.D.E.N. ( Welcome Page ) .html](sediment://file_000000002a1071f896e5609269801671)
*/

const $ = (sel) => document.querySelector(sel);

const ui = {
  openPanelBtn: $("#openPanelBtn"),
  closePanelBtn: $("#closePanelBtn"),
  panel: $("#panel"),

  tabWelcome: $("#tabWelcome"),
  tabMission: $("#tabMission"),
  tabSwitchboard: $("#tabSwitchboard"),
  switchboardHint: $("#switchboardHint"),

  viewWelcome: $("#viewWelcome"),
  viewMission: $("#viewMission"),
  viewSwitchboard: $("#viewSwitchboard"),
  missionContent: $("#missionContent"),

  switchboardToggle: $("#switchboardToggle"),
  switchboardToggleHint: $("#switchboardToggleHint"),
  layerGrid: $("#layerGrid"),
  toast: $("#toast"),

  labelsLayer: $("#labelsLayer"),
  canvas: $("#globeCanvas"),

  runState: $("#runState"),
  stationLine: $("#stationLine"),
};

const STATION_1 = {
  name: "Exit 222 • Station 1",
  latDeg: 38 + 9/60 + 39/3600,        // 38°9′39″ N
  lonDeg: -(79 + 4/60 + 24/3600),     // 79°4′24″ W
};

ui.stationLine.textContent = `${STATION_1.name} @ 38°9′39″ N, 79°4′24″ W`;

function showToast(msg){
  ui.toast.textContent = msg;
  ui.toast.classList.remove("isHidden");
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=> ui.toast.classList.add("isHidden"), 4200);
}

/* -----------------------------
   Tabs / Panel behavior
----------------------------- */
function openPanel(){
  ui.panel.classList.add("isOpen");
  ui.panel.setAttribute("aria-hidden","false");
}
function closePanel(){
  ui.panel.classList.remove("isOpen");
  ui.panel.setAttribute("aria-hidden","true");
}
ui.openPanelBtn.addEventListener("click", openPanel);
ui.closePanelBtn.addEventListener("click", closePanel);

function setActiveTab(which){
  const map = {
    welcome: [ui.tabWelcome, ui.viewWelcome],
    mission: [ui.tabMission, ui.viewMission],
    switchboard: [ui.tabSwitchboard, ui.viewSwitchboard],
  };

  Object.values(map).forEach(([btn, view])=>{
    btn.classList.remove("isActive");
    view.classList.remove("isActive");
  });

  map[which][0].classList.add("isActive");
  map[which][1].classList.add("isActive");
}
ui.tabWelcome.addEventListener("click", ()=> setActiveTab("welcome"));
ui.tabMission.addEventListener("click", ()=> setActiveTab("mission"));
ui.tabSwitchboard.addEventListener("click", ()=> setActiveTab("switchboard"));

/* Switchboard master toggle (show/hide layer buttons) */
let switchboardOn = false;

function setSwitchboard(on){
  switchboardOn = !!on;

  ui.switchboardToggle.classList.toggle("isOn", switchboardOn);
  ui.switchboardToggle.setAttribute("aria-pressed", String(switchboardOn));
  ui.switchboardToggleHint.textContent = switchboardOn ? "On" : "Off";

  ui.layerGrid.classList.toggle("isHidden", !switchboardOn);
  ui.layerGrid.setAttribute("aria-hidden", String(!switchboardOn));

  // White glow on the top Switchboard tab when ON
  ui.tabSwitchboard.classList.toggle("isOn", switchboardOn);
  ui.switchboardHint.textContent = switchboardOn ? "Tap to close" : "Tap to open";
}

ui.switchboardToggle.addEventListener("click", ()=> setSwitchboard(!switchboardOn));

/* -----------------------------
   Load Mission content from welcome.html
   (same-origin fetch & extract)
----------------------------- */
async function loadMissionFromWelcome(){
  try{
    const res = await fetch("./welcome.html", { cache: "no-store" });
    const html = await res.text();
    const doc = new DOMParser().parseFromString(html, "text/html");

    // Grab the first "Mission" block section if present
    // Your welcome file includes Mission content describing MAP E.D.E.N. and Project E.D.E.N.  [oai_citation:2‡MAP E.D.E.N. ( Welcome Page ) .html](sediment://file_000000002a1071f896e5609269801671)
    const missionHeading = Array.from(doc.querySelectorAll("h2, h3"))
      .find(h => (h.textContent || "").trim().toLowerCase() === "mission");

    const wrap = document.createElement("div");
    const title = document.createElement("h2");
    title.textContent = "Mission";
    wrap.appendChild(title);

    if(missionHeading){
      // Take a reasonable slice of content after the mission heading
      let node = missionHeading.nextElementSibling;
      let count = 0;
      while(node && count < 10){
        if(node.tagName === "H2") break;
        const clone = node.cloneNode(true);
        // sanitize large images/videos inside mission view
        clone.querySelectorAll("img, video").forEach(el=> el.remove());
        wrap.appendChild(clone);
        node = node.nextElementSibling;
        count++;
      }
      if(wrap.querySelectorAll("p").length === 0){
        const p = document.createElement("p");
        p.textContent = "Mission content found, but it couldn’t be extracted cleanly. Use the Welcome tab to view the full page.";
        wrap.appendChild(p);
      }
    }else{
      const p = document.createElement("p");
      p.textContent = "Mission section not detected. Use the Welcome tab to view the full page.";
      wrap.appendChild(p);
    }

    ui.missionContent.innerHTML = "";
    ui.missionContent.appendChild(wrap);
  }catch(err){
    ui.missionContent.innerHTML = `<div class="loading">Mission failed to load. Use the Welcome tab.</div>`;
  }
}
loadMissionFromWelcome();

/* -----------------------------
   THREE.JS import with fallback
----------------------------- */
async function importThree(){
  try{
    const THREE = await import("https://unpkg.com/three@0.160.0/build/three.module.js");
    const { OrbitControls } = await import("https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js");
    return { THREE, OrbitControls };
  }catch(e){
    // Optional local fallback if you later add /vendor files
    const THREE = await import("./vendor/three.module.js");
    const { OrbitControls } = await import("./vendor/OrbitControls.js");
    return { THREE, OrbitControls };
  }
}

/* -----------------------------
   Globe + Layers
----------------------------- */
const state = {
  THREE: null,
  OrbitControls: null,
  renderer: null,
  scene: null,
  camera: null,
  controls: null,
  raf: 0,
  running: true,

  globe: null,
  nightMesh: null,
  auroraMesh: null,
  magMesh: null,

  // Layer objects
  layers: new Map(),
  labels: {
    continents: [],
    names222: [],
    names42: [],
    perpName: [],
  },

  // Resize scheduling
  resizePending: false,
  lastSize: { w: 0, h: 0 },
};

function clampDPR(){
  // Prevent iOS Safari GPU overload on rotate
  const dpr = window.devicePixelRatio || 1;
  return Math.min(2, Math.max(1, dpr));
}

/* Math helpers */
const DEG2RAD = Math.PI / 180;
function latLonToVec3(THREE, latDeg, lonDeg, radius){
  const lat = latDeg * DEG2RAD;
  const lon = lonDeg * DEG2RAD;
  const x = radius * Math.cos(lat) * Math.cos(lon);
  const y = radius * Math.sin(lat);
  const z = radius * Math.cos(lat) * Math.sin(lon);
  return new THREE.Vector3(x,y,z);
}

/* Great-circle points */
function greatCirclePoints(THREE, lat1Deg, lon1Deg, bearingDeg, steps=720){
  const lat1 = lat1Deg * DEG2RAD;
  const lon1 = lon1Deg * DEG2RAD;
  const brng = bearingDeg * DEG2RAD;

  const pts = [];
  // go to antipode (pi radians)
  for(let i=0;i<=steps;i++){
    const d = (Math.PI * i) / steps;
    const sinLat1 = Math.sin(lat1), cosLat1 = Math.cos(lat1);
    const sinD = Math.sin(d), cosD = Math.cos(d);

    const lat2 = Math.asin(sinLat1*cosD + cosLat1*sinD*Math.cos(brng));
    const lon2 = lon1 + Math.atan2(Math.sin(brng)*sinD*cosLat1, cosD - sinLat1*Math.sin(lat2));
    pts.push({ lat: lat2/DEG2RAD, lon: lon2/DEG2RAD });
  }
  return pts;
}

/* Rhumb-line points (loxodrome approximation) */
function rhumbPoints(THREE, lat1Deg, lon1Deg, bearingDeg, steps=720){
  const φ1 = lat1Deg * DEG2RAD;
  const λ1 = lon1Deg * DEG2RAD;
  const θ = bearingDeg * DEG2RAD;

  const pts = [];
  // "half-circumference" angular distance
  const total = Math.PI;
  for(let i=0;i<=steps;i++){
    const d = total * (i/steps);

    const Δφ = d * Math.cos(θ);
    let φ2 = φ1 + Δφ;
    // clamp near poles
    const pole = (Math.PI/2) - 1e-6;
    φ2 = Math.max(-pole, Math.min(pole, φ2));

    const Δψ = Math.log(
      Math.tan(Math.PI/4 + φ2/2) / Math.tan(Math.PI/4 + φ1/2)
    );
    const q = Math.abs(Δψ) > 1e-12 ? (Δφ/Δψ) : Math.cos(φ1);

    const Δλ = d * Math.sin(θ) / q;
    const λ2 = λ1 + Δλ;

    pts.push({ lat: φ2/DEG2RAD, lon: λ2/DEG2RAD });
  }
  return pts;
}

/* Build line from lat/lon points */
function buildLine(THREE, ptsLL, radius, colorHex, opacity=0.95){
  const geom = new THREE.BufferGeometry();
  const arr = new Float32Array((ptsLL.length) * 3);
  for(let i=0;i<ptsLL.length;i++){
    const v = latLonToVec3(THREE, ptsLL[i].lat, ptsLL[i].lon, radius);
    arr[i*3+0]=v.x; arr[i*3+1]=v.y; arr[i*3+2]=v.z;
  }
  geom.setAttribute("position", new THREE.BufferAttribute(arr, 3));
  const mat = new THREE.LineBasicMaterial({ color: colorHex, transparent:true, opacity });
  return new THREE.Line(geom, mat);
}

/* Corridor boundary lines +/- km around the great circle plane */
function buildCorridorLines(THREE, gcPtsLL, radius, normalVec3, kmList=[1,5,10]){
  const R_EARTH_KM = 6371;
  const lines = [];

  const n = normalVec3.clone().normalize();
  // Convert ll -> vecs first
  const vecs = gcPtsLL.map(p => latLonToVec3(THREE, p.lat, p.lon, 1).normalize()); // unit sphere

  function offsetLine(alphaRad, sign){
    const pts = vecs.map(v=>{
      // side direction in tangent plane toward component of n
      const s = n.clone().sub(v.clone().multiplyScalar(n.dot(v))).normalize();
      const vOff = v.clone().multiplyScalar(Math.cos(alphaRad))
        .add(s.multiplyScalar(sign*Math.sin(alphaRad))).normalize();
      return vOff.multiplyScalar(radius);
    });
    const geom = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent:true, opacity: 0.20 });
    return new THREE.Line(geom, mat);
  }

  for(const km of kmList){
    const alpha = km / R_EARTH_KM; // radians
    lines.push(offsetLine(alpha, +1));
    lines.push(offsetLine(alpha, -1));
  }
  return lines;
}

/* Labels */
function makeLabel(text, className){
  const el = document.createElement("div");
  el.className = `label ${className || ""}`.trim();
  el.textContent = text;
  ui.labelsLayer.appendChild(el);
  return el;
}

/* Project 3D point to screen */
function projectToScreen(THREE, camera, vec3){
  const v = vec3.clone().project(camera);
  const x = (v.x * 0.5 + 0.5) * ui.labelsLayer.clientWidth;
  const y = (-v.y * 0.5 + 0.5) * ui.labelsLayer.clientHeight;
  return { x, y, z: v.z };
}

function setLabelVisible(el, on){
  el.style.display = on ? "block" : "none";
}

/* -----------------------------
   Init
----------------------------- */
async function init(){
  const { THREE, OrbitControls } = await importThree();
  state.THREE = THREE;
  state.OrbitControls = OrbitControls;

  const scene = new THREE.Scene();
  state.scene = scene;

  const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
  camera.position.set(0, 0, 3.2);
  state.camera = camera;

  const renderer = new THREE.WebGLRenderer({
    canvas: ui.canvas,
    antialias: true,
    alpha: true,
    powerPreference: "high-performance",
    preserveDrawingBuffer: false,
  });
  renderer.setPixelRatio(clampDPR());
  state.renderer = renderer;

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.55));
  const dir = new THREE.DirectionalLight(0xffffff, 1.05);
  dir.position.set(3, 2, 2);
  scene.add(dir);

  // Controls
  const controls = new OrbitControls(camera, ui.canvas);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.rotateSpeed = 0.55;
  controls.zoomSpeed = 0.7;
  controls.enablePan = false;
  controls.minDistance = 2.1;
  controls.maxDistance = 5.0;
  state.controls = controls;

  // Globe sphere
  const radius = 1.0;
  const tex = new THREE.TextureLoader();

  // IMPORTANT: use local assets (prevents your “CDN blocked” issues for textures)
  // Put these in /assets next to your site.
  const dayMap = tex.load("./assets/earth_day.jpg", undefined, undefined, ()=> showToast("Day texture failed (check ./assets/earth_day.jpg)"));
  const bumpMap = tex.load("./assets/earth_bump.jpg", undefined, undefined, ()=> {});
  const specMap = tex.load("./assets/earth_spec.jpg", undefined, undefined, ()=> {});

  const globeMat = new THREE.MeshPhongMaterial({
    map: dayMap,
    bumpMap,
    bumpScale: 0.015,
    specularMap: specMap,
    specular: new THREE.Color(0x222222),
    shininess: 12,
  });

  const globe = new THREE.Mesh(new THREE.SphereGeometry(radius, 96, 96), globeMat);
  state.globe = globe;
  scene.add(globe);

  // Atmosphere glow
  const atmo = new THREE.Mesh(
    new THREE.SphereGeometry(radius * 1.012, 96, 96),
    new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent:true, opacity:0.18 })
  );
  scene.add(atmo);

  // Overlays (night lights, aurora, magnetic field)
  // Use local assets to ensure they actually appear when toggled
  const nightTex = tex.load("./assets/earth_night.jpg", undefined, undefined, ()=> showToast("Night Lights texture missing: ./assets/earth_night.jpg"));
  state.nightMesh = new THREE.Mesh(
    new THREE.SphereGeometry(radius * 1.001, 96, 96),
    new THREE.MeshBasicMaterial({ map: nightTex, transparent:true, opacity:0.75, blending: THREE.AdditiveBlending })
  );
  state.nightMesh.visible = false;
  scene.add(state.nightMesh);

  const aurTex = tex.load("./assets/aurora.png", undefined, undefined, ()=> showToast("Aurora texture missing: ./assets/aurora.png"));
  state.auroraMesh = new THREE.Mesh(
    new THREE.SphereGeometry(radius * 1.002, 96, 96),
    new THREE.MeshBasicMaterial({ map: aurTex, transparent:true, opacity:0.55, blending: THREE.AdditiveBlending })
  );
  state.auroraMesh.visible = false;
  scene.add(state.auroraMesh);

  const magTex = tex.load("./assets/magnetic_field.png", undefined, undefined, ()=> showToast("Magnetic Field texture missing: ./assets/magnetic_field.png"));
  state.magMesh = new THREE.Mesh(
    new THREE.SphereGeometry(radius * 1.003, 96, 96),
    new THREE.MeshBasicMaterial({ map: magTex, transparent:true, opacity:0.38, blending: THREE.AdditiveBlending })
  );
  state.magMesh.visible = false;
  scene.add(state.magMesh);

  // Build axis lines
  const gc222LL = greatCirclePoints(THREE, STATION_1.latDeg, STATION_1.lonDeg, 222, 720);
  const gc42LL  = greatCirclePoints(THREE, STATION_1.latDeg, STATION_1.lonDeg, 42, 720);

  const rh222LL = rhumbPoints(THREE, STATION_1.latDeg, STATION_1.lonDeg, 222, 720);
  const rh42LL  = rhumbPoints(THREE, STATION_1.latDeg, STATION_1.lonDeg, 42, 720);

  const lineRh222 = buildLine(THREE, rh222LL, radius*1.004, 0xffcc55, 0.90);
  const lineRh42  = buildLine(THREE, rh42LL,  radius*1.004, 0xaaaaaa, 0.55);

  const lineGc222 = buildLine(THREE, gc222LL, radius*1.006, 0x55b7ff, 0.88);
  const lineGc42  = buildLine(THREE, gc42LL,  radius*1.006, 0xaaaaaa, 0.55);

  lineRh222.visible = false;
  lineRh42.visible  = false;
  lineGc222.visible = false;
  lineGc42.visible  = false;

  scene.add(lineRh222, lineRh42, lineGc222, lineGc42);

  state.layers.set("rhumb222", lineRh222);
  state.layers.set("rhumb42",  lineRh42);
  state.layers.set("gc222",    lineGc222);
  state.layers.set("gc42",     lineGc42);

  // Great-circle plane normal for corridor offsets
  // Approximate normal using two points from gc222
  const a = latLonToVec3(THREE, gc222LL[0].lat, gc222LL[0].lon, 1).normalize();
  const b = latLonToVec3(THREE, gc222LL[Math.floor(gc222LL.length/4)].lat, gc222LL[Math.floor(gc222LL.length/4)].lon, 1).normalize();
  const gcNormal = a.clone().cross(b).normalize();

  const corridorLines = buildCorridorLines(THREE, gc222LL, radius*1.002, gcNormal, [1,5,10]);
  corridorLines.forEach(l => { l.visible=false; scene.add(l); });
  state.layers.set("corridors", corridorLines);

  // Perpendiculars (132° / 312°) as great circles from the same station
  const perp132 = buildLine(THREE, greatCirclePoints(THREE, STATION_1.latDeg, STATION_1.lonDeg, 132, 720), radius*1.005, 0xffffff, 0.22);
  const perp312 = buildLine(THREE, greatCirclePoints(THREE, STATION_1.latDeg, STATION_1.lonDeg, 312, 720), radius*1.005, 0xffffff, 0.22);
  perp132.visible=false; perp312.visible=false;
  scene.add(perp132, perp312);
  state.layers.set("perps", [perp132, perp312]);

  // Stations
  const stationDot = new THREE.Mesh(
    new THREE.SphereGeometry(0.012, 16, 16),
    new THREE.MeshBasicMaterial({ color: 0x66ffcc })
  );
  stationDot.position.copy(latLonToVec3(THREE, STATION_1.latDeg, STATION_1.lonDeg, radius*1.01));
  stationDot.visible = false;
  scene.add(stationDot);
  state.layers.set("stations", [stationDot]);

  // Labels: Continents (light pill style) + Names layers (text only)
  // Continents
  const continentDefs = [
    ["North America", 40, -100],
    ["South America", -15, -60],
    ["Europe", 52, 15],
    ["Africa", 5, 20],
    ["Asia", 35, 95],
    ["Australia", -25, 135],
    ["Antarctica", -78, 0],
  ];
  for(const [name, lat, lon] of continentDefs){
    const el = makeLabel(name, "label--continent");
    const pos = latLonToVec3(THREE, lat, lon, radius*1.03);
    state.labels.continents.push({ el, pos, on:false });
    setLabelVisible(el, false);
  }

  // Names along 222 SW and 42 NE (NO borders, simple glow)
  // (These are examples — replace with your actual landmark list later.)
  const names222 = [
    ["Exit 222 • Station 1", STATION_1.latDeg, STATION_1.lonDeg],
    ["222 SW Corridor", 10, -120],
    ["Deep Antarctic Interior", -76, -135],
  ];
  for(const [txt, lat, lon] of names222){
    const el = makeLabel(txt, "label--names");
    const pos = latLonToVec3(THREE, lat, lon, radius*1.03);
    state.labels.names222.push({ el, pos, on:false });
    setLabelVisible(el, false);
  }

  const names42 = [
    ["42 NE Corridor", 55, -40],
    ["Archive/Dense Systems", 78, 20],
  ];
  for(const [txt, lat, lon] of names42){
    const el = makeLabel(txt, "label--names");
    const pos = latLonToVec3(THREE, lat, lon, radius*1.03);
    state.labels.names42.push({ el, pos, on:false });
    setLabelVisible(el, false);
  }

  // Perp Name labels
  const perpNames = [
    ["Perp 132°", 20, 40],
    ["Perp 312°", -20, -140],
  ];
  for(const [txt, lat, lon] of perpNames){
    const el = makeLabel(txt, "label--names");
    const pos = latLonToVec3(THREE, lat, lon, radius*1.03);
    state.labels.perpName.push({ el, pos, on:false });
    setLabelVisible(el, false);
  }

  // Hook up layer buttons
  document.querySelectorAll(".layerBtn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const key = btn.dataset.layer;
      toggleLayer(key, btn);
    });
  });

  // Resize handling (debounced + safe)
  const scheduleResize = () => {
    if(state.resizePending) return;
    state.resizePending = true;
    requestAnimationFrame(()=>{
      state.resizePending = false;
      doResize();
    });
  };

  // Observe container size changes (best for orientation changes)
  const ro = new ResizeObserver(scheduleResize);
  ro.observe($("#globeWrap"));

  // Extra safety for iOS orientation change
  window.addEventListener("orientationchange", ()=>{
    setTimeout(scheduleResize, 60);
    setTimeout(scheduleResize, 260);
  }, { passive:true });

  window.addEventListener("resize", scheduleResize, { passive:true });

  document.addEventListener("visibilitychange", ()=>{
    state.running = (document.visibilityState === "visible");
    if(state.running) loop();
    else cancelAnimationFrame(state.raf);
  });

  doResize();
  loop();
}

function setAllLabelsOff(groupKey){
  const arr = state.labels[groupKey];
  arr.forEach(o=>{
    o.on = false;
    setLabelVisible(o.el, false);
  });
}

function setLabels(groupKey, on){
  const arr = state.labels[groupKey];
  arr.forEach(o=>{
    o.on = on;
    setLabelVisible(o.el, on);
  });
}

function toggleLayer(key, btn){
  const obj = state.layers.get(key);

  // Handle special overlay layers
  if(key === "night"){
    state.nightMesh.visible = !state.nightMesh.visible;
    btn.classList.toggle("isOn", state.nightMesh.visible);
    return;
  }
  if(key === "aurora"){
    state.auroraMesh.visible = !state.auroraMesh.visible;
    btn.classList.toggle("isOn", state.auroraMesh.visible);
    return;
  }
  if(key === "magfield"){
    state.magMesh.visible = !state.magMesh.visible;
    btn.classList.toggle("isOn", state.magMesh.visible);
    return;
  }

  // Labels groups
  if(key === "continents"){
    const newOn = !state.labels.continents.some(x=>x.on);
    setLabels("continents", newOn);
    btn.classList.toggle("isOn", newOn);
    return;
  }
  if(key === "names222"){
    // IMPORTANT: Names must have NO borders -> handled by CSS .label--names
    const newOn = !state.labels.names222.some(x=>x.on);
    setLabels("names222", newOn);
    btn.classList.toggle("isOn", newOn);
    return;
  }
  if(key === "names42"){
    const newOn = !state.labels.names42.some(x=>x.on);
    setLabels("names42", newOn);
    btn.classList.toggle("isOn", newOn);
    return;
  }
  if(key === "perpName"){
    const newOn = !state.labels.perpName.some(x=>x.on);
    setLabels("perpName", newOn);
    btn.classList.toggle("isOn", newOn);
    return;
  }

  // Arrays of objects (perps, stations, corridors)
  if(Array.isArray(obj)){
    const anyOn = obj.some(x=>x.visible);
    obj.forEach(x=> x.visible = !anyOn);
    btn.classList.toggle("isOn", !anyOn);
    return;
  }

  // Single object
  if(obj){
    obj.visible = !obj.visible;
    btn.classList.toggle("isOn", obj.visible);
    return;
  }

  showToast(`Layer not found: ${key}`);
}

function doResize(){
  const w = ui.canvas.clientWidth || window.innerWidth;
  const h = ui.canvas.clientHeight || window.innerHeight;

  // Guard against transient 0 sizes during rotation
  if(w < 4 || h < 4) return;

  if(Math.abs(state.lastSize.w - w) < 1 && Math.abs(state.lastSize.h - h) < 1) return;

  state.lastSize.w = w;
  state.lastSize.h = h;

  state.renderer.setPixelRatio(clampDPR());
  state.renderer.setSize(w, h, false);

  state.camera.aspect = w / h;
  state.camera.updateProjectionMatrix();
}

function updateLabels(){
  const { THREE } = state;
  const cam = state.camera;

  const groups = ["continents","names222","names42","perpName"];
  for(const g of groups){
    for(const item of state.labels[g]){
      if(!item.on) continue;
      const p = projectToScreen(THREE, cam, item.pos);
      // Hide if behind camera
      if(p.z > 1){
        item.el.style.display = "none";
        continue;
      }
      item.el.style.display = "block";
      item.el.style.left = `${p.x}px`;
      item.el.style.top  = `${p.y}px`;
    }
  }
}

function loop(){
  if(!state.running) return;
  state.raf = requestAnimationFrame(loop);
  state.controls.update();
  updateLabels();
  state.renderer.render(state.scene, state.camera);
}

/* Start app */
init().catch(err=>{
  console.error(err);
  showToast("Three.js failed to load. Check network or local /vendor fallback.");
});

/* Default UI state */
setActiveTab("welcome");
setSwitchboard(false);
