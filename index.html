<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>E.D.E.N. Globe</title>
    <style>
      html, body { height: 100%; margin: 0; background: #05060a; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

      // ---------- Scene / Camera / Renderer ----------
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 5000);
      camera.position.set(0, 0, 3.4);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      // ---------- Lights (sun direction drives terminator) ----------
      scene.add(new THREE.AmbientLight(0xffffff, 0.10));

      const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
      sunLight.position.set(5, 1.5, 2.5);
      scene.add(sunLight);

      // ---------- Textures (Three.js CORS-friendly) ----------
      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin("anonymous");

      const TEX = {
        day:    "https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg",
        night:  "https://threejs.org/examples/textures/planets/earth_lights_2048.png",
        spec:   "https://threejs.org/examples/textures/planets/earth_specular_2048.jpg",
        clouds: "https://threejs.org/examples/textures/planets/earth_clouds_1024.png",
        stars:  "https://threejs.org/examples/textures/galaxy_starfield.png"
      };

      const dayMap   = loader.load(TEX.day);
      const nightMap = loader.load(TEX.night);
      const specMap  = loader.load(TEX.spec);
      const cloudMap = loader.load(TEX.clouds);
      const starMap  = loader.load(TEX.stars);

      dayMap.colorSpace = THREE.SRGBColorSpace;
      nightMap.colorSpace = THREE.SRGBColorSpace;
      cloudMap.colorSpace = THREE.SRGBColorSpace;
      starMap.colorSpace = THREE.SRGBColorSpace;
      specMap.colorSpace = THREE.SRGBColorSpace;

      // ---------- Stars (background sphere) ----------
      {
        const starGeo = new THREE.SphereGeometry(90, 64, 64);
        const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
        scene.add(new THREE.Mesh(starGeo, starMat));
      }

      // ---------- Earth (custom shader = day/night terminator + spec) ----------
      const earthRadius = 1.0;

      const earthUniforms = {
        dayMap:    { value: dayMap },
        nightMap:  { value: nightMap },
        specMap:   { value: specMap },
        sunDir:    { value: new THREE.Vector3(1, 0, 0) },
        cameraPos: { value: new THREE.Vector3() }
      };

      const earthMat = new THREE.ShaderMaterial({
        uniforms: earthUniforms,
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          void main() {
            vUv = uv;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vPosW = worldPos.xyz;
            vNormalW = normalize(mat3(modelMatrix) * normal);
            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `,
        fragmentShader: `
          precision highp float;
          uniform sampler2D dayMap;
          uniform sampler2D nightMap;
          uniform sampler2D specMap;
          uniform vec3 sunDir;
          uniform vec3 cameraPos;

          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;

          vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
          vec3 linearToSrgb(vec3 c){ return pow(max(c, 0.0), vec3(1.0/2.2)); }

          void main() {
            vec3 N = normalize(vNormalW);
            vec3 L = normalize(sunDir);
            vec3 V = normalize(cameraPos - vPosW);

            vec3 dayCol   = srgbToLinear(texture2D(dayMap, vUv).rgb);
            vec3 nightCol = srgbToLinear(texture2D(nightMap, vUv).rgb);
            float specMask = texture2D(specMap, vUv).r;

            float ndl = dot(N, L);
            float dayAmt = smoothstep(-0.10, 0.20, ndl);

            vec3 col = mix(nightCol, dayCol, dayAmt);

            vec3 H = normalize(L + V);
            float spec = pow(max(dot(N, H), 0.0), 80.0) * specMask * 0.45 * dayAmt;
            col += vec3(spec);

            float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
            col += vec3(0.06, 0.10, 0.16) * rim * (0.35 + 0.65 * dayAmt);

            gl_FragColor = vec4(linearToSrgb(col), 1.0);
          }
        `
      });

      const earth = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius, 128, 128),
        earthMat
      );
      scene.add(earth);

      // ---------- Cloud shadows (multiply layer) ----------
      const cloudShadow = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.0015, 128, 128),
        new THREE.MeshBasicMaterial({
          map: cloudMap,
          color: 0x000000,
          transparent: true,
          opacity: 0.28,
          blending: THREE.MultiplyBlending,
          depthWrite: false
        })
      );
      scene.add(cloudShadow);

      // ---------- Clouds (visible layer) ----------
      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.012, 128, 128),
        new THREE.MeshLambertMaterial({
          map: cloudMap,
          transparent: true,
          opacity: 0.85,
          depthWrite: false
        })
      );
      scene.add(clouds);

      // ---------- Thin atmosphere rim shader ----------
      const atmoUniforms = {
        sunDir:    { value: new THREE.Vector3(1, 0, 0) },
        cameraPos: { value: new THREE.Vector3() }
      };

      const atmosphere = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.045, 128, 128),
        new THREE.ShaderMaterial({
          uniforms: atmoUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide,
          vertexShader: `
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main() {
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            void main() {
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
              float daySide = smoothstep(-0.15, 0.25, dot(N, L));

              vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
              float alpha = rim * (0.20 + 0.60 * daySide);

              gl_FragColor = vec4(col, alpha);
            }
          `
        })
      );
      scene.add(atmosphere);

      // ---------- Animation (just spins) ----------
      const earthSpin = 0.0016;
      const cloudSpin = 0.0023;
      const sunDrift  = 0.00005;

      function animate() {
        requestAnimationFrame(animate);

        earth.rotation.y += earthSpin;
        clouds.rotation.y += cloudSpin;
        cloudShadow.rotation.y += cloudSpin + 0.0002;

        sunLight.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), sunDrift);

        const sunDir = sunLight.position.clone().normalize();
        earthUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.sunDir.value.copy(sunDir);

        earthUniforms.cameraPos.value.copy(camera.position);
        atmoUniforms.cameraPos.value.copy(camera.position);

        renderer.render(scene, camera);
      }
      animate();

      addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
