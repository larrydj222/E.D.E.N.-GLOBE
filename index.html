<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAP E.D.E.N. Globe</title>

  <style>
    :root{
      --glass: rgba(12,14,18,0.60);
      --stroke: rgba(255,255,255,0.12);
      --stroke2: rgba(255,255,255,0.14);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted2: rgba(255,255,255,0.46);

      --gold: #f6c24a;
      --blue: #5bbcff;
      --aqua: #7fffd4;
      --violet:#a078ff;
      --white:#ffffff;

      --green: rgba(120,255,200,0.88);
    }

    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; touch-action:none; }
    canvas { display:block; width:100vw !important; height:100vh !important; }

    /* ---------- Floating OPEN button ---------- */
    #openBtn{
      position: fixed;
      left: 18px;
      bottom: 18px;
      z-index: 10000;
      display: none;
      align-items: center;
      padding: 12px 14px;
      border-radius: 18px;
      color: var(--text);
      background: rgba(12,14,18,0.62);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.42);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      font: 900 13px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.35px;
    }
    #openBtn:active { transform: translateY(1px); }

    /* ---------- Bottom Drawer ---------- */
    #drawer {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      width: min(820px, calc(100vw - 28px));
      max-height: calc(100vh - 28px);
      z-index: 9999;
      color: var(--text);
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: 22px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.42);
      user-select: none;
      overflow: hidden;
    }

    #drawer.closed{
      transform: translateX(-50%) translateY(140%);
      opacity: 0;
      pointer-events: none;
      transition: transform 240ms ease, opacity 200ms ease;
    }
    #drawer:not(.closed){
      transition: transform 240ms ease, opacity 200ms ease;
    }

    #handle {
      width: 44px;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.18);
      margin: 6px auto 10px;
      cursor: pointer;
    }

    #drawerTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    #titleBlock{
      display:flex;
      flex-direction:column;
      gap:4px;
      padding-right: 8px;
    }
    #title {
      font: 900 18px/1.1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.25px;
    }
    #subtitle{
      font: 650 12px/1.25 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: var(--muted);
      max-width: 540px;
    }

    #closeBtn{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color: transparent;
      flex: 0 0 auto;
    }
    #closeBtn:active { transform: translateY(1px); }

    #drawerBody{
      margin-top: 12px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      max-height: calc(100vh - 190px);
      padding-bottom: 6px;
    }

    .gridTop{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 10px;
    }

    .grid2{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .pill {
      width: 100%;
      display:inline-flex;
      align-items:center;
      justify-content: space-between;
      gap:10px;
      padding: 12px 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font: 900 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.15px;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .pill:active { transform: translateY(1px); }

    .pill .left{
      display:inline-flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }
    .pill .label{
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .pill .hint{
      font: 800 11px/1.1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,0.55);
      letter-spacing: 0.1px;
      text-align: right;
    }

    .dot {
      width: 10px; height: 10px;
      border-radius: 50%;
      background: rgba(255,255,255,0.16);
      box-shadow: 0 0 0 rgba(0,0,0,0);
      flex: 0 0 auto;
    }

    .pill.on .dot{
      background: var(--green);
      box-shadow: 0 0 16px rgba(120,255,200,0.24);
    }

    .pill.on[data-key="rhumb222"] .dot{ background: rgba(246,194,74,0.95); box-shadow:0 0 16px rgba(246,194,74,0.22); }
    .pill.on[data-key="gc222"]    .dot{ background: rgba(91,188,255,0.92); box-shadow:0 0 16px rgba(91,188,255,0.22); }

    .pill.on[data-key="rhumb42"] .dot{ background: rgba(246,194,74,0.55); box-shadow:0 0 16px rgba(246,194,74,0.16); }
    .pill.on[data-key="gc42"]    .dot{ background: rgba(91,188,255,0.55); box-shadow:0 0 16px rgba(91,188,255,0.16); }

    .pill.on[data-key="stations"]   .dot{ background: rgba(127,255,212,0.90); box-shadow:0 0 16px rgba(127,255,212,0.18); }
    .pill.on[data-key="aurora"]     .dot{ background: rgba(160,120,255,0.92); box-shadow:0 0 16px rgba(160,120,255,0.18); }
    .pill.on[data-key="nightLights"].dot{ background: rgba(140,255,200,0.92); box-shadow:0 0 16px rgba(140,255,200,0.18); }

    .pill.switch.on{
      border-color: rgba(255,255,255,0.22);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset, 0 0 28px rgba(255,255,255,0.10);
    }

    #statusBar{
      margin-top: 10px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:center;
      color: var(--muted2);
      font: 800 11px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    #errors{
      margin-top: 10px;
      display:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,120,120,0.22);
      background: rgba(80,10,10,0.35);
      color: rgba(255,170,170,0.95);
      font: 650 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      white-space: pre-wrap;
    }

    #drawer.collapsed #drawerBody,
    #drawer.collapsed #statusBar,
    #drawer.collapsed #errors { display:none; }
    #drawer.collapsed { padding-bottom: 12px; }

    #switchboardGroup{ display:none; }
    #switchboardGroup.on{ display:block; }

    /* ---------- Modal ---------- */
    #modalMask{
      position: fixed;
      inset: 0;
      z-index: 20000;
      background: rgba(0,0,0,0.62);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    #modalMask.on{ display:flex; }

    #modal{
      width: min(980px, calc(100vw - 24px));
      height: min(84vh, 780px);
      background: rgba(12,14,18,0.78);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 22px;
      box-shadow: 0 20px 70px rgba(0,0,0,0.55);
      overflow: hidden;
      display:flex;
      flex-direction: column;
    }

    #modalTop{
      display:flex;
      align-items:center;
      justify-content: space-between;
      padding: 12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    #modalTitle{
      font: 900 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.3px;
      color: rgba(255,255,255,0.92);
      padding-left: 6px;
    }
    #modalClose{
      width: 40px;
      height: 40px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      cursor:pointer;
    }

    #modalBody{
      flex: 1 1 auto;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      background: rgba(0,0,0,0.15);
    }

    #welcomeFrame{
      width: 100%;
      height: 100%;
      border: 0;
      display:block;
      background: #000;
    }

    #missionContent{
      padding: 18px 18px 24px;
      color: rgba(255,255,255,0.88);
      font: 650 14px/1.55 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      max-width: 920px;
      margin: 0 auto;
    }
    #missionContent h2{
      font: 900 18px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      margin: 0 0 10px;
      letter-spacing: 0.2px;
    }
    #missionContent p{ margin: 0 0 12px; color: rgba(255,255,255,0.80); }

    @media (max-width: 520px){
      .pill{ padding: 12px 12px; border-radius: 16px; font-size: 13px; }
      #drawerBody{ max-height: calc(100vh - 200px); }
      #subtitle{ max-width: 310px; }
      .pill .hint{ display:none; }
    }
    @media (max-width: 380px){
      .gridTop{ grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <button id="openBtn" aria-label="Open MAP E.D.E.N.">MAP E.D.E.N.</button>

  <div id="drawer">
    <div id="handle" title="Tap to collapse/expand"></div>

    <div id="drawerTop">
      <div id="titleBlock">
        <div id="title">MAP E.D.E.N.</div>
        <div id="subtitle">Earth Diametric Energy Network • Tap Switchboard to open layers</div>
      </div>
      <button id="closeBtn" aria-label="Close drawer" title="Close">✕</button>
    </div>

    <div id="drawerBody">
      <div class="gridTop">
        <button class="pill" id="welcomeBtn">
          <span class="left"><span class="dot"></span><span class="label">Welcome</span></span>
        </button>

        <button class="pill" id="missionBtn">
          <span class="left"><span class="dot"></span><span class="label">Mission</span></span>
        </button>

        <button class="pill switch" id="switchboardBtn">
          <span class="left"><span class="dot"></span><span class="label">Switchboard</span></span>
          <span class="hint" id="switchHint">Tap to open</span>
        </button>
      </div>

      <div id="switchboardGroup">
        <div class="grid2">
          <button class="pill on" data-key="rhumb222"><span class="left"><span class="dot"></span><span class="label">Rhumb 222 SW</span></span></button>
          <button class="pill" data-key="rhumb42"><span class="left"><span class="dot"></span><span class="label">Rhumb 42 NE</span></span></button>

          <button class="pill on" data-key="gc222"><span class="left"><span class="dot"></span><span class="label">Great Circle 222 SW</span></span></button>
          <button class="pill" data-key="gc42"><span class="left"><span class="dot"></span><span class="label">Great Circle 42 NE</span></span></button>

          <button class="pill" data-key="names222"><span class="left"><span class="dot"></span><span class="label">Names 222 SW</span></span></button>
          <button class="pill" data-key="names42"><span class="left"><span class="dot"></span><span class="label">Names 42 NE</span></span></button>

          <button class="pill" data-key="perpLine"><span class="left"><span class="dot"></span><span class="label">Perpendiculars</span></span></button>
          <button class="pill" data-key="continents"><span class="left"><span class="dot"></span><span class="label">Continents</span></span></button>

          <button class="pill on" data-key="stations"><span class="left"><span class="dot"></span><span class="label">Stations</span></span></button>
          <button class="pill" data-key="corridors"><span class="left"><span class="dot"></span><span class="label">Corridors</span></span></button>

          <button class="pill" data-key="magField"><span class="left"><span class="dot"></span><span class="label">Magnetic Field</span></span></button>
          <button class="pill" data-key="aurora"><span class="left"><span class="dot"></span><span class="label">Aurora</span></span></button>

          <button class="pill on" data-key="nightLights"><span class="left"><span class="dot"></span><span class="label">Night Lights</span></span></button>
          <button class="pill" data-key="perpName"><span class="left"><span class="dot"></span><span class="label">Perp Name</span></span></button>
        </div>
      </div>

      <div id="errors"></div>
    </div>

    <div id="statusBar">
      <span id="status">Booting…</span>
      <span id="stationText">Exit 222 • Station 1 @ 38°9′39″ N, 79°4′24″ W</span>
    </div>
  </div>

  <div id="modalMask" role="dialog" aria-modal="true" aria-label="MAP E.D.E.N. Modal">
    <div id="modal">
      <div id="modalTop">
        <div id="modalTitle">WELCOME</div>
        <button id="modalClose" aria-label="Close modal">✕</button>
      </div>
      <div id="modalBody">
        <iframe id="welcomeFrame" title="MAP E.D.E.N. Welcome" loading="lazy"></iframe>

        <!-- Mission content -->
        <div id="missionContent" style="display:none;">
          <h2>MISSION</h2>
          <p>MAP E.D.E.N. is the operational field platform for Project E.D.E.N. (Earth Diametric &amp; Energy Network)—a secure, repeatable way to run real-world tests along defined Earth corridors, beginning with the 42/222 diametric axis (42° and 222° are opposite bearings on the same straight line). Based on a 20+ year personal observation record, the Founder identified “222” as a persistent recurring numeric event marker across routine environments (time displays, identifiers, signage). This long-duration recurrence served as the initial trigger for structuring Project E.D.E.N. as a measurement-first field program.</p>
          <p>Over time, and in multiple documented sessions, the “222” event marker also coincided with a compass bearing of 222° (SW)—reinforcing the 42/222 line as a repeatable corridor for formal testing. MAP E.D.E.N. equips trusted operators with clear protocols to collect environmental field measurements and navigation-behavior observations, including human biological magnetoreception and magnetically influenced orientation, homing, and migratory navigation in animals and insects, so results can be compared across time.</p>
        </div>

      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
    import { EffectComposer } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/RenderPass.js";
    import { ShaderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/ShaderPass.js";
    import { OutputPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/OutputPass.js";
    import { UnrealBloomPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js";

    // ---------- UI ----------
    const statusEl   = document.getElementById("status");
    const errorsEl   = document.getElementById("errors");
    const drawerEl   = document.getElementById("drawer");
    const openBtn    = document.getElementById("openBtn");
    const closeBtn   = document.getElementById("closeBtn");
    const handle     = document.getElementById("handle");

    const welcomeBtn = document.getElementById("welcomeBtn");
    const missionBtn = document.getElementById("missionBtn");
    const switchBtn  = document.getElementById("switchboardBtn");
    const switchHint = document.getElementById("switchHint");
    const switchGrp  = document.getElementById("switchboardGroup");

    const modalMask  = document.getElementById("modalMask");
    const modalClose = document.getElementById("modalClose");
    const modalTitle = document.getElementById("modalTitle");
    const welcomeFrame = document.getElementById("welcomeFrame");
    const missionContent = document.getElementById("missionContent");

    // Make top buttons light green when pressed
    function setTopBtnOn(btn, isOn){
      if (!btn) return;
      btn.classList.toggle("on", !!isOn);
    }

    function showError(msg){
      if (!errorsEl) return;
      errorsEl.style.display = "block";
      errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
      statusEl.textContent = "Error (see panel)";
    }
    window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
    window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

    function setDrawerClosed(isClosed){
      drawerEl.classList.toggle("closed", !!isClosed);
      openBtn.style.display = isClosed ? "inline-flex" : "none";
    }
    setDrawerClosed(false);
    openBtn.addEventListener("click", () => setDrawerClosed(false));
    closeBtn.addEventListener("click", () => setDrawerClosed(true));
    handle.addEventListener("click", () => drawerEl.classList.toggle("collapsed"));

    // Modal controls
    function openModal(kind){
      modalMask.classList.add("on");
      setTopBtnOn(welcomeBtn, kind === "welcome");
      setTopBtnOn(missionBtn, kind === "mission");
      if (kind === "welcome"){
        modalTitle.textContent = "WELCOME";
        missionContent.style.display = "none";
        welcomeFrame.style.display = "block";

        // Drop-in HTML file (put this file next to this globe HTML in your repo)
        const WELCOME_FILE = "welcome.html";
        welcomeFrame.src = encodeURI(WELCOME_FILE);
      } else {
        modalTitle.textContent = "MISSION";
        welcomeFrame.style.display = "none";
        missionContent.style.display = "block";
      }
    }
    function closeModal(){
      modalMask.classList.remove("on");
      setTopBtnOn(welcomeBtn, false);
      setTopBtnOn(missionBtn, false);
      // avoid iOS memory spikes by unloading iframe when closed
      if (welcomeFrame.style.display !== "none") welcomeFrame.src = "about:blank";
    }
    modalClose.addEventListener("click", closeModal);
    modalMask.addEventListener("click", (e)=>{ if(e.target === modalMask) closeModal(); });
    welcomeBtn.addEventListener("click", ()=>openModal("welcome"));
    missionBtn.addEventListener("click", ()=>openModal("mission"));

    // Switchboard open/close (green light stays on while open)
    let switchboardOn = false;
    function setSwitchboard(on){
      switchboardOn = !!on;
      switchBtn.classList.toggle("on", switchboardOn);
      switchGrp.classList.toggle("on", switchboardOn);
      switchHint.textContent = switchboardOn ? "Tap to close" : "Tap to open";
    }
    switchBtn.addEventListener("click", ()=> setSwitchboard(!switchboardOn));
    setSwitchboard(false);

    // ---------- Math helpers ----------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const DEG = Math.PI/180;
    const RAD = 180/Math.PI;

    function isUIEventTarget(target){
      return !!(target && (target.closest?.("#drawer") || target.closest?.("#openBtn") || target.closest?.("#modalMask")));
    }

    function latLonToVec3(latDeg, lonDeg, radius=1.0){
      const lat = latDeg * DEG;
      const lon = lonDeg * DEG;
      return new THREE.Vector3(
        radius * Math.cos(lat) * Math.cos(lon),
        radius * Math.sin(lat),
        radius * Math.cos(lat) * Math.sin(lon)
      );
    }

    function greatCirclePoints(lat0Deg, lon0Deg, bearingDeg, stepDeg=1.0){
      const lat0 = lat0Deg * DEG;
      const lon0 = lon0Deg * DEG;
      const brng = bearingDeg * DEG;

      const pts = [];
      for(let d=-180; d<=180; d+=stepDeg){
        const δ = d * DEG;
        const sinLat = Math.sin(lat0)*Math.cos(δ) + Math.cos(lat0)*Math.sin(δ)*Math.cos(brng);
        const lat = Math.asin(clamp(sinLat, -1, 1));
        const y = Math.sin(brng)*Math.sin(δ)*Math.cos(lat0);
        const x = Math.cos(δ) - Math.sin(lat0)*Math.sin(lat);
        const lon = lon0 + Math.atan2(y, x);
        pts.push({ lat: lat*RAD, lon: ((lon*RAD + 540) % 360) - 180 });
      }
      return pts;
    }

    // Rhumb line (loxodrome) forward computation for plotting
    function rhumbLinePoints(lat0Deg, lon0Deg, bearingDeg, stepKm=120, steps=120){
      const R = 6371;
      const brng = bearingDeg * DEG;

      let lat = lat0Deg * DEG;
      let lon = lon0Deg * DEG;

      const pts = [{lat: lat0Deg, lon: lon0Deg}];

      for(let i=0;i<steps;i++){
        const d = (stepKm / R); // angular distance
        const dLat = d * Math.cos(brng);
        lat = lat + dLat;

        // Clamp lat to avoid infinity at poles
        lat = clamp(lat, -Math.PI/2 + 1e-6, Math.PI/2 - 1e-6);

        const dPsi = Math.log(Math.tan(Math.PI/4 + lat/2) / Math.tan(Math.PI/4 + (lat - dLat)/2));
        const q = (Math.abs(dPsi) > 1e-12) ? (dLat / dPsi) : Math.cos(lat);

        const dLon = d * Math.sin(brng) / q;
        lon = lon + dLon;

        const latDeg = lat * RAD;
        const lonDeg = ((lon * RAD + 540) % 360) - 180;
        pts.push({lat: latDeg, lon: lonDeg});
      }
      return pts;
    }

    // ---------- Scene ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 3.0);

    const group = new THREE.Group();
    scene.add(group);

    // Lighting
    const sunLight = new THREE.DirectionalLight(0xffffff, 1.6);
    sunLight.position.set(5, 2, 5);
    scene.add(sunLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.25));

    // ---------- Texture loading ----------
    const loader = new THREE.TextureLoader();
    const base = "https://unpkg.com/three@0.161.0/examples/textures/";

    statusEl.textContent = "Starting…";

    const textures = {};
    function loadTex(name, url){
      return new Promise((resolve, reject)=>{
        loader.load(url, (t)=>{
          t.colorSpace = THREE.SRGBColorSpace;
          t.anisotropy = 8;
          textures[name] = t;
          resolve(t);
        }, undefined, reject);
      });
    }

    (async()=>{
      try{
        statusEl.textContent = "Loading textures…";

        // Use standard three.js example textures for stable GitHub Pages hosting.
        // Earth base + spec + normal
        await loadTex("earthMap", base + "planets/earth_atmos_2048.jpg");
        await loadTex("earthNormal", base + "planets/earth_normal_2048.jpg");
        await loadTex("earthSpec", base + "planets/earth_specular_2048.jpg");
        await loadTex("clouds", base + "planets/earth_clouds_1024.png");

        // Night lights (fallback: re-use earth map if missing)
        try{
          await loadTex("night", base + "planets/earth_lights_2048.png");
        }catch(e){
          textures.night = textures.earthMap;
        }

        // ---------- Earth material (custom shader for day/night + spec) ----------
        const radius = 1.0;

        const earthUniforms = {
          dayMap:    { value: textures.earthMap },
          nightMap:  { value: textures.night },
          normalMap: { value: textures.earthNormal },
          specMap:   { value: textures.earthSpec },
          sunDir:    { value: sunLight.position.clone().normalize() },
          cameraPos: { value: camera.position.clone() },
        };

        const earthMat = new THREE.ShaderMaterial({
          uniforms: earthUniforms,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vUv = uv;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              vec4 wPos = modelMatrix * vec4(position,1.0);
              vPosW = wPos.xyz;
              gl_Position = projectionMatrix * viewMatrix * wPos;
            }
          `,
          fragmentShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            uniform sampler2D dayMap;
            uniform sampler2D nightMap;
            uniform sampler2D normalMap;
            uniform sampler2D specMap;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;

            // Cheap normal mapping (tangent-free approximation)
            vec3 perturbNormal(vec3 n, vec2 uv){
              vec3 nm = texture2D(normalMap, uv).xyz * 2.0 - 1.0;
              // rotate normal map into world-ish space using base normal (approx)
              vec3 up = abs(n.y) < 0.999 ? vec3(0.0,1.0,0.0) : vec3(1.0,0.0,0.0);
              vec3 t = normalize(cross(up, n));
              vec3 b = cross(n, t);
              mat3 TBN = mat3(t, b, n);
              return normalize(TBN * nm);
            }

            void main(){
              vec3 n = normalize(vNormalW);
              vec3 nn = perturbNormal(n, vUv);

              float ndl = clamp(dot(nn, normalize(sunDir)), 0.0, 1.0);

              vec3 day = texture2D(dayMap, vUv).rgb;
              vec3 night = texture2D(nightMap, vUv).rgb;

              // Soften terminator
              float t = smoothstep(0.05, 0.35, ndl);

              vec3 col = mix(night * 1.15, day, t);

              // Specular
              vec3 v = normalize(cameraPos - vPosW);
              vec3 h = normalize(v + normalize(sunDir));
              float spec = pow(clamp(dot(nn, h), 0.0, 1.0), 64.0);
              float specMask = texture2D(specMap, vUv).r;
              col += spec * specMask * 0.55;

              gl_FragColor = vec4(col, 1.0);
            }
          `
        });

        const earthGeo = new THREE.SphereGeometry(radius, 64, 64);
        const earth = new THREE.Mesh(earthGeo, earthMat);
        group.add(earth);

        // Clouds
        const cloudsMat = new THREE.MeshLambertMaterial({
          map: textures.clouds,
          transparent: true,
          opacity: 0.38,
          depthWrite: false
        });
        const clouds = new THREE.Mesh(new THREE.SphereGeometry(radius*1.005, 64, 64), cloudsMat);
        group.add(clouds);

        // Subtle cloud shadow (darken day side slightly)
        const cloudShadowMat = new THREE.MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.10,
          depthWrite: false
        });
        const cloudShadow = new THREE.Mesh(new THREE.SphereGeometry(radius*1.003, 64, 64), cloudShadowMat);
        group.add(cloudShadow);

        // Atmosphere glow
        const atmoUniforms = {
          sunDir: { value: sunLight.position.clone().normalize() },
          cameraPos: { value: camera.position.clone() }
        };
        const atmoMat = new THREE.ShaderMaterial({
          uniforms: atmoUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexShader: `
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vNormalW = normalize(mat3(modelMatrix) * normal);
              vec4 wPos = modelMatrix * vec4(position,1.0);
              vPosW = wPos.xyz;
              gl_Position = projectionMatrix * viewMatrix * wPos;
            }
          `,
          fragmentShader: `
            varying vec3 vNormalW;
            varying vec3 vPosW;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;

            void main(){
              vec3 n = normalize(vNormalW);
              vec3 v = normalize(cameraPos - vPosW);
              float fres = pow(1.0 - clamp(dot(n, v), 0.0, 1.0), 2.2);
              float day = clamp(dot(n, normalize(sunDir)), 0.0, 1.0);
              vec3 col = mix(vec3(0.08,0.25,0.55), vec3(0.25,0.55,0.95), day);
              gl_FragColor = vec4(col * fres * 0.75, fres);
            }
          `
        });
        const atmo = new THREE.Mesh(new THREE.SphereGeometry(radius*1.02, 64, 64), atmoMat);
        group.add(atmo);

        // ---------- Overlays (lines/points) ----------
        const overlays = new THREE.Group();
        group.add(overlays);

        const lineMaterial = (rgb, opacity=0.95)=> new THREE.LineBasicMaterial({ color: rgb, transparent:true, opacity });

        function buildLineFromLatLon(points, color, opacity=0.95){
          const geom = new THREE.BufferGeometry();
          const verts = [];
          for(const p of points){
            const v = latLonToVec3(p.lat, p.lon, radius*1.001);
            verts.push(v.x, v.y, v.z);
          }
          geom.setAttribute("position", new THREE.Float32BufferAttribute(verts, 3));
          return new THREE.Line(geom, lineMaterial(color, opacity));
        }

        // Station 1: 38°9′39″ N, 79°4′24″ W
        const STATION1 = { lat: 38 + 9/60 + 39/3600, lon: -(79 + 4/60 + 24/3600) };

        // Main axis bearing corridor
        const rhumb222Pts = rhumbLinePoints(STATION1.lat, STATION1.lon, 222, 160, 140);
        const rhumb42Pts  = rhumbLinePoints(STATION1.lat, STATION1.lon, 42, 160, 140);
        const gc222Pts    = greatCirclePoints(STATION1.lat, STATION1.lon, 222, 1.0);
        const gc42Pts     = greatCirclePoints(STATION1.lat, STATION1.lon, 42, 1.0);

        const lineRhumb222 = buildLineFromLatLon(rhumb222Pts, 0xF6C24A, 0.95);
        const lineRhumb42  = buildLineFromLatLon(rhumb42Pts,  0xF6C24A, 0.35);
        const lineGc222    = buildLineFromLatLon(gc222Pts,    0x5BBCFF, 0.95);
        const lineGc42     = buildLineFromLatLon(gc42Pts,     0x5BBCFF, 0.35);

        overlays.add(lineRhumb222, lineRhumb42, lineGc222, lineGc42);

        // Names/labels as sprite text
        function makeTextSprite(text, color="#ffffff"){
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const pad = 18;
          ctx.font = "800 36px -apple-system, system-ui, Segoe UI, Roboto, Arial";
          const w = Math.ceil(ctx.measureText(text).width) + pad*2;
          const h = 64;
          canvas.width = w; canvas.height = h;
          ctx.font = "800 36px -apple-system, system-ui, Segoe UI, Roboto, Arial";
          ctx.fillStyle = "rgba(0,0,0,0.0)";
          ctx.fillRect(0,0,w,h);
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillRect(0,0,w,h);
          ctx.fillStyle = color;
          ctx.textBaseline = "middle";
          ctx.fillText(text, pad, h/2);

          const tex = new THREE.CanvasTexture(canvas);
          tex.colorSpace = THREE.SRGBColorSpace;
          const mat = new THREE.SpriteMaterial({ map: tex, transparent:true, opacity:0.95, depthWrite:false });
          const spr = new THREE.Sprite(mat);
          spr.scale.set(0.55*(w/h), 0.55, 1);
          return spr;
        }

        const labelGroup = new THREE.Group();
        overlays.add(labelGroup);

        const label222 = makeTextSprite("222° SW", "rgba(246,194,74,0.98)");
        label222.position.copy(latLonToVec3(STATION1.lat - 8, STATION1.lon - 8, radius*1.08));
        labelGroup.add(label222);

        const label42 = makeTextSprite("42° NE", "rgba(91,188,255,0.98)");
        label42.position.copy(latLonToVec3(STATION1.lat + 10, STATION1.lon + 10, radius*1.08));
        labelGroup.add(label42);

        // Perpendicular controls (132/312) shown as short segments through station
        function buildPerpSegment(bearing){
          const pts = greatCirclePoints(STATION1.lat, STATION1.lon, bearing, 3.0).slice(50, 72);
          return buildLineFromLatLon(pts, 0xffffff, 0.35);
        }
        const perp132 = buildPerpSegment(132);
        const perp312 = buildPerpSegment(312);
        overlays.add(perp132, perp312);

        // Continents placeholder (simple sphere ring grid)
        const grid = new THREE.GridHelper(4, 12, 0xffffff, 0xffffff);
        grid.material.transparent = true;
        grid.material.opacity = 0.08;
        grid.rotation.x = Math.PI/2;
        overlays.add(grid);

        // Stations
        const stationsGroup = new THREE.Group();
        overlays.add(stationsGroup);

        const stationMat = new THREE.MeshBasicMaterial({ color: 0x7FFFD4 });
        const stationDot = new THREE.Mesh(new THREE.SphereGeometry(0.013, 18, 18), stationMat);
        stationDot.position.copy(latLonToVec3(STATION1.lat, STATION1.lon, radius*1.01));
        stationsGroup.add(stationDot);

        const stationLabel = makeTextSprite("Station 1", "rgba(127,255,212,0.98)");
        stationLabel.position.copy(latLonToVec3(STATION1.lat+2.2, STATION1.lon-2.5, radius*1.07));
        stationsGroup.add(stationLabel);

        // Corridors placeholder (offset rings)
        const corridorGroup = new THREE.Group();
        overlays.add(corridorGroup);
        corridorGroup.visible = false;
        for(const op of [0.0, 0.015, 0.03]){
          const ring = new THREE.Mesh(
            new THREE.TorusGeometry(radius*1.002, 0.0016, 10, 180),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity: 0.10 })
          );
          ring.rotation.x = Math.PI/2;
          ring.scale.set(1+op,1+op,1);
          corridorGroup.add(ring);
        }

        // Magnetic field placeholder (subtle arrows)
        const fieldGroup = new THREE.Group();
        overlays.add(fieldGroup);
        fieldGroup.visible = false;
        const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity: 0.12 });
        for(let i=0;i<18;i++){
          const a = (i/18) * Math.PI*2;
          const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.01, 0.04, 10), arrowMat);
          arrow.position.set(Math.cos(a)*1.1, 0, Math.sin(a)*1.1);
          arrow.lookAt(0,0,0);
          arrow.rotateX(Math.PI/2);
          fieldGroup.add(arrow);
        }

        // Aurora placeholder (glow belt)
        const auroraGroup = new THREE.Group();
        overlays.add(auroraGroup);
        auroraGroup.visible = false;
        const auroraMat = new THREE.MeshBasicMaterial({ color: 0xA078FF, transparent:true, opacity: 0.10, blending: THREE.AdditiveBlending });
        const aurora = new THREE.Mesh(new THREE.TorusGeometry(radius*1.08, 0.035, 20, 240), auroraMat);
        aurora.rotation.x = Math.PI/2;
        aurora.rotation.y = Math.PI/6;
        auroraGroup.add(aurora);

        // Night lights toggle (just boosts night map contribution by raising opacity of a mesh shell)
        const nightGroup = new THREE.Group();
        overlays.add(nightGroup);
        const nightShellMat = new THREE.MeshBasicMaterial({
          map: textures.night,
          transparent: true,
          opacity: 0.0,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        const nightShell = new THREE.Mesh(new THREE.SphereGeometry(radius*1.0005, 64, 64), nightShellMat);
        nightGroup.add(nightShell);

        // ---------- Toggle map ----------
        const toggles = {
          rhumb222: { el: document.querySelector('.pill[data-key="rhumb222"]'), obj: lineRhumb222, on: true },
          rhumb42:  { el: document.querySelector('.pill[data-key="rhumb42"]'),  obj: lineRhumb42,  on: false },
          gc222:    { el: document.querySelector('.pill[data-key="gc222"]'),    obj: lineGc222,    on: true },
          gc42:     { el: document.querySelector('.pill[data-key="gc42"]'),     obj: lineGc42,     on: false },

          names222: { el: document.querySelector('.pill[data-key="names222"]'), obj: label222, on: false },
          names42:  { el: document.querySelector('.pill[data-key="names42"]'),  obj: label42,  on: false },

          perpLine: { el: document.querySelector('.pill[data-key="perpLine"]'), obj: [perp132, perp312], on: false },
          continents:{el: document.querySelector('.pill[data-key="continents"]'), obj: grid, on: false },
          stations: { el: document.querySelector('.pill[data-key="stations"]'), obj: stationsGroup, on: true },
          corridors:{ el: document.querySelector('.pill[data-key="corridors"]'), obj: corridorGroup, on: false },
          magField: { el: document.querySelector('.pill[data-key="magField"]'), obj: fieldGroup, on: false },
          aurora:   { el: document.querySelector('.pill[data-key="aurora"]'),   obj: auroraGroup, on: false },
          nightLights:{el: document.querySelector('.pill[data-key="nightLights"]'), obj: nightShellMat, on: true },
          perpName: { el: document.querySelector('.pill[data-key="perpName"]'), obj: null, on: false }
        };

        function applyToggle(key){
          const t = toggles[key];
          if (!t) return;
          t.on = !t.on;
          t.el.classList.toggle("on", t.on);

          if (key === "nightLights"){
            nightShellMat.opacity = t.on ? 0.40 : 0.0;
            return;
          }

          const obj = t.obj;
          if (Array.isArray(obj)){
            obj.forEach(o=> o.visible = t.on);
          } else if (obj && obj.visible !== undefined){
            obj.visible = t.on;
          } else if (obj){
            obj.visible = t.on;
          }
        }

        for (const [k,t] of Object.entries(toggles)){
          if (!t.el) continue;
          // apply initial state
          t.el.classList.toggle("on", !!t.on);
          if (k === "nightLights"){ nightShellMat.opacity = t.on ? 0.40 : 0.0; }
          else if (Array.isArray(t.obj)) t.obj.forEach(o=>o.visible = !!t.on);
          else if (t.obj && t.obj.visible !== undefined) t.obj.visible = !!t.on;

          t.el.addEventListener("click", ()=> applyToggle(k));
        }

        // ---------- Postprocessing (bloom) ----------
        const renderScene = new RenderPass(scene, camera);

        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.75, 0.35, 0.90);
        bloomComposer.addPass(bloomPass);

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        const finalPass = new ShaderPass(new THREE.ShaderMaterial({
          uniforms: {
            baseTexture: { value: null },
            bloomTexture:{ value: bloomComposer.renderTarget2.texture }
          },
          vertexShader: `
            varying vec2 vUv;
            void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
          `,
          fragmentShader: `
            uniform sampler2D baseTexture;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main(){
              vec4 base = texture2D(baseTexture, vUv);
              vec4 bloom = texture2D(bloomTexture, vUv);
              gl_FragColor = base + bloom * 0.95;
            }
          `,
          defines: {}
        }), "baseTexture");
        finalPass.needsSwap = true;
        finalComposer.addPass(finalPass);
        finalComposer.addPass(new OutputPass());

        // ---------- Interaction ----------
        let dragging = false;
        let lastX = 0, lastY = 0;
        let velX = 0, velY = 0;
        const DAMPING = 0.92;
        const ROT_SPEED = 0.005;
        const AUTO_SPIN = 0.00035;
        const MAX_PITCH = Math.PI/2.4;

        let pinching = false;
        let startDist = 0;
        let startZ = camera.position.z;
        const Z_MIN = 1.8, Z_MAX = 5.0;

        function getDist(t1, t2){
          const dx = t1.clientX - t2.clientX;
          const dy = t1.clientY - t2.clientY;
          return Math.sqrt(dx*dx + dy*dy);
        }

        function pointerDown(e){
          if (isUIEventTarget(e.target)) return;
          dragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          renderer.domElement.setPointerCapture?.(e.pointerId);
        }
        function pointerMove(e){
          if (!dragging || isUIEventTarget(e.target)) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          lastX = e.clientX;
          lastY = e.clientY;
          velY = dx * ROT_SPEED;
          velX = dy * ROT_SPEED;
          group.rotation.y += velY;
          group.rotation.x = clamp(group.rotation.x + velX, -MAX_PITCH, MAX_PITCH);
        }
        function pointerUp(){
          dragging = false;
        }

        renderer.domElement.addEventListener("pointerdown", pointerDown, { passive:true });
        renderer.domElement.addEventListener("pointermove", pointerMove, { passive:true });
        renderer.domElement.addEventListener("pointerup", pointerUp, { passive:true });
        renderer.domElement.addEventListener("pointercancel", pointerUp, { passive:true });

        // Touch pinch zoom
        renderer.domElement.addEventListener("touchstart", (e)=>{
          if (isUIEventTarget(e.target)) return;
          if (e.touches.length === 2){
            pinching = true;
            startDist = getDist(e.touches[0], e.touches[1]);
            startZ = camera.position.z;
          }
        }, { passive:true });

        renderer.domElement.addEventListener("touchmove", (e)=>{
          if (!pinching || isUIEventTarget(e.target)) return;
          if (e.touches.length === 2){
            const d = getDist(e.touches[0], e.touches[1]);
            const scale = startDist / d;
            camera.position.z = clamp(startZ * scale, Z_MIN, Z_MAX);
          }
        }, { passive:true });

        renderer.domElement.addEventListener("touchend", (e)=>{
          if (e.touches.length < 2) pinching = false;
        }, { passive:true });

        // Wheel zoom
        window.addEventListener("wheel", (e)=>{
          if (isUIEventTarget(e.target)) return;
          camera.position.z = clamp(camera.position.z + (e.deltaY * 0.0025), Z_MIN, Z_MAX);
        }, { passive:true });

        // Resize (stable on iOS rotation)
        let resizeTimer = 0;
        function doResize(){
          const w = Math.max(1, window.innerWidth);
          const h = Math.max(1, window.innerHeight);

          camera.aspect = w/h;
          camera.updateProjectionMatrix();
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);

          bloomComposer.setSize(w, h);
          finalComposer.setSize(w, h);
          bloomPass.setSize(w, h);
        }
        function scheduleResize(){
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(()=> requestAnimationFrame(doResize), 160);
        }
        window.addEventListener("resize", scheduleResize, { passive:true });
        window.addEventListener("orientationchange", scheduleResize, { passive:true });

        // Render loop
        let running = true;
        let rafId = 0;

        function renderBloom(){
          // render bloom into target
          bloomComposer.render();
        }

        statusEl.textContent = "Running";

        const sunDrift = 0.00005;
        const cloudSpin = 0.0020;

        function animate(){
          if (!running){ rafId = 0; return; }
          rafId = requestAnimationFrame(animate);

          clouds.rotation.y += cloudSpin;
          cloudShadow.rotation.y += cloudSpin + 0.00015;

          if(!dragging && !pinching){
            group.rotation.y += AUTO_SPIN + velY;
            group.rotation.x = clamp(group.rotation.x + velX, -MAX_PITCH, MAX_PITCH);
            velY *= DAMPING;
            velX *= DAMPING;
          }

          sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
          const sunDir = sunLight.position.clone().normalize();
          earthUniforms.sunDir.value.copy(sunDir);
          earthUniforms.cameraPos.value.copy(camera.position);
          atmoUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.cameraPos.value.copy(camera.position);

          renderBloom();
          finalComposer.render();
        }
        animate();

        // Pause render when hidden
        document.addEventListener("visibilitychange", ()=>{
          running = !document.hidden;
          if (running && !rafId) animate();
        });

      } catch (err){
        showError("Top-level error:\n" + (err?.stack || err?.message || err));
      }
    })();
  </script>
</body>
</html>
