<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>MAP E.D.E.N.</title>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100vw !important;
      height: 100vh !important;
    }

    /* LEFT floating toggle button (always visible) */
    #drawerToggle{
      position: fixed;
      left: 14px;
      bottom: 22px;
      z-index: 10000;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 12px 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(12,14,18,0.62);
      color: rgba(255,255,255,0.92);
      font: 800 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.15px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 14px 44px rgba(0,0,0,0.40);
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    #drawerToggle:active{ transform: translateY(1px); }
    #drawerToggle .chev{
      display:inline-flex;
      width: 18px; height: 18px;
      align-items:center; justify-content:center;
      opacity: 0.92;
    }
    #drawerToggle .lbl{ opacity: 0.88; }

    /* Drawer panel */
    #drawer{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      width: min(920px, 94vw);
      border-radius: 26px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(10,12,16,0.62);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      box-shadow: 0 26px 78px rgba(0,0,0,0.55);
      padding: 18px 18px 16px;
      z-index: 9999;
      transition: transform 260ms ease, opacity 260ms ease;
      opacity: 1;
    }

    #drawer.open{
      transform: translateX(-50%) translateY(0);
      pointer-events: auto;
    }
    #drawer.closed{
      transform: translateX(-50%) translateY(calc(100% + 22px));
      opacity: 0.0;
      pointer-events: none;
    }

    #drawerTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 14px;
      margin-bottom: 14px;
    }
    #title{
      font: 900 34px/1.05 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.6px;
      color: rgba(255,255,255,0.92);
    }
    #subtitle{
      margin-top: 8px;
      font: 600 14px/1.25 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,0.66);
      letter-spacing: 0.15px;
    }

    .row{
      display:flex;
      flex-wrap:wrap;
      gap: 12px;
      margin-top: 12px;
    }

    .pill{
      flex: 1 1 160px;
      min-width: 160px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      padding: 14px 16px;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.86);
      font: 800 18px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
      letter-spacing: 0.2px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .pill:active{ transform: translateY(1px); }
    .pill .dot{
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(255,255,255,0.18);
      box-shadow: 0 0 0 2px rgba(255,255,255,0.08) inset;
    }
    .pill.on{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.18);
    }
    .pill.on .dot{
      background: rgba(255,255,255,0.72);
      box-shadow: 0 0 16px rgba(160,210,255,0.45);
    }

    #statusLine{
      margin-top: 14px;
      display:flex;
      justify-content:space-between;
      gap: 12px;
      flex-wrap: wrap;
      font: 700 14px/1.25 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: rgba(255,255,255,0.72);
    }
    #hint{
      color: rgba(255,255,255,0.50);
      font-weight: 700;
    }

    #errors{
      margin-top: 12px;
      display:none;
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,80,80,0.28);
      background: rgba(80,10,10,0.52);
      color: rgba(255,210,210,0.92);
      font: 700 13px/1.25 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
    }

    @supports (padding: max(0px)) {
      #drawerToggle{ bottom: max(22px, env(safe-area-inset-bottom)); }
      #drawer{ bottom: max(18px, env(safe-area-inset-bottom)); }
    }
  </style>

  <!-- ✅ Import Map: makes "three" + "three/addons/" work on GitHub Pages -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <button id="drawerToggle" aria-label="Toggle layers panel" title="Layers">
    <span class="chev">×</span>
    <span class="lbl">Close</span>
  </button>

  <div id="drawer" class="open">
    <div id="drawerTop">
      <div>
        <div id="title">MAP E.D.E.N.</div>
        <div id="subtitle">Tap to toggle layers • Drag globe to rotate • Pinch to zoom</div>
      </div>
    </div>

    <div class="row">
      <button class="pill on" data-key="axisLines"><span class="dot"></span>Axis Lines</button>
      <button class="pill" data-key="lineNames"><span class="dot"></span>Line Names</button>
      <button class="pill" data-key="continents"><span class="dot"></span>Continents</button>
    </div>

    <div class="row">
      <button class="pill on" data-key="stations"><span class="dot"></span>Stations</button>
      <button class="pill" data-key="corridors"><span class="dot"></span>Corridors</button>
      <button class="pill" data-key="perpendiculars"><span class="dot"></span>Perpendiculars</button>
    </div>

    <div class="row">
      <button class="pill" data-key="magField"><span class="dot"></span>Magnetic Field</button>
      <button class="pill" data-key="aurora"><span class="dot"></span>Aurora</button>
    </div>

    <div id="statusLine">
      <span id="status">Booting…</span>
      <span id="hint">Tip: With Stations ON, tap globe to drop a Future Station (saved).</span>
    </div>

    <div id="errors"></div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

    // ---------------- HUD error capture ----------------
    const statusEl = document.getElementById("status");
    const errorsEl = document.getElementById("errors");
    function setStatus(msg){ statusEl.textContent = msg; }
    function showError(msg){
      errorsEl.style.display = "block";
      errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
      setStatus("Error (see panel)");
    }
    window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
    window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

    // ---------------- Drawer open/close ----------------
    const drawerEl = document.getElementById("drawer");
    const drawerToggleBtn = document.getElementById("drawerToggle");
    const PANEL_KEY = "eden_layers_panel_v1";

    function setPanel(open){
      drawerEl.classList.toggle("open", open);
      drawerEl.classList.toggle("closed", !open);
      localStorage.setItem(PANEL_KEY, open ? "open" : "closed");
      drawerToggleBtn.querySelector(".chev").textContent = open ? "×" : "≡";
      drawerToggleBtn.querySelector(".lbl").textContent = open ? "Close" : "Layers";
    }
    const savedPanelState = localStorage.getItem(PANEL_KEY);
    setPanel(savedPanelState !== "closed");
    drawerToggleBtn.addEventListener("click", () => setPanel(!drawerEl.classList.contains("open")));

    // ---------------- Math helpers ----------------
    const DEG = Math.PI / 180;
    const RAD = 180 / Math.PI;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const wrapLonRad = (lon)=> {
      lon = (lon + Math.PI) % (Math.PI*2);
      if (lon < 0) lon += Math.PI*2;
      return lon - Math.PI;
    };

    function latLonToVec3(latDeg, lonDeg, r=1){
      const lat = latDeg * DEG;
      const lon = lonDeg * DEG;
      const x = Math.cos(lat) * Math.cos(lon);
      const y = Math.sin(lat);
      const z = Math.cos(lat) * Math.sin(lon);
      return new THREE.Vector3(x*r, y*r, z*r);
    }

    function vec3ToLatLon(v){
      const n = v.clone().normalize();
      const lat = Math.asin(clamp(n.y, -1, 1));
      const lon = Math.atan2(n.z, n.x);
      return { latDeg: lat*RAD, lonDeg: lon*RAD };
    }

    // Great-circle points from start + initial bearing
    function greatCirclePoints(lat1Deg, lon1Deg, bearingDeg, steps=720){
      const lat1 = lat1Deg*DEG, lon1 = lon1Deg*DEG, brng = bearingDeg*DEG;
      const pts = [];
      for (let i=0; i<=steps; i++){
        const t = (i/steps)*2*Math.PI - Math.PI; // -π..+π
        const δ = t;
        const sinLat2 = Math.sin(lat1)*Math.cos(δ) + Math.cos(lat1)*Math.sin(δ)*Math.cos(brng);
        const lat2 = Math.asin(clamp(sinLat2,-1,1));
        const y = Math.sin(brng)*Math.sin(δ)*Math.cos(lat1);
        const x = Math.cos(δ) - Math.sin(lat1)*Math.sin(lat2);
        const lon2 = wrapLonRad(lon1 + Math.atan2(y, x));
        pts.push({lat: lat2, lon: lon2});
      }
      return pts;
    }

    // Rhumb (loxodrome) stepping (stable for visualization)
    function rhumbPoints(lat1Deg, lon1Deg, bearingDeg, steps=900){
      const brng = bearingDeg*DEG;
      let φ = lat1Deg*DEG;
      let λ = lon1Deg*DEG;

      const outForward = [];
      const outBackward = [];

      const total = 2*Math.PI; // ~ full wrap
      const step = total/steps;

      const march = (dir, out) => {
        let φc = φ, λc = λ;
        const s = step * dir;
        for (let i=0;i<=steps;i++){
          // record
          out.push({lat: φc, lon: wrapLonRad(λc)});
          // step
          let φ2 = φc + s*Math.cos(brng);
          φ2 = clamp(φ2, -Math.PI/2 + 1e-4, Math.PI/2 - 1e-4);
          const ψ1 = Math.log(Math.tan(Math.PI/4 + φc/2));
          const ψ2 = Math.log(Math.tan(Math.PI/4 + φ2/2));
          const dψ = (ψ2 - ψ1);
          const dφ = (φ2 - φc);
          const q = Math.abs(dψ) > 1e-12 ? (dφ/dψ) : Math.cos(φc);
          const dλ = (s*Math.sin(brng))/q;
          φc = φ2;
          λc = λc + dλ;
        }
      };

      march(+1, outForward);
      march(-1, outBackward);

      outBackward.reverse();
      // merge, removing duplicate center
      return outBackward.concat(outForward.slice(1));
    }

    function makeTextSprite(text, {
      fontSize=42,
      padding=18,
      fontWeight=800,
      color="rgba(255,255,255,0.92)",
      bg="rgba(0,0,0,0.0)",
      stroke="rgba(0,0,0,0.55)",
      strokeWidth=6,
      scale=0.45
    }={}){
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      ctx.font = `${fontWeight} ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
      const metrics = ctx.measureText(text);
      const w = Math.ceil(metrics.width + padding*2);
      const h = Math.ceil(fontSize + padding*2);

      canvas.width = w;
      canvas.height = h;

      ctx.clearRect(0,0,w,h);
      if (bg !== "rgba(0,0,0,0.0)"){
        ctx.fillStyle = bg;
        ctx.fillRect(0,0,w,h);
      }

      ctx.font = `${fontWeight} ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";

      // stroke for readability
      ctx.lineJoin = "round";
      ctx.lineWidth = strokeWidth;
      ctx.strokeStyle = stroke;
      ctx.strokeText(text, w/2, h/2);

      ctx.fillStyle = color;
      ctx.fillText(text, w/2, h/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.needsUpdate = true;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const spr = new THREE.Sprite(mat);
      spr.scale.set((w/h)*scale, 1*scale, 1);
      return spr;
    }

    // ---------------- Main async boot ----------------
    (async () => {
      try {
        setStatus("Loading…");

        // Scene / Camera / Renderer
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
        let camDist = 4.2;
        camera.position.set(0, 0, camDist);

        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.10));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
        sunLight.position.set(5, 1.5, 2.5);
        scene.add(sunLight);

        // Loading manager
        const manager = new THREE.LoadingManager();
        manager.onStart = () => setStatus("Loading textures…");
        manager.onProgress = (_url, loaded, total) => setStatus(`Loading textures… (${loaded}/${total})`);
        manager.onError = (url) => showError("Texture failed to load:\n" + url);

        const loader = new THREE.TextureLoader(manager);
        loader.setCrossOrigin("anonymous");

        const CDNS = [
          "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/",
          "https://unpkg.com/three@0.161.0/examples/textures/"
        ];
        const TEX_PATHS = {
          day:    "planets/earth_atmos_2048.jpg",
          night:  "planets/earth_lights_2048.png",
          spec:   "planets/earth_specular_2048.jpg",
          clouds: "planets/earth_clouds_1024.png",
          stars:  "galaxy_starfield.png"
        };

        const loadWithFallback = (path) => new Promise((resolve, reject) => {
          let i = 0;
          const tryNext = () => {
            const url = CDNS[i] + path;
            loader.load(
              url,
              (tex) => resolve(tex),
              undefined,
              () => {
                i++;
                if (i < CDNS.length) tryNext();
                else reject(new Error("All CDNs failed: " + path));
              }
            );
          };
          tryNext();
        });

        const [dayMap, nightMap, specMap, cloudMap, starMap] = await Promise.all([
          loadWithFallback(TEX_PATHS.day),
          loadWithFallback(TEX_PATHS.night),
          loadWithFallback(TEX_PATHS.spec),
          loadWithFallback(TEX_PATHS.clouds),
          loadWithFallback(TEX_PATHS.stars)
        ]);

        dayMap.colorSpace   = THREE.SRGBColorSpace;
        nightMap.colorSpace = THREE.SRGBColorSpace;
        specMap.colorSpace  = THREE.SRGBColorSpace;
        cloudMap.colorSpace = THREE.SRGBColorSpace;
        starMap.colorSpace  = THREE.SRGBColorSpace;

        const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
        [dayMap, nightMap, specMap, cloudMap, starMap].forEach((t) => {
          t.anisotropy = maxAniso;
          t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
        });

        // Stars
        {
          const starGeo = new THREE.SphereGeometry(90, 64, 64);
          const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
          scene.add(new THREE.Mesh(starGeo, starMat));
        }

        // Globe
        const earthRadius = 1.0;
        const SEG = 96;

        const earthUniforms = {
          dayMap:    { value: dayMap },
          specMap:   { value: specMap },
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const earthMat = new THREE.ShaderMaterial({
          uniforms: earthUniforms,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vUv = uv;
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform sampler2D dayMap;
            uniform sampler2D specMap;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
              float specMask = texture2D(specMap, vUv).r;

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);

              // Slightly brighter night base so continents read better
              vec3 nightBase = dayCol * 0.13;
              vec3 col = mix(nightBase, dayCol, dayAmt);

              vec3 H = normalize(L + V);
              float spec = pow(max(dot(N, H), 0.0), 80.0) * specMask * 0.55 * dayAmt;
              col += vec3(spec);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
              col += vec3(0.08, 0.14, 0.22) * rim * (0.35 + 0.65 * dayAmt);

              gl_FragColor = vec4(linearToSrgb(col), 1.0);
            }
          `
        });

        const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);
        scene.add(earth);

        // Night lights (bloom target)
        const lightsUniforms = {
          nightMap: { value: nightMap },
          sunDir:   { value: new THREE.Vector3(1,0,0) },
          gain:     { value: 2.6 }
        };

        const nightLights = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: lightsUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexShader: `
              varying vec2 vUv;
              varying vec3 vNormalW;
              void main(){
                vUv = uv;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform sampler2D nightMap;
              uniform vec3 sunDir;
              uniform float gain;
              varying vec2 vUv;
              varying vec3 vNormalW;

              vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
              vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);

                float ndl = dot(N, L);
                float dayAmt = smoothstep(-0.05, 0.15, ndl);
                float nightAmt = 1.0 - dayAmt;

                vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
                float mask = smoothstep(0.05, 0.35, nightAmt);

                vec3 col = lights * mask;
                float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
                gl_FragColor = vec4(linearToSrgb(col), a);
              }
            `
          })
        );
        scene.add(nightLights);

        // Cloud shadow layer (multiply)
        const cloudShadow = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
          new THREE.MeshBasicMaterial({
            map: cloudMap,
            color: 0x000000,
            transparent: true,
            opacity: 0.26,
            blending: THREE.MultiplyBlending,
            depthWrite: false
          })
        );
        scene.add(cloudShadow);

        // Clouds (visible)
        const clouds = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
          new THREE.MeshLambertMaterial({
            map: cloudMap,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
          })
        );
        scene.add(clouds);

        // Atmosphere (bloom target)
        const atmoUniforms = {
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const atmosphere = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: atmoUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            vertexShader: `
              varying vec3 vNormalW;
              varying vec3 vPosW;
              void main(){
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vPosW = worldPos.xyz;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * worldPos;
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform vec3 sunDir;
              uniform vec3 cameraPos;
              varying vec3 vNormalW;
              varying vec3 vPosW;

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);
                vec3 V = normalize(cameraPos - vPosW);

                float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
                float daySide = smoothstep(-0.15, 0.25, dot(N, L));

                vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
                float alpha = rim * (0.18 + 0.62 * daySide);
                gl_FragColor = vec4(col, alpha);
              }
            `
          })
        );
        scene.add(atmosphere);

        // Rotation group
        const globe = new THREE.Group();
        scene.remove(earth, nightLights, cloudShadow, clouds, atmosphere);
        globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
        scene.add(globe);

        // ---------------- Selective Bloom ----------------
        const BLOOM_LAYER = 1;
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_LAYER);

        nightLights.layers.enable(BLOOM_LAYER);
        atmosphere.layers.enable(BLOOM_LAYER);

        const darkMaterial = new THREE.MeshBasicMaterial({ color:"black" });
        const materials = new Map();

        function darkenNonBloom(obj){
          if (obj.isMesh && !bloomLayer.test(obj.layers)){
            materials.set(obj.uuid, obj.material);
            obj.material = darkMaterial;
          }
        }
        function restoreMaterial(obj){
          if (materials.has(obj.uuid)){
            obj.material = materials.get(obj.uuid);
            materials.delete(obj.uuid);
          }
        }

        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(innerWidth, innerHeight),
          1.18,
          0.85,
          0.12
        );

        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        const finalPass = new ShaderPass({
          uniforms: { tDiffuse:{ value:null }, bloomTexture:{ value:null } },
          vertexShader: `
            varying vec2 vUv;
            void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
          `,
          fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main(){
              vec4 base = texture2D(tDiffuse, vUv);
              vec4 bloom = texture2D(bloomTexture, vUv);
              gl_FragColor = base + bloom;
            }
          `
        });

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(finalPass);
        finalComposer.addPass(new OutputPass());

        function renderBloom(){
          scene.traverse(darkenNonBloom);
          bloomComposer.render();
          finalPass.uniforms.bloomTexture.value = bloomComposer.readBuffer.texture;
          scene.traverse(restoreMaterial);
        }

        // ---------------- Layers groups ----------------
        const axisGroup = new THREE.Group();
        const corridorGroup = new THREE.Group();
        const perpGroup = new THREE.Group();
        const lineLabelGroup = new THREE.Group();
        const continentGroup = new THREE.Group();
        const stationGroup = new THREE.Group();
        const magGroup = new THREE.Group();
        const auroraGroup = new THREE.Group();

        globe.add(axisGroup, corridorGroup, perpGroup, lineLabelGroup, continentGroup, stationGroup, magGroup, auroraGroup);

        // ---------------- Anchor ----------------
        // Staunton VA anchor (from prior log): 38.160833, -79.073056
        const anchor = { lat: 38.160833, lon: -79.073056 };

        // Axis definitions
        // 222° direction is the "Hidden Spine" direction from anchor; the axis is bidirectional along the same path.
        const BEARING_AXIS = 222;
        const BEARING_PERP_A = (BEARING_AXIS + 90) % 360;  // 312
        const BEARING_PERP_B = (BEARING_AXIS + 270) % 360; // 132

        // ---------------- Axis lines (Rhumb gold, Geodesic blue) ----------------
        function makeTubeFromLatLonPoints(points, radius, color, opacity=1.0, bloom=true){
          const curvePts = points.map(p => {
            const v = new THREE.Vector3(
              Math.cos(p.lat)*Math.cos(p.lon),
              Math.sin(p.lat),
              Math.cos(p.lat)*Math.sin(p.lon)
            ).multiplyScalar(earthRadius*1.003);
            return v;
          });
          const curve = new THREE.CatmullRomCurve3(curvePts);
          const tube = new THREE.TubeGeometry(curve, Math.max(300, curvePts.length), radius, 10, false);
          const mat = new THREE.MeshBasicMaterial({ color, transparent: opacity < 1, opacity });
          const mesh = new THREE.Mesh(tube, mat);
          if (bloom) mesh.layers.enable(BLOOM_LAYER);
          return mesh;
        }

        // Rhumb (Gold)
        const rhumbPts = rhumbPoints(anchor.lat, anchor.lon, BEARING_AXIS, 900);
        const rhumbMesh = makeTubeFromLatLonPoints(rhumbPts, 0.006, 0xD6B14A, 1.0, true);
        axisGroup.add(rhumbMesh);

        // Geodesic (Blue)
        const geoPts = greatCirclePoints(anchor.lat, anchor.lon, BEARING_AXIS, 720);
        const geoMesh = makeTubeFromLatLonPoints(geoPts, 0.005, 0x4CA8FF, 1.0, true);
        axisGroup.add(geoMesh);

        // ---------------- Corridors (visual tubes) ----------------
        function addCorridors(points, baseColor){
          // 3 corridor widths (visual): small/med/large
          const c1 = makeTubeFromLatLonPoints(points, 0.010, baseColor, 0.18, false);
          const c2 = makeTubeFromLatLonPoints(points, 0.018, baseColor, 0.12, false);
          const c3 = makeTubeFromLatLonPoints(points, 0.028, baseColor, 0.08, false);
          corridorGroup.add(c1,c2,c3);
        }
        addCorridors(rhumbPts, 0xD6B14A);
        addCorridors(geoPts,   0x4CA8FF);

        // ---------------- Perpendiculars (two great circles) ----------------
        const perpA = greatCirclePoints(anchor.lat, anchor.lon, BEARING_PERP_A, 720);
        const perpB = greatCirclePoints(anchor.lat, anchor.lon, BEARING_PERP_B, 720);

        const perpMeshA = makeTubeFromLatLonPoints(perpA, 0.004, 0xA9FFE8, 0.95, true);
        const perpMeshB = makeTubeFromLatLonPoints(perpB, 0.004, 0xA9FFE8, 0.95, true);
        perpGroup.add(perpMeshA, perpMeshB);

        // ---------------- Line labels ----------------
        const labelRhumb = makeTextSprite("Rhumb (True) · 222°", { scale: 0.42 });
        labelRhumb.position.copy(latLonToVec3(18, -40, earthRadius*1.11));
        lineLabelGroup.add(labelRhumb);

        const labelGeo = makeTextSprite("Geodesic (WGS84) · 222°", { scale: 0.42 });
        labelGeo.position.copy(latLonToVec3(-8, -10, earthRadius*1.11));
        lineLabelGroup.add(labelGeo);

        const labelPerp = makeTextSprite("Perpendicular Controls · 132° / 312°", { scale: 0.44 });
        labelPerp.position.copy(latLonToVec3(42, 30, earthRadius*1.12));
        lineLabelGroup.add(labelPerp);

        // ---------------- Continents labels ----------------
        const continents = [
          { name:"North America", lat: 45, lon: -100 },
          { name:"South America", lat: -15, lon: -60 },
          { name:"Europe",        lat: 52, lon:  15 },
          { name:"Africa",        lat:  5, lon:  20 },
          { name:"Asia",          lat: 35, lon: 100 },
          { name:"Australia",     lat: -25, lon: 135 },
          { name:"Antarctica",    lat: -75, lon:   0 }
        ];

        for (const c of continents){
          const spr = makeTextSprite(c.name, { fontSize: 40, scale: 0.48, strokeWidth: 7 });
          spr.position.copy(latLonToVec3(c.lat, c.lon, earthRadius*1.10));
          continentGroup.add(spr);
        }

        // ---------------- Stations ----------------
        const STATION_KEY = "eden_future_stations_v1";

        function makeStationMarker(name, lat, lon, color=0xFFFFFF){
          const grp = new THREE.Group();

          const marker = new THREE.Mesh(
            new THREE.SphereGeometry(0.018, 18, 18),
            new THREE.MeshBasicMaterial({ color })
          );
          marker.layers.enable(BLOOM_LAYER);
          marker.position.copy(latLonToVec3(lat, lon, earthRadius*1.020));
          grp.add(marker);

          const label = makeTextSprite(name, { fontSize: 38, scale: 0.40, strokeWidth: 7 });
          label.position.copy(latLonToVec3(lat, lon, earthRadius*1.085));
          grp.add(label);

          return grp;
        }

        // Default anchor station
        stationGroup.add(makeStationMarker("Exit 222 · Staunton VA", anchor.lat, anchor.lon, 0xFFFFFF));

        function loadFutureStations(){
          try {
            const raw = localStorage.getItem(STATION_KEY);
            if (!raw) return [];
            const list = JSON.parse(raw);
            if (!Array.isArray(list)) return [];
            return list.filter(s => typeof s.lat === "number" && typeof s.lon === "number" && typeof s.name === "string");
          } catch { return []; }
        }
        function saveFutureStations(list){
          localStorage.setItem(STATION_KEY, JSON.stringify(list));
        }

        const futureStations = loadFutureStations();
        for (const st of futureStations){
          stationGroup.add(makeStationMarker(st.name, st.lat, st.lon, 0xB8D7FF));
        }

        // Tap to add station (raycast)
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function screenToNDC(x,y){
          pointer.x = (x / innerWidth) * 2 - 1;
          pointer.y = -(y / innerHeight) * 2 + 1;
        }

        let pressStart = 0;
        let pressMoved = 0;
        let pressX = 0, pressY = 0;

        function addFutureStationAtIntersect(intersectPoint){
          const { latDeg, lonDeg } = vec3ToLatLon(intersectPoint);
          const list = loadFutureStations();
          const n = list.length + 1;
          const name = `Future Station ${n}`;
          const entry = { name, lat: +latDeg.toFixed(4), lon: +lonDeg.toFixed(4) };
          list.push(entry);
          saveFutureStations(list);

          stationGroup.add(makeStationMarker(name, entry.lat, entry.lon, 0xB8D7FF));
          setStatus(`Saved ${name} @ ${entry.lat}, ${entry.lon}`);
        }

        // ---------------- Magnetic Field (v1 dipole-style lines) ----------------
        function buildMagFieldV1(){
          magGroup.clear();
          const mat = new THREE.LineBasicMaterial({ color: 0x66D0FF, transparent:true, opacity: 0.38 });

          // Create a set of meridian-plane dipole lines, rotate around Y
          const linesCount = 12;
          const Lshells = [1.2, 1.4, 1.7, 2.2, 3.0];
          for (let i=0; i<linesCount; i++){
            const rot = (i/linesCount) * Math.PI * 2;
            for (const L of Lshells){
              const pts = [];
              // theta from near pole to near pole
              for (let t=0; t<=140; t++){
                const θ = (t/140) * Math.PI - Math.PI/2; // -90..+90
                // dipole: r = L * cos^2(theta)
                const r = L * Math.cos(θ) * Math.cos(θ);
                const x = r * Math.cos(θ);
                const y = r * Math.sin(θ);
                const v = new THREE.Vector3(x, y, 0);
                v.applyAxisAngle(new THREE.Vector3(0,1,0), rot);
                v.multiplyScalar(earthRadius*0.70); // scale down to wrap nicely around earth
                pts.push(v);
              }
              const geo = new THREE.BufferGeometry().setFromPoints(pts);
              const line = new THREE.Line(geo, mat);
              line.layers.enable(BLOOM_LAYER);
              magGroup.add(line);
            }
          }
        }
        buildMagFieldV1();

        // ---------------- Aurora (v1 polar rings) ----------------
        function buildAuroraV1(){
          auroraGroup.clear();
          const ringMat = new THREE.MeshBasicMaterial({
            color: 0x7CFFB9,
            transparent: true,
            opacity: 0.14,
            blending: THREE.AdditiveBlending,
            depthWrite: false
          });

          function ringAtLat(latDeg){
            const φ = latDeg*DEG;
            const y = Math.sin(φ) * earthRadius * 1.01;
            const R = Math.cos(φ) * earthRadius * 1.03;
            const geo = new THREE.TorusGeometry(R, 0.035, 10, 96);
            const m = ringMat.clone();
            const mesh = new THREE.Mesh(geo, m);
            mesh.rotation.x = Math.PI/2;
            mesh.position.y = y;
            mesh.layers.enable(BLOOM_LAYER);
            return mesh;
          }

          const north = ringAtLat(70);
          const south = ringAtLat(-70);
          auroraGroup.add(north, south);

          // Soft glow cap
          const capMat = new THREE.MeshBasicMaterial({
            color: 0x4CA8FF,
            transparent: true,
            opacity: 0.07,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
          });
          const capGeo = new THREE.CircleGeometry(0.42, 64);
          const capN = new THREE.Mesh(capGeo, capMat.clone());
          capN.position.y = earthRadius*0.92;
          capN.rotation.x = -Math.PI/2;

          const capS = new THREE.Mesh(capGeo, capMat.clone());
          capS.position.y = -earthRadius*0.92;
          capS.rotation.x = Math.PI/2;

          capN.layers.enable(BLOOM_LAYER);
          capS.layers.enable(BLOOM_LAYER);
          auroraGroup.add(capN, capS);

          return { north, south };
        }
        const auroraMeshes = buildAuroraV1();

        // ---------------- Default layer state ----------------
        const state = {
          axisLines: true,
          lineNames: false,
          continents: false,
          stations: true,
          corridors: false,
          perpendiculars: false,
          magField: false,
          aurora: false
        };

        function applyState(){
          axisGroup.visible = state.axisLines;
          corridorGroup.visible = state.corridors;
          perpGroup.visible = state.perpendiculars;
          lineLabelGroup.visible = state.lineNames;
          continentGroup.visible = state.continents;
          stationGroup.visible = state.stations;
          magGroup.visible = state.magField;
          auroraGroup.visible = state.aurora;

          document.querySelectorAll(".pill").forEach(btn=>{
            const key = btn.getAttribute("data-key");
            if (!key) return;
            btn.classList.toggle("on", !!state[key]);
          });
        }
        applyState();

        // Buttons
        document.querySelectorAll(".pill").forEach(btn=>{
          btn.addEventListener("click", ()=>{
            const key = btn.getAttribute("data-key");
            state[key] = !state[key];
            applyState();
          });
        });

        // ---------------- Touch rotate + inertia ----------------
        let dragging=false, lastX=0, lastY=0, velY=0, velX=0;
        const AUTO_SPIN=0.00115, DRAG_SENS=0.0065, PITCH_SENS=0.0048, DAMPING=0.92, MAX_PITCH=0.55;

        function getPoint(e){
          if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
          return { x:e.clientX, y:e.clientY };
        }

        // Pinch zoom
        let pinchActive = false;
        let pinchStartDist = 0;
        let pinchStartCam = camDist;

        function touchDist(t1, t2){
          const dx = t1.clientX - t2.clientX;
          const dy = t1.clientY - t2.clientY;
          return Math.sqrt(dx*dx + dy*dy);
        }

        function down(e){
          pressStart = performance.now();
          pressMoved = 0;
          const p = getPoint(e);
          pressX = p.x; pressY = p.y;

          if (e.touches && e.touches.length === 2){
            pinchActive = true;
            pinchStartDist = touchDist(e.touches[0], e.touches[1]);
            pinchStartCam = camDist;
            return;
          }

          dragging=true;
          lastX=p.x; lastY=p.y;
        }

        function move(e){
          // pinch
          if (e.touches && e.touches.length === 2){
            pinchActive = true;
            const d = touchDist(e.touches[0], e.touches[1]);
            const factor = pinchStartDist / Math.max(20, d);
            camDist = clamp(pinchStartCam * factor, 2.6, 10.0);
            camera.position.set(0, 0, camDist);
            return;
          }

          if(!dragging) return;
          const p=getPoint(e);
          const dx=p.x-lastX, dy=p.y-lastY;
          lastX=p.x; lastY=p.y;

          pressMoved += Math.abs(dx) + Math.abs(dy);

          globe.rotation.y += dx*DRAG_SENS;
          globe.rotation.x += dy*PITCH_SENS;
          globe.rotation.x = clamp(globe.rotation.x, -MAX_PITCH, MAX_PITCH);

          velY = dx*DRAG_SENS;
          velX = dy*PITCH_SENS;
        }

        function up(e){
          dragging=false;

          // if quick tap with minimal movement, allow station drop
          const dt = performance.now() - pressStart;
          const isTap = dt < 320 && pressMoved < 14;

          pinchActive = false;

          if (isTap && state.stations){
            const p = getPoint(e);
            screenToNDC(p.x, p.y);
            raycaster.setFromCamera(pointer, camera);
            const hit = raycaster.intersectObject(earth, false)[0];
            if (hit && hit.point){
              addFutureStationAtIntersect(hit.point.clone().normalize().multiplyScalar(earthRadius));
            }
          }
        }

        const el = renderer.domElement;
        el.addEventListener("touchstart", down, { passive:true });
        el.addEventListener("touchmove", move, { passive:true });
        el.addEventListener("touchend", up, { passive:true });

        el.addEventListener("mousedown", (e)=>down(e));
        window.addEventListener("mousemove", (e)=>move(e));
        window.addEventListener("mouseup", (e)=>up(e));

        // wheel zoom for desktop
        window.addEventListener("wheel", (e)=>{
          camDist = clamp(camDist + Math.sign(e.deltaY)*0.20, 2.6, 10.0);
          camera.position.set(0,0,camDist);
        }, { passive:true });

        // ---------------- Animation ----------------
        setStatus("Running");

        const sunDrift = 0.00005;
        const cloudSpin = 0.0020;

        function animate(){
          requestAnimationFrame(animate);

          clouds.rotation.y += cloudSpin;
          cloudShadow.rotation.y += cloudSpin + 0.00015;

          if(!dragging && !pinchActive){
            globe.rotation.y += AUTO_SPIN;
            globe.rotation.y += velY;
            globe.rotation.x += velX;
            velY *= DAMPING;
            velX *= DAMPING;
            globe.rotation.x = clamp(globe.rotation.x, -MAX_PITCH, MAX_PITCH);
          }

          // Aurora pulse
          if (auroraMeshes){
            const t = performance.now()*0.001;
            const pulse = 0.10 + 0.06*Math.sin(t*1.25);
            auroraGroup.traverse(obj=>{
              if (obj.material && obj.material.transparent){
                obj.material.opacity = obj.material.opacity; // keep
              }
            });
            // tweak ring opacity slightly
            auroraMeshes.north.material.opacity = pulse;
            auroraMeshes.south.material.opacity = pulse;
          }

          sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
          const sunDir = sunLight.position.clone().normalize();

          earthUniforms.sunDir.value.copy(sunDir);
          earthUniforms.cameraPos.value.copy(camera.position);

          lightsUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.cameraPos.value.copy(camera.position);

          renderBloom();
          finalComposer.render();
        }
        animate();

        // Resize
        addEventListener("resize", () => {
          camera.aspect = innerWidth/innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);

          bloomComposer.setSize(innerWidth, innerHeight);
          finalComposer.setSize(innerWidth, innerHeight);
          bloomPass.setSize(innerWidth, innerHeight);
        });

      } catch (err) {
        showError("Top-level error:\n" + (err?.stack || err?.message || err));
      }
    })();
  </script>
</body>
</html>
