<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>MAP E.D.E.N. Globe</title>

    <style>
      :root{
        --glass: rgba(12,14,18,0.58);
        --glass2: rgba(12,14,18,0.42);
        --stroke: rgba(255,255,255,0.12);
        --text: rgba(255,255,255,0.92);
        --muted: rgba(255,255,255,0.68);
        --muted2: rgba(255,255,255,0.45);
        --gold: #f6c24a;
        --blue: #5bbcff;
      }

      html, body { height: 100%; margin: 0; background:#000; overflow:hidden; touch-action:none; }
      canvas { display:block; width:100vw !important; height:100vh !important; }

      /* ---------- Bottom Drawer (matches your screenshot vibe) ---------- */
      #drawer {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        bottom: 18px;
        width: min(720px, calc(100vw - 28px));
        z-index: 9999;
        color: var(--text);
        background: var(--glass);
        border: 1px solid var(--stroke);
        border-radius: 22px;
        padding: 14px 14px 16px;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 14px 44px rgba(0,0,0,0.42);
        user-select: none;
      }

      #drawerTop{
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:12px;
      }

      #titleBlock{
        display:flex;
        flex-direction:column;
        gap:4px;
      }

      #title {
        font: 700 18px/1.1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        letter-spacing: 0.2px;
      }
      #subtitle{
        font: 500 12px/1.25 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        color: var(--muted);
      }

      #handle {
        width: 44px;
        height: 6px;
        border-radius: 999px;
        background: rgba(255,255,255,0.18);
        margin: 6px auto 10px;
      }

      #rowWrap {
        display:flex;
        flex-direction:column;
        gap:10px;
        margin-top: 10px;
      }

      .row {
        display:flex;
        flex-wrap:wrap;
        gap:10px;
      }

      .pill {
        display:inline-flex;
        align-items:center;
        gap:10px;
        padding: 12px 14px;
        border-radius: 18px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(255,255,255,0.06);
        color: var(--text);
        font: 700 14px/1 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        letter-spacing: 0.15px;
        cursor:pointer;
        -webkit-tap-highlight-color: transparent;
      }
      .pill:active { transform: translateY(1px); }

      .dot {
        width: 10px; height: 10px;
        border-radius: 50%;
        background: rgba(255,255,255,0.18);
        box-shadow: 0 0 0 rgba(0,0,0,0);
      }

      .pill.on .dot {
        background: rgba(120,255,200,0.88);
        box-shadow: 0 0 18px rgba(120,255,200,0.35);
      }

      /* color hint for axis lines when enabled */
      .pill.on[data-key="axisLines"] .dot{ background: rgba(246,194,74,0.95); box-shadow:0 0 18px rgba(246,194,74,0.35); }
      .pill.on[data-key="corridors"] .dot{ background: rgba(246,194,74,0.65); box-shadow:0 0 18px rgba(246,194,74,0.24); }
      .pill.on[data-key="perpendiculars"] .dot{ background: rgba(91,188,255,0.90); box-shadow:0 0 18px rgba(91,188,255,0.30); }
      .pill.on[data-key="aurora"] .dot{ background: rgba(160,120,255,0.90); box-shadow:0 0 18px rgba(160,120,255,0.30); }
      .pill.on[data-key="magField"] .dot{ background: rgba(91,188,255,0.75); box-shadow:0 0 18px rgba(91,188,255,0.22); }

      #statusLine{
        margin-top:10px;
        color: var(--muted2);
        font: 600 11px/1.2 -apple-system, system-ui, Segoe UI, Roboto, Arial;
        display:flex;
        justify-content:space-between;
        gap:12px;
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }

      #errors{
        margin-top: 10px;
        display:none;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(255,120,120,0.22);
        background: rgba(80,10,10,0.35);
        color: rgba(255,170,170,0.95);
        font: 600 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        white-space: pre-wrap;
      }

      /* collapsed state */
      #drawer.collapsed #rowWrap,
      #drawer.collapsed #statusLine,
      #drawer.collapsed #errors { display:none; }
      #drawer.collapsed { padding-bottom: 12px; }

      @media (max-width: 420px){
        .pill { padding: 12px 12px; border-radius: 16px; font-size: 13px; }
      }
    </style>

    <!-- ✅ Import Map so 'three' + 'three/addons/' resolve on GitHub Pages -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <div id="drawer">
      <div id="handle" title="Tap to collapse/expand"></div>

      <div id="drawerTop">
        <div id="titleBlock">
          <div id="title">MAP E.D.E.N.</div>
          <div id="subtitle">Tap to toggle layers • Drag globe to rotate • Pinch to zoom</div>
        </div>
      </div>

      <div id="rowWrap">
        <div class="row">
          <button class="pill on" data-key="axisLines"><span class="dot"></span>Axis Lines</button>
          <button class="pill" data-key="lineNames"><span class="dot"></span>Line Names</button>
          <button class="pill" data-key="continents"><span class="dot"></span>Continents</button>
        </div>

        <div class="row">
          <button class="pill on" data-key="stations"><span class="dot"></span>Stations</button>
          <button class="pill" data-key="corridors"><span class="dot"></span>Corridors</button>
          <button class="pill" data-key="perpendiculars"><span class="dot"></span>Perpendiculars</button>
        </div>

        <div class="row">
          <button class="pill" data-key="magField"><span class="dot"></span>Magnetic Field</button>
          <button class="pill" data-key="aurora"><span class="dot"></span>Aurora</button>
        </div>

        <div id="statusLine">
          <span id="status">Booting…</span>
          <span id="hint">Tip: With Stations ON, tap globe to drop a Future Station (saved).</span>
        </div>

        <div id="errors"></div>
      </div>
    </div>

    <script type="module">
      // ---------- Error capture (so iPhone shows why it's dark if something breaks) ----------
      const statusEl = document.getElementById("status");
      const errorsEl = document.getElementById("errors");
      const drawerEl = document.getElementById("drawer");

      function showError(msg){
        errorsEl.style.display = "block";
        errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
        statusEl.textContent = "Error (see panel)";
      }
      window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
      window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

      // Drawer collapse/expand
      const handle = document.getElementById("handle");
      handle.addEventListener("click", () => drawerEl.classList.toggle("collapsed"));

      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // ---------- Helpers ----------
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const DEG = Math.PI / 180;
      const RAD = 180 / Math.PI;

      function latLonToVec3(latDeg, lonDeg, radius=1.0){
        const lat = latDeg * DEG;
        const lon = lonDeg * DEG;
        const x = radius * Math.cos(lat) * Math.cos(lon);
        const y = radius * Math.sin(lat);
        const z = radius * Math.cos(lat) * Math.sin(lon);
        return new THREE.Vector3(x,y,z);
      }

      function vec3ToLatLon(v){
        const r = v.length();
        const lat = Math.asin(v.y / r) * RAD;
        const lon = Math.atan2(v.z, v.x) * RAD;
        return { lat, lon };
      }

      // Great-circle points from start + bearing
      function greatCirclePoints(lat0Deg, lon0Deg, bearingDeg, stepDeg=1.0){
        const lat0 = lat0Deg * DEG;
        const lon0 = lon0Deg * DEG;
        const brng = bearingDeg * DEG;

        const pts = [];
        for(let d=-180; d<=180; d+=stepDeg){
          const δ = d * DEG; // angular distance
          const sinLat = Math.sin(lat0)*Math.cos(δ) + Math.cos(lat0)*Math.sin(δ)*Math.cos(brng);
          const lat = Math.asin(clamp(sinLat, -1, 1));
          const y = Math.sin(brng)*Math.sin(δ)*Math.cos(lat0);
          const x = Math.cos(δ) - Math.sin(lat0)*Math.sin(lat);
          const lon = lon0 + Math.atan2(y, x);
          pts.push({ lat: lat*RAD, lon: ((lon*RAD + 540) % 360) - 180 });
        }
        return pts;
      }

      // Rhumb-line points (constant bearing) along sphere
      function rhumbPoints(lat0Deg, lon0Deg, bearingDeg, stepKm=250){
        const R = 6371; // km
        const φ1 = lat0Deg * DEG;
        const λ1 = lon0Deg * DEG;
        const θ = bearingDeg * DEG;

        const pts = [];
        // walk both directions from anchor to cover planet
        const maxSteps = 120; // ~ 30,000 km @ 250km
        for (const dir of [-1, +1]){
          let φ = φ1, λ = λ1;
          for (let i=0; i<maxSteps; i++){
            const d = dir * (stepKm / R); // radians
            const Δφ = d * Math.cos(θ);
            let φ2 = φ + Δφ;
            // clamp near poles
            φ2 = clamp(φ2, -Math.PI/2 + 1e-6, Math.PI/2 - 1e-6);

            const Δψ = Math.log(Math.tan(Math.PI/4 + φ2/2) / Math.tan(Math.PI/4 + φ/2));
            const q = Math.abs(Δψ) > 1e-12 ? (Δφ / Δψ) : Math.cos(φ);

            const Δλ = d * Math.sin(θ) / q;
            let λ2 = λ + Δλ;

            // normalize lon
            λ2 = ((λ2 + Math.PI) % (2*Math.PI)) - Math.PI;

            pts.push({ lat: φ2*RAD, lon: λ2*RAD });

            φ = φ2; λ = λ2;
          }
        }
        // ensure sorted-ish for tube continuity: just return in insertion order (fine for line)
        return pts;
      }

      // Build a glowing line (two-pass: core + halo) using TubeGeometry
      function makeGlowTube(pointsVec3, radius, coreColor, haloColor, coreOpacity=1.0, haloOpacity=0.35){
        const curve = new THREE.CatmullRomCurve3(pointsVec3, false, "catmullrom", 0.15);

        const coreGeom = new THREE.TubeGeometry(curve, Math.max(300, pointsVec3.length*2), radius, 10, false);
        const haloGeom = new THREE.TubeGeometry(curve, Math.max(300, pointsVec3.length*2), radius*2.5, 10, false);

        const coreMat = new THREE.MeshBasicMaterial({
          color: coreColor,
          transparent: coreOpacity < 1.0,
          opacity: coreOpacity,
          depthWrite: false
        });

        const haloMat = new THREE.MeshBasicMaterial({
          color: haloColor,
          transparent: true,
          opacity: haloOpacity,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });

        const g = new THREE.Group();
        g.add(new THREE.Mesh(haloGeom, haloMat));
        g.add(new THREE.Mesh(coreGeom, coreMat));
        return g;
      }

      // Label sprite (simple, crisp)
      function makeLabelSprite(text, {fontSize=44, padding=18, color="#ffffff", bg="rgba(0,0,0,0.35)"} = {}){
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        ctx.font = `700 ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
        const metrics = ctx.measureText(text);
        const w = Math.ceil(metrics.width + padding*2);
        const h = Math.ceil(fontSize + padding*2);

        canvas.width = w; canvas.height = h;

        // background pill
        ctx.fillStyle = bg;
        const r = Math.min(24, h/2);
        ctx.beginPath();
        ctx.moveTo(r, 0);
        ctx.arcTo(w, 0, w, h, r);
        ctx.arcTo(w, h, 0, h, r);
        ctx.arcTo(0, h, 0, 0, r);
        ctx.arcTo(0, 0, w, 0, r);
        ctx.closePath();
        ctx.fill();

        // text
        ctx.font = `700 ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = color;
        ctx.textBaseline = "middle";
        ctx.fillText(text, padding, h/2);

        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = 8;
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite:false });
        const spr = new THREE.Sprite(mat);

        // scale in world units
        const scale = 0.0065;
        spr.scale.set(w*scale, h*scale, 1);
        return spr;
      }

      // ---------- Main ----------
      try {
        // Scene / Camera / Renderer
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
        camera.position.set(0, 0, 4.2);

        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.05;
        document.body.appendChild(renderer.domElement);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.10));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
        sunLight.position.set(5, 1.5, 2.5);
        scene.add(sunLight);

        // Loading manager
        const manager = new THREE.LoadingManager();
        manager.onStart = () => { statusEl.textContent = "Loading textures…"; };
        manager.onProgress = (_url, loaded, total) => { statusEl.textContent = `Loading textures… (${loaded}/${total})`; };
        manager.onLoad = () => { statusEl.textContent = "Running"; };
        manager.onError = (url) => showError("Texture failed to load:\n" + url);

        // Textures (stable CDN)
        const base = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/";
        const TEX = {
          day:    base + "planets/earth_atmos_2048.jpg",
          night:  base + "planets/earth_lights_2048.png",
          spec:   base + "planets/earth_specular_2048.jpg",
          clouds: base + "planets/earth_clouds_1024.png",
          stars:  base + "galaxy_starfield.png"
        };

        const loader = new THREE.TextureLoader(manager);
        loader.setCrossOrigin("anonymous");

        const dayMap   = loader.load(TEX.day);
        const nightMap = loader.load(TEX.night);
        const specMap  = loader.load(TEX.spec);
        const cloudMap = loader.load(TEX.clouds);
        const starMap  = loader.load(TEX.stars);

        [dayMap, nightMap, specMap, cloudMap, starMap].forEach((t) => t.colorSpace = THREE.SRGBColorSpace);

        const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
        [dayMap, nightMap, specMap, cloudMap, starMap].forEach((t) => {
          t.anisotropy = maxAniso;
          t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
        });

        // Stars
        {
          const starGeo = new THREE.SphereGeometry(90, 64, 64);
          const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
          scene.add(new THREE.Mesh(starGeo, starMat));
        }

        // Globe parts
        const earthRadius = 1.0;
        const SEG = 96;

        // Earth base shader (boost definition slightly)
        const earthUniforms = {
          dayMap:    { value: dayMap },
          specMap:   { value: specMap },
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const earthMat = new THREE.ShaderMaterial({
          uniforms: earthUniforms,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vUv = uv;
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform sampler2D dayMap;
            uniform sampler2D specMap;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);

              // subtle definition boost (contrast + saturation feel)
              float lum = dot(dayCol, vec3(0.2126,0.7152,0.0722));
              vec3 sat = mix(vec3(lum), dayCol, 1.12);
              vec3 c = pow(max(sat, 0.0), vec3(0.92));

              float specMask = texture2D(specMap, vUv).r;

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);

              vec3 nightBase = c * 0.08;
              vec3 col = mix(nightBase, c, dayAmt);

              vec3 H = normalize(L + V);
              float spec = pow(max(dot(N, H), 0.0), 80.0) * specMask * 0.50 * dayAmt;
              col += vec3(spec);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
              col += vec3(0.06, 0.10, 0.16) * rim * (0.30 + 0.70 * dayAmt);

              gl_FragColor = vec4(linearToSrgb(col), 1.0);
            }
          `
        });

        const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);

        // Night lights mesh (additive) — blooms
        const lightsUniforms = {
          nightMap: { value: nightMap },
          sunDir:   { value: new THREE.Vector3(1,0,0) },
          gain:     { value: 2.6 }
        };

        const nightLights = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: lightsUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexShader: `
              varying vec2 vUv;
              varying vec3 vNormalW;
              void main(){
                vUv = uv;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform sampler2D nightMap;
              uniform vec3 sunDir;
              uniform float gain;
              varying vec2 vUv;
              varying vec3 vNormalW;

              vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
              vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);

                float ndl = dot(N, L);
                float dayAmt = smoothstep(-0.05, 0.15, ndl);
                float nightAmt = 1.0 - dayAmt;

                vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
                float mask = smoothstep(0.05, 0.35, nightAmt);

                vec3 col = lights * mask;
                float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
                gl_FragColor = vec4(linearToSrgb(col), a);
              }
            `
          })
        );

        // Cloud shadow (multiply)
        const cloudShadow = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
          new THREE.MeshBasicMaterial({
            map: cloudMap,
            color: 0x000000,
            transparent: true,
            opacity: 0.28,
            blending: THREE.MultiplyBlending,
            depthWrite: false
          })
        );

        // Clouds (visible)
        const clouds = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
          new THREE.MeshLambertMaterial({
            map: cloudMap,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
          })
        );

        // Atmosphere rim — blooms
        const atmoUniforms = {
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const atmosphere = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: atmoUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            vertexShader: `
              varying vec3 vNormalW;
              varying vec3 vPosW;
              void main(){
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vPosW = worldPos.xyz;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * worldPos;
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform vec3 sunDir;
              uniform vec3 cameraPos;
              varying vec3 vNormalW;
              varying vec3 vPosW;

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);
                vec3 V = normalize(cameraPos - vPosW);

                float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
                float daySide = smoothstep(-0.15, 0.25, dot(N, L));

                vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
                float alpha = rim * (0.18 + 0.62 * daySide);
                gl_FragColor = vec4(col, alpha);
              }
            `
          })
        );

        // Rotation group
        const globe = new THREE.Group();
        globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
        scene.add(globe);

        // ---------- Overlays / Layers ----------
        const overlays = {
          axisLines: new THREE.Group(),
          corridors: new THREE.Group(),
          perpendiculars: new THREE.Group(),
          lineNames: new THREE.Group(),
          continents: new THREE.Group(),
          stations: new THREE.Group(),
          magField: new THREE.Group(),
          aurora: new THREE.Group()
        };
        Object.values(overlays).forEach(g => globe.add(g));

        // Anchor: 202 Hendren Ave, Staunton VA (from your earlier log)
        const ANCHOR = {
          name: "EXIT 222 • 202 Hendren Ave • Staunton, VA",
          lat: 38.160833,
          lon: -79.073056
        };

        // Axis bearings: 42° / 222°
        const BEARING_A = 42;
        const BEARING_B = 222;

        // Great circle (blue glow)
        const gc = greatCirclePoints(ANCHOR.lat, ANCHOR.lon, BEARING_B, 1.0)
          .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
        const gcGlow = makeGlowTube(gc, 0.0032, 0x5bbcff, 0x5bbcff, 1.0, 0.32);

        // Rhumb line (gold glow)
        const rh = rhumbPoints(ANCHOR.lat, ANCHOR.lon, BEARING_B, 240)
          .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
        const rhGlow = makeGlowTube(rh, 0.0032, 0xf6c24a, 0xf6c24a, 1.0, 0.28);

        overlays.axisLines.add(gcGlow, rhGlow);

        // Corridors (tube radii for ±1/±5/±10 km)
        // Map km to world units: 1 unit == Earth radius (6371 km)
        const kmToUnit = (km) => (km / 6371) * earthRadius;
        const corridorRadii = [
          { km: 1,  r: kmToUnit(1),  o: 0.18 },
          { km: 5,  r: kmToUnit(5),  o: 0.10 },
          { km: 10, r: kmToUnit(10), o: 0.07 }
        ];
        for (const c of corridorRadii){
          const tubeGC = makeGlowTube(gc, c.r, 0xf6c24a, 0xf6c24a, 0.0, c.o); // halo-only look
          const tubeRH = makeGlowTube(rh, c.r, 0xf6c24a, 0xf6c24a, 0.0, c.o*0.9);
          overlays.corridors.add(tubeGC, tubeRH);
        }

        // Perpendiculars (132° / 312°) — blue glow, shorter arc
        function arcFromBearing(bearingDeg){
          const pts = greatCirclePoints(ANCHOR.lat, ANCHOR.lon, bearingDeg, 1.2)
            .filter((_, idx) => idx > 40 && idx < 260) // crop to a pleasing arc length
            .map(p => latLonToVec3(p.lat, p.lon, earthRadius*1.012));
          return makeGlowTube(pts, 0.0026, 0x5bbcff, 0x5bbcff, 1.0, 0.22);
        }
        overlays.perpendiculars.add(arcFromBearing(132), arcFromBearing(312));

        // Line names
        {
          const a = makeLabelSprite("Rhumb 222° (Gold)", { color:"#ffffff", bg:"rgba(246,194,74,0.18)" });
          a.position.copy(latLonToVec3(25, -20, earthRadius*1.12));
          overlays.lineNames.add(a);

          const b = makeLabelSprite("Geodesic / Great Circle 222° (Blue)", { color:"#ffffff", bg:"rgba(91,188,255,0.18)" });
          b.position.copy(latLonToVec3(-10, 70, earthRadius*1.12));
          overlays.lineNames.add(b);

          const c = makeLabelSprite("Perpendiculars 132° / 312°", { color:"#ffffff", bg:"rgba(91,188,255,0.14)" });
          c.position.copy(latLonToVec3(55, 110, earthRadius*1.14));
          overlays.lineNames.add(c);
        }

        // Continents labels (simple, user-identifiable)
        const CONT = [
          { name:"North America", lat: 45,  lon:-102 },
          { name:"South America", lat:-16,  lon:-60 },
          { name:"Europe",        lat: 52,  lon: 15 },
          { name:"Africa",        lat:  5,  lon: 20 },
          { name:"Asia",          lat: 45,  lon: 95 },
          { name:"Australia",     lat:-25,  lon: 135 },
          { name:"Antarctica",    lat:-80,  lon:  0 }
        ];
        for (const c of CONT){
          const s = makeLabelSprite(c.name, { fontSize: 42, bg:"rgba(0,0,0,0.28)" });
          s.position.copy(latLonToVec3(c.lat, c.lon, earthRadius*1.10));
          overlays.continents.add(s);
        }

        // Stations: anchor + future stations
        function makeStationMarker(label, lat, lon, color=0x7fffd4){
          const g = new THREE.Group();
          const p = latLonToVec3(lat, lon, earthRadius*1.02);

          const pin = new THREE.Mesh(
            new THREE.SphereGeometry(0.010, 18, 18),
            new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.95 })
          );
          pin.position.copy(p);

          const glow = new THREE.Mesh(
            new THREE.SphereGeometry(0.020, 18, 18),
            new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.18, blending:THREE.AdditiveBlending, depthWrite:false })
          );
          glow.position.copy(p);

          const tag = makeLabelSprite(label, { fontSize: 40, bg:"rgba(0,0,0,0.30)" });
          tag.position.copy(latLonToVec3(lat, lon, earthRadius*1.12));

          g.add(glow, pin, tag);
          return g;
        }

        const anchorMarker = makeStationMarker(ANCHOR.name, ANCHOR.lat, ANCHOR.lon, 0x7fffd4);
        overlays.stations.add(anchorMarker);

        const STORAGE_KEY = "eden_future_stations_v1";
        function loadStations(){
          try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]"); }
          catch { return []; }
        }
        function saveStations(arr){
          localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
        }

        function rebuildFutureStations(){
          // remove old future stations (keep anchor at child[0])
          while (overlays.stations.children.length > 1) overlays.stations.remove(overlays.stations.children[1]);

          const list = loadStations();
          list.forEach((s, idx) => {
            overlays.stations.add(makeStationMarker(`Future Station ${idx+1}`, s.lat, s.lon, 0xffffff));
          });
        }
        rebuildFutureStations();

        // Magnetic Field (v1 Dipole preview) — structured for IGRF v2 drop-in later
        // For now: show several dipole field lines oriented to Earth's rotation axis
        function makeDipoleFieldLines(){
          const g = new THREE.Group();
          const col = 0x5bbcff;

          // dipole axis: Y up (simple preview)
          const axis = new THREE.Vector3(0,1,0);

          // generate L-shell-like curves by tracing in dipole coordinates
          const Ls = [1.6, 2.2, 3.2, 4.6];
          for (const L of Ls){
            const pts = [];
            for (let t=-80; t<=80; t+=1.2){
              const θ = (90 - t) * DEG; // colat
              const r = L * Math.sin(θ)*Math.sin(θ); // r = L sin^2(θ)
              const rr = earthRadius * r;

              // build point in dipole meridian plane (x-z), then rotate around axis
              const x = rr * Math.sin(θ);
              const y = rr * Math.cos(θ);
              const v = new THREE.Vector3(x, y, 0);

              // keep close to Earth only
              if (rr < earthRadius*1.04) continue;

              pts.push(v);
            }

            // rotate this meridian curve around Y to make multiple longitudes
            const longitudes = 10;
            for (let i=0; i<longitudes; i++){
              const a = (i / longitudes) * Math.PI*2;
              const ring = pts.map(p => p.clone().applyAxisAngle(axis, a).normalize().multiplyScalar(p.length()));
              // clamp to a reasonable distance
              const ringClamped = ring.filter(v => v.length() < earthRadius*7.5);
              const tube = makeGlowTube(
                ringClamped.map(v => v.clone()),
                0.0014,
                col,
                col,
                0.0,
                0.06
              );
              g.add(tube);
            }
          }
          return g;
        }
        overlays.magField.add(makeDipoleFieldLines());

        // Aurora (v1 preview belt) — structured for Kp v2 later
        function makeAuroraBelt(latDeg=67, color=0xa078ff){
          const g = new THREE.Group();
          const rings = [latDeg, -latDeg];
          for (const lat of rings){
            const pts = [];
            for (let lon=-180; lon<=180; lon+=2){
              pts.push(latLonToVec3(lat, lon, earthRadius*1.05));
            }
            g.add(makeGlowTube(pts, 0.0026, color, color, 0.0, 0.12));
          }
          return g;
        }
        overlays.aurora.add(makeAuroraBelt(67));

        // ---------- Selective Bloom ----------
        const BLOOM_LAYER = 1;
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_LAYER);

        // bloom targets
        nightLights.layers.enable(BLOOM_LAYER);
        atmosphere.layers.enable(BLOOM_LAYER);
        overlays.axisLines.traverse(o => o.layers && o.layers.enable(BLOOM_LAYER));
        overlays.perpendiculars.traverse(o => o.layers && o.layers.enable(BLOOM_LAYER));

        const darkMaterial = new THREE.MeshBasicMaterial({ color:"black" });
        const materials = new Map();

        function darkenNonBloom(obj){
          if (obj.isMesh && !bloomLayer.test(obj.layers)){
            materials.set(obj.uuid, obj.material);
            obj.material = darkMaterial;
          }
        }
        function restoreMaterial(obj){
          if (materials.has(obj.uuid)){
            obj.material = materials.get(obj.uuid);
            materials.delete(obj.uuid);
          }
        }

        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(innerWidth, innerHeight),
          1.20, // strength
          0.85, // radius
          0.10  // threshold
        );

        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        const finalPass = new ShaderPass({
          uniforms: {
            tDiffuse: { value: null },
            bloomTexture: { value: null }
          },
          vertexShader: `
            varying vec2 vUv;
            void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
          `,
          fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main(){
              vec4 base = texture2D(tDiffuse, vUv);
              vec4 bloom = texture2D(bloomTexture, vUv);
              gl_FragColor = base + bloom;
            }
          `
        });

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(finalPass);
        finalComposer.addPass(new OutputPass());

        function renderBloom(){
          scene.traverse(darkenNonBloom);
          bloomComposer.render();
          finalPass.uniforms.bloomTexture.value = bloomComposer.readBuffer.texture;
          scene.traverse(restoreMaterial);
        }

        // ---------- Interaction: drag + inertia + pinch zoom ----------
        let dragging=false, lastX=0, lastY=0, velY=0, velX=0;

        const AUTO_SPIN=0.0013, DRAG_SENS=0.0065, PITCH_SENS=0.0048, DAMPING=0.92, MAX_PITCH=0.55;

        // pinch zoom
        let pinching = false;
        let pinchStartDist = 0;
        let pinchStartZ = camera.position.z;
        const Z_MIN = 2.2;
        const Z_MAX = 8.0;

        function getPoint(e){
          if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
          return { x:e.clientX, y:e.clientY };
        }
        function dist2(t1, t2){
          const dx = t1.clientX - t2.clientX;
          const dy = t1.clientY - t2.clientY;
          return Math.sqrt(dx*dx + dy*dy);
        }

        function down(e){
          if (e.touches && e.touches.length === 2){
            pinching = true;
            pinchStartDist = dist2(e.touches[0], e.touches[1]);
            pinchStartZ = camera.position.z;
            return;
          }
          dragging=true;
          const p=getPoint(e);
          lastX=p.x; lastY=p.y;
        }

        function move(e){
          if (pinching && e.touches && e.touches.length === 2){
            const d = dist2(e.touches[0], e.touches[1]);
            const ratio = pinchStartDist > 0 ? (pinchStartDist / d) : 1.0;
            camera.position.z = clamp(pinchStartZ * ratio, Z_MIN, Z_MAX);
            return;
          }

          if(!dragging) return;
          const p=getPoint(e);
          const dx=p.x-lastX, dy=p.y-lastY;
          lastX=p.x; lastY=p.y;

          globe.rotation.y += dx*DRAG_SENS;
          globe.rotation.x += dy*PITCH_SENS;
          globe.rotation.x = clamp(globe.rotation.x, -MAX_PITCH, MAX_PITCH);

          velY = dx*DRAG_SENS;
          velX = dy*PITCH_SENS;
        }

        function up(){
          dragging=false;
          pinching=false;
        }

        const el = renderer.domElement;
        el.addEventListener("touchstart", down, { passive:true });
        el.addEventListener("touchmove", move, { passive:true });
        el.addEventListener("touchend", up, { passive:true });
        el.addEventListener("mousedown", down);
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);

        // desktop wheel zoom
        window.addEventListener("wheel", (e) => {
          camera.position.z = clamp(camera.position.z + (e.deltaY * 0.0025), Z_MIN, Z_MAX);
        }, { passive:true });

        // Tap-to-add station (only if Stations ON and tap isn't a drag)
        const raycaster = new THREE.Raycaster();
        const ndc = new THREE.Vector2();
        let tapCandidate = null;

        function pointerToNDC(clientX, clientY){
          ndc.x = (clientX / innerWidth) * 2 - 1;
          ndc.y = -(clientY / innerHeight) * 2 + 1;
        }

        function addFutureStationFromTap(clientX, clientY){
          pointerToNDC(clientX, clientY);
          raycaster.setFromCamera(ndc, camera);

          const hits = raycaster.intersectObject(earth, true);
          if (!hits.length) return;

          // world point -> globe local
          const pWorld = hits[0].point.clone();
          const pLocal = globe.worldToLocal(pWorld.clone());
          const v = pLocal.clone().normalize();

          const ll = vec3ToLatLon(v);
          const list = loadStations();
          list.push({ lat: ll.lat, lon: ll.lon, t: Date.now() });
          saveStations(list);
          rebuildFutureStations();

          statusEl.textContent = `Saved Future Station ${list.length} @ ${ll.lat.toFixed(4)}, ${ll.lon.toFixed(4)}`;
        }

        el.addEventListener("touchstart", (e) => {
          if (e.touches?.length === 1){
            tapCandidate = { x: e.touches[0].clientX, y: e.touches[0].clientY, t: performance.now() };
          } else tapCandidate = null;
        }, { passive:true });

        el.addEventListener("touchend", (e) => {
          if (!tapCandidate) return;
          const dt = performance.now() - tapCandidate.t;
          // if user moved a lot, it's a drag
          if (dt < 280 && !dragging && !pinching && state.stations){
            addFutureStationFromTap(tapCandidate.x, tapCandidate.y);
          }
          tapCandidate = null;
        }, { passive:true });

        // ---------- Layer toggles ----------
        const state = {
          axisLines: true,
          lineNames: false,
          continents: false,
          stations: true,
          corridors: false,
          perpendiculars: false,
          magField: false,
          aurora: false
        };

        function applyVisibility(){
          overlays.axisLines.visible = state.axisLines;
          overlays.lineNames.visible = state.lineNames;
          overlays.continents.visible = state.continents;
          overlays.stations.visible = state.stations;
          overlays.corridors.visible = state.corridors;
          overlays.perpendiculars.visible = state.perpendiculars;
          overlays.magField.visible = state.magField;
          overlays.aurora.visible = state.aurora;
        }
        applyVisibility();

        function setPill(key, on){
          const b = document.querySelector(`.pill[data-key="${key}"]`);
          if (!b) return;
          b.classList.toggle("on", !!on);
        }

        document.querySelectorAll(".pill").forEach(btn => {
          btn.addEventListener("click", () => {
            const key = btn.dataset.key;
            state[key] = !state[key];
            setPill(key, state[key]);
            applyVisibility();
          });
        });

        // ---------- Animation ----------
        const sunDrift = 0.00005;
        const cloudSpin = 0.0020;

        function animate(){
          requestAnimationFrame(animate);

          clouds.rotation.y += cloudSpin;
          cloudShadow.rotation.y += cloudSpin + 0.00015;

          if(!dragging && !pinching){
            globe.rotation.y += AUTO_SPIN;
            globe.rotation.y += velY;
            globe.rotation.x += velX;
            velY *= DAMPING;
            velX *= DAMPING;
            globe.rotation.x = clamp(globe.rotation.x, -MAX_PITCH, MAX_PITCH);
          }

          sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
          const sunDir = sunLight.position.clone().normalize();

          earthUniforms.sunDir.value.copy(sunDir);
          earthUniforms.cameraPos.value.copy(camera.position);

          lightsUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.cameraPos.value.copy(camera.position);

          renderBloom();
          finalComposer.render();
        }
        animate();

        addEventListener("resize", () => {
          camera.aspect = innerWidth/innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
          bloomComposer.setSize(innerWidth, innerHeight);
          finalComposer.setSize(innerWidth, innerHeight);
          bloomPass.setSize(innerWidth, innerHeight);
        });

      } catch (err) {
        showError("Top-level error:\n" + (err?.stack || err?.message || err));
      }
    </script>
  </body>
</html>
