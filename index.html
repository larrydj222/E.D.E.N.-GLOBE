<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>E.D.E.N. Globe</title>

    <style>
      :root{
        --bg: #000;
        --ui-bg: rgba(14,14,18,0.55);
        --ui-border: rgba(255,255,255,0.14);
        --ui-text: rgba(255,255,255,0.92);
        --ui-muted: rgba(255,255,255,0.62);
        --btn-off: rgba(255,255,255,0.10);
        --btn-on: rgba(120,210,255,0.22);
        --btn-on-border: rgba(120,210,255,0.55);
        --btn-off-border: rgba(255,255,255,0.14);
      }

      html, body { height:100%; margin:0; background:var(--bg); overflow:hidden; touch-action:none; }
      canvas { display:block; width:100vw !important; height:100vh !important; }

      /* Bottom control bar */
      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 10px;
        z-index: 9999;
        display: flex;
        justify-content: center;
        padding: 0 10px;
        pointer-events: none; /* allow canvas drag except buttons */
      }

      #panel {
        pointer-events: auto;
        max-width: 980px;
        width: min(980px, calc(100vw - 20px));
        background: var(--ui-bg);
        border: 1px solid var(--ui-border);
        border-radius: 18px;
        padding: 10px 10px 12px;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 10px 35px rgba(0,0,0,0.45);
      }

      #titleRow{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        padding: 2px 6px 8px;
      }

      #titleRow .left{
        display:flex;
        flex-direction:column;
        gap:2px;
      }

      #brand {
        font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial;
        font-weight: 700;
        font-size: 13px;
        letter-spacing: 0.02em;
        color: var(--ui-text);
      }

      #sub {
        font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial;
        font-weight: 500;
        font-size: 11px;
        color: var(--ui-muted);
      }

      #chips{
        display:flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 0 6px 2px;
      }

      .chip{
        display:inline-flex;
        align-items:center;
        gap:8px;
        padding: 10px 12px;
        border-radius: 999px;
        border: 1px solid var(--btn-off-border);
        background: var(--btn-off);
        color: var(--ui-text);
        font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial;
        font-weight: 650;
        font-size: 12px;
        letter-spacing: 0.01em;
        user-select:none;
        -webkit-tap-highlight-color: transparent;
        transition: transform 120ms ease, background 180ms ease, border-color 180ms ease;
      }

      .chip:active { transform: scale(0.98); }
      .chip.on{
        background: var(--btn-on);
        border-color: var(--btn-on-border);
      }

      .dot{
        width: 10px; height:10px;
        border-radius: 999px;
        background: rgba(255,255,255,0.35);
        box-shadow: 0 0 0 rgba(0,0,0,0);
      }
      .chip.on .dot{
        background: rgba(120,210,255,0.9);
        box-shadow: 0 0 10px rgba(120,210,255,0.6);
      }

      /* optional mini HUD for debugging on iPhone */
      #hud{
        position:fixed; left:10px; top:10px; z-index:9999;
        font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial;
        font-size:12px; line-height:1.25;
        color:#d7d7d7; background:rgba(0,0,0,0.55);
        border:1px solid rgba(255,255,255,0.12);
        border-radius:12px; padding:10px 12px; max-width:88vw;
        backdrop-filter:blur(6px);
        display:none;
      }
      #hud b{ color:#fff; }
      #errors{ margin-top:8px; color:#ff9c9c; white-space:pre-wrap; display:none; }
    </style>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <div id="hud">
      <div><b>Status:</b> <span id="status">Booting…</span></div>
      <div id="errors"></div>
    </div>

    <!-- UI -->
    <div id="ui">
      <div id="panel">
        <div id="titleRow">
          <div class="left">
            <div id="brand">E.D.E.N. Globe</div>
            <div id="sub">Tap to toggle layers • Drag globe to rotate</div>
          </div>
        </div>

        <div id="chips">
          <div class="chip on" data-toggle="axis"><span class="dot"></span>Axis Lines</div>
          <div class="chip on" data-toggle="lineLabels"><span class="dot"></span>Line Names</div>
          <div class="chip on" data-toggle="continents"><span class="dot"></span>Continents</div>
          <div class="chip on" data-toggle="stations"><span class="dot"></span>Stations</div>
          <div class="chip" data-toggle="magnetic"><span class="dot"></span>Magnetic Field</div>
          <div class="chip" data-toggle="aurora"><span class="dot"></span>Aurora</div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // ---------- Optional HUD for debugging ----------
      const hud = document.getElementById("hud");
      const statusEl = document.getElementById("status");
      const errorsEl = document.getElementById("errors");
      const qp = new URLSearchParams(location.search);
      const HUD_ON = qp.get("hud") === "1";
      if (HUD_ON) hud.style.display = "block";

      function showError(msg){
        if (!HUD_ON) hud.style.display = "block";
        errorsEl.style.display = "block";
        errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
        statusEl.textContent = "Error";
      }
      window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
      window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

      // ---------- E.D.E.N. Constants ----------
      const DEG2RAD = Math.PI/180;
      const EARTH_RADIUS_KM = 6371.0;

      // Anchor (approx) near 202 Hendren Ave, Staunton VA
      const ANCHOR_LAT = 38.160833;
      const ANCHOR_LON = -79.073056;

      const AXIS_BEARING = 42;

      const GOLD = new THREE.Color(0xffd36b); // Rhumb
      const BLUE = new THREE.Color(0x4db3ff); // Great Circle
      const CTRL = new THREE.Color(0xd9f0ff);

      const BLOOM_STRENGTH = 1.22;
      const BLOOM_RADIUS = 0.85;
      const BLOOM_THRESHOLD = 0.10;

      const LIGHTS_GAIN = 2.55;

      // Layers
      const CORRIDORS_KM = [1,5,10];
      const AXIS_ALT = 1.020;
      const AXIS_OUTER_R = 0.010;
      const AXIS_INNER_R = 0.004;
      const CORR_OUTER_R = 0.0065;
      const CORR_INNER_R = 0.0028;
      const CTRL_OUTER_R = 0.0075;
      const CTRL_INNER_R = 0.0030;

      // Spin / drag
      const AUTO_SPIN=0.00125, DRAG_SENS=0.0065, PITCH_SENS=0.0048, DAMPING=0.92, MAX_PITCH=0.55;

      // Continents pop
      const NORMAL_SCALE = 1.15;
      const DAY_CONTRAST = 1.12;
      const COAST_STRENGTH = 0.55;
      const COAST_LOW = 0.020;
      const COAST_HIGH = 0.080;

      // ---------- Helpers ----------
      function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
      function wrapLonRad(lam){
        const TWO_PI = Math.PI*2;
        lam = (lam + Math.PI) % TWO_PI;
        if (lam < 0) lam += TWO_PI;
        return lam - Math.PI;
      }

      function makeFallbackTexture(hex = "#222"){
        const c = document.createElement("canvas");
        c.width = c.height = 2;
        const ctx = c.getContext("2d");
        ctx.fillStyle = hex;
        ctx.fillRect(0,0,2,2);
        const t = new THREE.CanvasTexture(c);
        t.needsUpdate = true;
        return t;
      }

      function applyTexSettings(tex, { colorSpace=null, maxAniso=1 } = {}){
        if (colorSpace) tex.colorSpace = colorSpace;
        tex.anisotropy = maxAniso;
        tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.minFilter = THREE.LinearMipmapLinearFilter;
        tex.magFilter = THREE.LinearFilter;
      }

      function latLonToVec3(latDeg, lonDeg, radius){
        const lat = latDeg * DEG2RAD;
        const lon = lonDeg * DEG2RAD;
        const cosLat = Math.cos(lat);
        return new THREE.Vector3(
          radius * cosLat * Math.cos(lon),
          radius * Math.sin(lat),
          radius * cosLat * Math.sin(lon)
        );
      }

      function greatCirclePoint(lat1, lon1, bearingRad, delta){
        const sinLat1 = Math.sin(lat1), cosLat1 = Math.cos(lat1);
        const sinD = Math.sin(delta), cosD = Math.cos(delta);
        const sinBr = Math.sin(bearingRad), cosBr = Math.cos(bearingRad);

        const sinLat2 = sinLat1 * cosD + cosLat1 * sinD * cosBr;
        const lat2 = Math.asin(clamp(sinLat2, -1, 1));

        const y = sinBr * sinD * cosLat1;
        const x = cosD - sinLat1 * Math.sin(lat2);
        const lon2 = wrapLonRad(lon1 + Math.atan2(y, x));
        return { lat: lat2, lon: lon2 };
      }

      function rhumbStep(lat1, lon1, bearingRad, d){
        const dPhi = d * Math.cos(bearingRad);
        let lat2 = lat1 + dPhi;
        lat2 = clamp(lat2, (-89.9)*DEG2RAD, (89.9)*DEG2RAD);

        const dPsi = Math.log(Math.tan(Math.PI/4 + lat2/2) / Math.tan(Math.PI/4 + lat1/2));
        const q = (Math.abs(dPsi) > 1e-12) ? (dPhi / dPsi) : Math.cos(lat1);

        const dLam = d * Math.sin(bearingRad) / q;
        const lon2 = wrapLonRad(lon1 + dLam);
        return { lat: lat2, lon: lon2 };
      }

      function buildGreatCirclePoints(latDeg, lonDeg, bearingDeg, radius, stepDeg=0.75){
        const lat1 = latDeg * DEG2RAD;
        const lon1 = lonDeg * DEG2RAD;
        const br = bearingDeg * DEG2RAD;

        const pts = [];
        const step = stepDeg * DEG2RAD;
        for (let d=0; d<=Math.PI*2 + step*0.5; d+=step){
          const p = greatCirclePoint(lat1, lon1, br, d);
          pts.push(latLonToVec3(p.lat/DEG2RAD, p.lon/DEG2RAD, radius));
        }
        return pts;
      }

      function buildRhumbPoints(latDeg, lonDeg, bearingDeg, radius, stepDeg=0.35, maxSteps=5000){
        const lat1 = latDeg * DEG2RAD;
        const lon1 = lonDeg * DEG2RAD;
        const br = bearingDeg * DEG2RAD;
        const step = stepDeg * DEG2RAD;

        let lat=lat1, lon=lon1;
        const fwd=[latLonToVec3(latDeg, lonDeg, radius)];
        for (let i=0;i<maxSteps;i++){
          const p=rhumbStep(lat,lon,br,step);
          lat=p.lat; lon=p.lon;
          fwd.push(latLonToVec3(lat/DEG2RAD, lon/DEG2RAD, radius));
          if (Math.abs(lat)>(89.7*DEG2RAD)) break;
        }

        lat=lat1; lon=lon1;
        const back=[];
        const brBack=wrapLonRad(br+Math.PI);
        for (let i=0;i<maxSteps;i++){
          const p=rhumbStep(lat,lon,brBack,step);
          lat=p.lat; lon=p.lon;
          back.push(latLonToVec3(lat/DEG2RAD, lon/DEG2RAD, radius));
          if (Math.abs(lat)>(89.7*DEG2RAD)) break;
        }
        back.reverse();
        return back.concat(fwd);
      }

      function offsetCurve(points, km, radius){
        const a = (km / EARTH_RADIUS_KM);
        const cosA = Math.cos(a);
        const sinA = Math.sin(a);

        const out=[];
        const n=points.length;
        for (let i=0;i<n;i++){
          const pPrev=points[Math.max(0,i-1)];
          const pNext=points[Math.min(n-1,i+1)];
          const p=points[i];

          const t=pNext.clone().sub(pPrev).normalize();
          const v=p.clone().normalize();
          const s=new THREE.Vector3().crossVectors(t,v).normalize();

          const vp=v.clone().multiplyScalar(cosA).add(s.clone().multiplyScalar(sinA)).normalize();
          out.push(vp.multiplyScalar(radius));
        }
        return out;
      }

      function makeGlowTube(points, color, outerR, innerR, outerOpacity=0.22, innerOpacity=0.92){
        const curve = new THREE.CatmullRomCurve3(points, false, "catmullrom", 0.05);
        const tubularSegments = Math.max(300, points.length * 2);

        const outer = new THREE.Mesh(
          new THREE.TubeGeometry(curve, tubularSegments, outerR, 14, false),
          new THREE.MeshBasicMaterial({
            color,
            transparent:true,
            opacity:outerOpacity,
            blending:THREE.AdditiveBlending,
            depthWrite:false
          })
        );

        const inner = new THREE.Mesh(
          new THREE.TubeGeometry(curve, tubularSegments, innerR, 10, false),
          new THREE.MeshBasicMaterial({
            color,
            transparent:true,
            opacity:innerOpacity,
            blending:THREE.AdditiveBlending,
            depthWrite:false
          })
        );

        const g=new THREE.Group();
        g.add(outer, inner);
        return g;
      }

      function makeTextSprite(text){
        const padX=18, padY=12;
        const fontSize=44;
        const canvas=document.createElement("canvas");
        const ctx=canvas.getContext("2d");

        ctx.font=`700 ${fontSize}px -apple-system, system-ui, Segoe UI, Roboto, Arial`;
        const w=Math.ceil(ctx.measureText(text).width + padX*2);
        const h=Math.ceil(fontSize + padY*2);
        canvas.width=w; canvas.height=h;

        const r=14;
        ctx.fillStyle="rgba(0,0,0,0.45)";
        ctx.strokeStyle="rgba(255,255,255,0.18)";
        ctx.lineWidth=3;

        ctx.beginPath();
        ctx.moveTo(r,0);
        ctx.arcTo(w,0,w,h,r);
        ctx.arcTo(w,h,0,h,r);
        ctx.arcTo(0,h,0,0,r);
        ctx.arcTo(0,0,w,0,r);
        ctx.closePath();
        ctx.fill(); ctx.stroke();

        ctx.fillStyle="rgba(255,255,255,0.92)";
        ctx.textBaseline="middle";
        ctx.fillText(text, padX, h/2);

        const tex=new THREE.CanvasTexture(canvas);
        tex.colorSpace=THREE.SRGBColorSpace;
        tex.minFilter=THREE.LinearFilter;
        tex.magFilter=THREE.LinearFilter;

        const mat=new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false });
        const spr=new THREE.Sprite(mat);

        const aspect=w/h;
        const base=0.46;
        spr.scale.set(base*aspect, base, 1);
        return spr;
      }

      async function tryLoadTexture(url){
        return new Promise((resolve, reject) => {
          const loader = new THREE.TextureLoader();
          loader.setCrossOrigin("anonymous");
          loader.load(url, resolve, undefined, reject);
        });
      }
      async function loadFirst(urls){
        for (const u of urls){
          try { return { tex: await tryLoadTexture(u), used:u }; } catch {}
        }
        return { tex:null, used:"(fallback)" };
      }

      // ---------- Scene ----------
      try{
        if (HUD_ON) statusEl.textContent="Booting…";

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
        camera.position.set(0,0,4.2);

        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:"high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.setClearColor(0x000000, 1);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.10));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
        sunLight.position.set(5,1.5,2.5);
        scene.add(sunLight);

        const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;

        // Fallback textures so it NEVER renders black
        const dayMap    = makeFallbackTexture("#1f2b3a");
        const nightMap  = makeFallbackTexture("#000");
        const specMap   = makeFallbackTexture("#111");
        const normalMap = makeFallbackTexture("#8080ff");
        const cloudMap  = makeFallbackTexture("#222");
        const starMap   = makeFallbackTexture("#000");

        applyTexSettings(dayMap,   { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(nightMap, { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(cloudMap, { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(starMap,  { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(specMap,  { colorSpace: THREE.NoColorSpace, maxAniso });
        applyTexSettings(normalMap,{ colorSpace: THREE.NoColorSpace, maxAniso });

        // Stars
        {
          const starGeo = new THREE.SphereGeometry(90, 64, 64);
          const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
          scene.add(new THREE.Mesh(starGeo, starMat));
        }

        // Earth shader (coastline enhancement for continent readability)
        const earthRadius=1.0;
        const SEG=96;

        const earthUniforms = {
          dayMap: { value: dayMap },
          specMap:{ value: specMap },
          normalMap:{ value: normalMap },
          texel:{ value: new THREE.Vector2(1/2048, 1/1024) },
          normalScale:{ value: NORMAL_SCALE },
          dayContrast:{ value: DAY_CONTRAST },
          coastStrength:{ value: COAST_STRENGTH },
          coastLow:{ value: COAST_LOW },
          coastHigh:{ value: COAST_HIGH },
          sunDir:{ value: new THREE.Vector3(1,0,0) },
          cameraPos:{ value: new THREE.Vector3() }
        };

        const earthMat = new THREE.ShaderMaterial({
          uniforms: earthUniforms,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vUv = uv;
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;

            uniform sampler2D dayMap;
            uniform sampler2D specMap;
            uniform sampler2D normalMap;
            uniform vec2 texel;

            uniform float normalScale;
            uniform float dayContrast;

            uniform float coastStrength;
            uniform float coastLow;
            uniform float coastHigh;

            uniform vec3 sunDir;
            uniform vec3 cameraPos;

            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }
            float luma(vec3 c){ return dot(c, vec3(0.2126, 0.7152, 0.0722)); }

            vec3 perturbNormal(vec3 surfPos, vec3 surfNorm, vec2 uv){
              vec3 map = texture2D(normalMap, uv).xyz * 2.0 - 1.0;
              map.xy *= normalScale;

              vec3 dp1 = dFdx(surfPos);
              vec3 dp2 = dFdy(surfPos);
              vec2 duv1 = dFdx(uv);
              vec2 duv2 = dFdy(uv);

              vec3 dp2perp = cross(dp2, surfNorm);
              vec3 dp1perp = cross(surfNorm, dp1);
              vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
              vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

              float invmax = inversesqrt(max(dot(T,T), dot(B,B)));
              mat3 TBN = mat3(T*invmax, B*invmax, surfNorm);
              return normalize(TBN * map);
            }

            float coastlineEdge(vec2 uv){
              vec3 c  = srgbToLinear(texture2D(dayMap, uv).rgb);
              float m = luma(c);

              float ml = luma(srgbToLinear(texture2D(dayMap, uv - vec2(texel.x, 0.0)).rgb));
              float mr = luma(srgbToLinear(texture2D(dayMap, uv + vec2(texel.x, 0.0)).rgb));
              float md = luma(srgbToLinear(texture2D(dayMap, uv - vec2(0.0, texel.y)).rgb));
              float mu = luma(srgbToLinear(texture2D(dayMap, uv + vec2(0.0, texel.y)).rgb));

              float g = abs(mr-ml) + abs(mu-md);
              return smoothstep(coastLow, coastHigh, g);
            }

            void main(){
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              vec3 N0 = normalize(vNormalW);
              vec3 N = perturbNormal(vPosW, N0, vUv);

              vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
              dayCol = pow(dayCol, vec3(1.0/dayContrast));

              float edge = coastlineEdge(vUv);
              dayCol *= (1.0 - coastStrength * edge * 0.55);

              float specMask = texture2D(specMap, vUv).r;

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);

              vec3 nightBase = dayCol * 0.09;
              vec3 col = mix(nightBase, dayCol, dayAmt);

              vec3 H = normalize(L + V);
              float spec = pow(max(dot(N, H), 0.0), 95.0) * specMask * 0.55 * dayAmt;
              col += vec3(spec);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
              col += vec3(0.06, 0.10, 0.18) * rim * (0.30 + 0.70 * dayAmt);

              gl_FragColor = vec4(linearToSrgb(col), 1.0);
            }
          `
        });

        const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);
        scene.add(earth);

        // Night lights (bloom)
        const lightsUniforms = {
          nightMap: { value: nightMap },
          sunDir:   { value: new THREE.Vector3(1,0,0) },
          gain:     { value: LIGHTS_GAIN }
        };

        const nightLights = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: lightsUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexShader: `
              varying vec2 vUv; varying vec3 vNormalW;
              void main(){
                vUv = uv;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform sampler2D nightMap;
              uniform vec3 sunDir;
              uniform float gain;
              varying vec2 vUv;
              varying vec3 vNormalW;

              vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
              vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);

                float ndl = dot(N, L);
                float dayAmt = smoothstep(-0.05, 0.15, ndl);
                float nightAmt = 1.0 - dayAmt;

                vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
                float mask = smoothstep(0.05, 0.35, nightAmt);

                vec3 col = lights * mask;
                float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
                gl_FragColor = vec4(linearToSrgb(col), a);
              }
            `
          })
        );
        scene.add(nightLights);

        // Clouds
        const cloudShadow = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
          new THREE.MeshBasicMaterial({
            map: cloudMap,
            color: 0x000000,
            transparent: true,
            opacity: 0.28,
            blending: THREE.MultiplyBlending,
            depthWrite: false
          })
        );
        scene.add(cloudShadow);

        const clouds = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
          new THREE.MeshLambertMaterial({
            map: cloudMap,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
          })
        );
        scene.add(clouds);

        // Atmosphere (bloom)
        const atmoUniforms = {
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const atmosphere = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: atmoUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            vertexShader: `
              varying vec3 vNormalW; varying vec3 vPosW;
              void main(){
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vPosW = worldPos.xyz;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * worldPos;
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform vec3 sunDir;
              uniform vec3 cameraPos;
              varying vec3 vNormalW;
              varying vec3 vPosW;
              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);
                vec3 V = normalize(cameraPos - vPosW);

                float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
                float daySide = smoothstep(-0.15, 0.25, dot(N, L));

                vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
                float alpha = rim * (0.18 + 0.62 * daySide);
                gl_FragColor = vec4(col, alpha);
              }
            `
          })
        );
        scene.add(atmosphere);

        // --------- Overlay groups (TOGGLED) ---------
        const globe = new THREE.Group();
        scene.remove(earth, nightLights, cloudShadow, clouds, atmosphere);
        globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
        scene.add(globe);

        const overlays = {
          axis: new THREE.Group(),
          lineLabels: new THREE.Group(),
          continents: new THREE.Group(),
          stations: new THREE.Group(),
          magnetic: new THREE.Group(),
          aurora: new THREE.Group()
        };
        Object.values(overlays).forEach(g => globe.add(g));

        // Axis: Great Circle + Rhumb + corridors + perpendiculars
        const axisRadius = earthRadius * AXIS_ALT;

        const gcPts = buildGreatCirclePoints(ANCHOR_LAT, ANCHOR_LON, AXIS_BEARING, axisRadius, 0.75);
        const rhPts = buildRhumbPoints(ANCHOR_LAT, ANCHOR_LON, AXIS_BEARING, axisRadius, 0.35, 5000);

        const greatCircle = makeGlowTube(gcPts, BLUE, AXIS_OUTER_R, AXIS_INNER_R);
        const rhumbLine   = makeGlowTube(rhPts, GOLD, AXIS_OUTER_R, AXIS_INNER_R);

        function buildCorridors(points, color){
          const g=new THREE.Group();
          for (const km of CORRIDORS_KM){
            const plus  = offsetCurve(points, +km, axisRadius);
            const minus = offsetCurve(points, -km, axisRadius);
            g.add(
              makeGlowTube(plus,  color, CORR_OUTER_R, CORR_INNER_R, 0.12, 0.55),
              makeGlowTube(minus, color, CORR_OUTER_R, CORR_INNER_R, 0.12, 0.55)
            );
          }
          return g;
        }

        const gcCorridors = buildCorridors(gcPts, BLUE);
        const rhCorridors = buildCorridors(rhPts, GOLD);

        const perp1 = buildGreatCirclePoints(ANCHOR_LAT, ANCHOR_LON, AXIS_BEARING + 90, axisRadius, 0.75);
        const perp2 = buildGreatCirclePoints(ANCHOR_LAT, ANCHOR_LON, AXIS_BEARING - 90, axisRadius, 0.75);
        const perpA = makeGlowTube(perp1, CTRL, CTRL_OUTER_R, CTRL_INNER_R, 0.10, 0.60);
        const perpB = makeGlowTube(perp2, CTRL, CTRL_OUTER_R, CTRL_INNER_R, 0.10, 0.60);

        overlays.axis.add(greatCircle, rhumbLine, gcCorridors, rhCorridors, perpA, perpB);

        // Line labels
        const rhLabel = makeTextSprite("Rhumb Line (True) — 42°/222° (Gold)");
        rhLabel.position.copy(latLonToVec3(10, -30, earthRadius * 1.22));
        const gcLabel = makeTextSprite("Great Circle (Geodesic WGS84) — 42°/222° (Blue)");
        gcLabel.position.copy(latLonToVec3(-8, 25, earthRadius * 1.22));
        const perpLabel = makeTextSprite("Perpendicular Controls — 132° / 312°");
        perpLabel.position.copy(latLonToVec3(-25, -150, earthRadius * 1.22));
        overlays.lineLabels.add(rhLabel, gcLabel, perpLabel);

        // Continent labels
        const continents = [
          { name:"North America", lat:  40, lon: -100 },
          { name:"South America", lat: -15, lon:  -60 },
          { name:"Europe",        lat:  52, lon:   15 },
          { name:"Africa",        lat:   5, lon:   20 },
          { name:"Asia",          lat:  35, lon:   95 },
          { name:"Australia",     lat: -25, lon:  135 },
          { name:"Antarctica",    lat: -80, lon:    0 }
        ];
        const labelRadius = earthRadius * 1.095;
        continents.forEach(c => {
          const s = makeTextSprite(c.name);
          s.position.copy(latLonToVec3(c.lat, c.lon, labelRadius));
          overlays.continents.add(s);
        });

        // Stations (current: Exit 222 / 202 Staunton VA)
        function makeStationMarker(name, lat, lon){
          const g = new THREE.Group();
          const marker = new THREE.Mesh(
            new THREE.SphereGeometry(0.018, 18, 18),
            new THREE.MeshBasicMaterial({
              color: 0xffffff,
              transparent:true,
              opacity:0.95,
              blending: THREE.AdditiveBlending,
              depthWrite:false
            })
          );
          marker.position.copy(latLonToVec3(lat, lon, earthRadius * 1.026));
          g.add(marker);

          const label = makeTextSprite(name);
          label.position.copy(latLonToVec3(lat, lon, earthRadius * 1.18));
          g.add(label);
          return g;
        }
        overlays.stations.add(
          makeStationMarker("Exit 222 / 202 Station — Staunton, VA", ANCHOR_LAT, ANCHOR_LON)
        );

        // Magnetic field (simple dipole-like lines v1)
        // This is an illustrative overlay (not measured data).
        function buildMagneticField(){
          const g = new THREE.Group();
          const fieldColor = new THREE.Color(0x7ad2ff);

          // Build a set of meridian-like arcs near poles (stylized)
          const lines = 18;
          for (let i=0;i<lines;i++){
            const lon = -180 + (360/lines)*i;
            const pts=[];
            for (let t=0;t<=1.0;t+=0.02){
              // latitude curve concentrating toward poles
              const lat = -80 + 160*t; // -80..80
              // raise altitude near poles slightly for effect
              const alt = 1.06 + 0.06 * Math.pow(Math.abs(lat)/80, 2.0);
              pts.push(latLonToVec3(lat, lon, earthRadius * alt));
            }
            const tube = makeGlowTube(pts, fieldColor, 0.0055, 0.0022, 0.08, 0.35);
            g.add(tube);
          }
          return g;
        }
        overlays.magnetic.add(buildMagneticField());

        // Aurora (subtle polar glow rings v1)
        function buildAurora(){
          const g = new THREE.Group();
          const aurMat = new THREE.MeshBasicMaterial({
            color: 0x66ffcc,
            transparent:true,
            opacity:0.10,
            blending: THREE.AdditiveBlending,
            depthWrite:false,
            side: THREE.DoubleSide
          });

          function ring(lat){
            const r = earthRadius * 1.06;
            const geo = new THREE.TorusGeometry(r*Math.cos(lat*DEG2RAD), 0.03, 10, 120);
            const mesh = new THREE.Mesh(geo, aurMat.clone());
            mesh.rotation.x = Math.PI/2;
            mesh.position.y = earthRadius * Math.sin(lat*DEG2RAD) * 1.04;
            return mesh;
          }

          // north + south auroral ovals
          g.add(ring(72), ring(-72));
          return g;
        }
        overlays.aurora.add(buildAurora());

        // ---------- Selective Bloom ----------
        const BLOOM_LAYER = 1;
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_LAYER);

        // bloom targets
        nightLights.layers.enable(BLOOM_LAYER);
        atmosphere.layers.enable(BLOOM_LAYER);
        // bloom overlays (lines / stations / effects)
        [overlays.axis, overlays.magnetic, overlays.aurora, overlays.stations].forEach(grp => {
          grp.traverse(o => o.layers?.enable(BLOOM_LAYER));
        });

        const darkMaterial = new THREE.MeshBasicMaterial({ color:"black" });
        const materials = new Map();
        function darkenNonBloom(obj){
          if (obj.isMesh && !bloomLayer.test(obj.layers)){
            materials.set(obj.uuid, obj.material);
            obj.material = darkMaterial;
          }
        }
        function restoreMaterial(obj){
          if (materials.has(obj.uuid)){
            obj.material = materials.get(obj.uuid);
            materials.delete(obj.uuid);
          }
        }

        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(innerWidth, innerHeight),
          BLOOM_STRENGTH, BLOOM_RADIUS, BLOOM_THRESHOLD
        );

        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        const finalPass = new ShaderPass({
          uniforms: { tDiffuse: { value: null }, bloomTexture: { value: null } },
          vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
          fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main(){
              vec4 base = texture2D(tDiffuse, vUv);
              vec4 bloom = texture2D(bloomTexture, vUv);
              gl_FragColor = base + bloom;
            }
          `
        });

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(finalPass);
        finalComposer.addPass(new OutputPass());

        function renderBloom(){
          scene.traverse(darkenNonBloom);
          bloomComposer.render();
          finalPass.uniforms.bloomTexture.value = bloomComposer.readBuffer.texture;
          scene.traverse(restoreMaterial);
        }

        // ---------- UI toggles ----------
        const state = {
          axis: true,
          lineLabels: true,
          continents: true,
          stations: true,
          magnetic: false,
          aurora: false
        };

        function applyState(){
          overlays.axis.visible = state.axis;

          overlays.lineLabels.visible = state.lineLabels;
          overlays.continents.visible = state.continents;
          overlays.stations.visible = state.stations;

          overlays.magnetic.visible = state.magnetic;
          overlays.aurora.visible = state.aurora;
        }
        applyState();

        const chips = [...document.querySelectorAll(".chip")];
        chips.forEach(ch => {
          ch.addEventListener("click", () => {
            const key = ch.dataset.toggle;
            state[key] = !state[key];
            ch.classList.toggle("on", state[key]);
            applyState();
          });
        });

        // Ensure labels always face camera
        function faceCamera(group){
          group.children.forEach(obj => {
            if (obj.isSprite) obj.quaternion.copy(camera.quaternion);
            if (obj.children?.length) faceCamera(obj);
          });
        }

        // ---------- Touch drag + inertia ----------
        let dragging=false, lastX=0, lastY=0, velY=0, velX=0;

        function getPoint(e){
          if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
          return { x:e.clientX, y:e.clientY };
        }
        function down(e){ dragging=true; const p=getPoint(e); lastX=p.x; lastY=p.y; }
        function move(e){
          if(!dragging) return;
          const p=getPoint(e);
          const dx=p.x-lastX, dy=p.y-lastY;
          lastX=p.x; lastY=p.y;

          globe.rotation.y += dx*DRAG_SENS;
          globe.rotation.x += dy*PITCH_SENS;
          globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));

          velY = dx*DRAG_SENS;
          velX = dy*PITCH_SENS;
        }
        function up(){ dragging=false; }

        const el = renderer.domElement;
        el.addEventListener("touchstart", down, { passive:true });
        el.addEventListener("touchmove", move, { passive:true });
        el.addEventListener("touchend", up, { passive:true });
        el.addEventListener("mousedown", down);
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);

        // ---------- Animation ----------
        const sunDrift = 0.00005;
        const cloudSpin = 0.0020;

        function animate(){
          requestAnimationFrame(animate);

          // face sprites
          faceCamera(overlays.lineLabels);
          faceCamera(overlays.continents);
          faceCamera(overlays.stations);

          clouds.rotation.y += cloudSpin;
          cloudShadow.rotation.y += cloudSpin + 0.00015;

          if(!dragging){
            globe.rotation.y += AUTO_SPIN;
            globe.rotation.y += velY;
            globe.rotation.x += velX;
            velY *= DAMPING;
            velX *= DAMPING;
            globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));
          }

          sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
          const sunDir = sunLight.position.clone().normalize();

          earthUniforms.sunDir.value.copy(sunDir);
          earthUniforms.cameraPos.value.copy(camera.position);

          lightsUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.cameraPos.value.copy(camera.position);

          renderBloom();
          finalComposer.render();
        }
        animate();

        // ---------- Resize ----------
        addEventListener("resize", () => {
          camera.aspect = innerWidth/innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
          bloomComposer.setSize(innerWidth, innerHeight);
          finalComposer.setSize(innerWidth, innerHeight);
          bloomPass.setSize(innerWidth, innerHeight);
        });

        // ---------- Texture upgrade (no local files required) ----------
        if (HUD_ON) statusEl.textContent="Loading textures…";

        const cdnJS = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/";
        const cdn3J = "https://threejs.org/examples/textures/";

        const sources = {
          day:    [cdnJS+"planets/earth_atmos_4096.jpg", cdn3J+"planets/earth_atmos_4096.jpg", cdnJS+"planets/earth_atmos_2048.jpg", cdn3J+"planets/earth_atmos_2048.jpg"],
          night:  [cdnJS+"planets/earth_lights_2048.png",    cdn3J+"planets/earth_lights_2048.png"],
          spec:   [cdnJS+"planets/earth_specular_2048.jpg",  cdn3J+"planets/earth_specular_2048.jpg"],
          normal: [cdnJS+"planets/earth_normal_2048.jpg",    cdn3J+"planets/earth_normal_2048.jpg"],
          clouds: [cdnJS+"planets/earth_clouds_1024.png",    cdn3J+"planets/earth_clouds_1024.png"],
          stars:  [cdnJS+"galaxy_starfield.png",             cdn3J+"galaxy_starfield.png"]
        };

        const [dayRes, nightRes, specRes, normalRes, cloudRes, starsRes] = await Promise.all([
          loadFirst(sources.day),
          loadFirst(sources.night),
          loadFirst(sources.spec),
          loadFirst(sources.normal),
          loadFirst(sources.clouds),
          loadFirst(sources.stars),
        ]);

        function updateTexelFrom(tex){
          const w = tex?.image?.width || 2048;
          const h = tex?.image?.height || 1024;
          earthUniforms.texel.value.set(1/Math.max(1,w), 1/Math.max(1,h));
        }

        if (dayRes.tex){
          applyTexSettings(dayRes.tex, { colorSpace: THREE.SRGBColorSpace, maxAniso });
          earthUniforms.dayMap.value = dayRes.tex;
          updateTexelFrom(dayRes.tex);
        }
        if (nightRes.tex){
          applyTexSettings(nightRes.tex, { colorSpace: THREE.SRGBColorSpace, maxAniso });
          lightsUniforms.nightMap.value = nightRes.tex;
        }
        if (specRes.tex){
          applyTexSettings(specRes.tex, { colorSpace: THREE.NoColorSpace, maxAniso });
          earthUniforms.specMap.value = specRes.tex;
        }
        if (normalRes.tex){
          applyTexSettings(normalRes.tex, { colorSpace: THREE.NoColorSpace, maxAniso });
          earthUniforms.normalMap.value = normalRes.tex;
        }
        if (cloudRes.tex){
          applyTexSettings(cloudRes.tex, { colorSpace: THREE.SRGBColorSpace, maxAniso });
          cloudShadow.material.map = cloudRes.tex;
          clouds.material.map = cloudRes.tex;
          cloudShadow.material.needsUpdate = true;
          clouds.material.needsUpdate = true;
        }
        if (starsRes.tex){
          applyTexSettings(starsRes.tex, { colorSpace: THREE.SRGBColorSpace, maxAniso });
          scene.traverse(o => {
            if (o.isMesh && o.material && o.material.map === starMap){
              o.material.map = starsRes.tex;
              o.material.needsUpdate = true;
            }
          });
        }

        if (HUD_ON){
          statusEl.textContent="Running";
          errorsEl.style.display="block";
          errorsEl.textContent =
            `Anchor: ${ANCHOR_LAT.toFixed(6)}, ${ANCHOR_LON.toFixed(6)}\n`+
            `Axis: 42° / 222°\nPerps: 132° / 312°\nCorridors: ±1/±5/±10 km\n\n`+
            `Textures:\n`+
            `day: ${dayRes.used}\nnight: ${nightRes.used}\n`+
            `spec: ${specRes.used}\nnormal: ${normalRes.used}\n`+
            `cloud: ${cloudRes.used}\nstars: ${starsRes.used}`;
        }

      } catch (err) {
        showError("Top-level error:\n" + (err?.stack || err?.message || err));
      }
    </script>
  </body>
</html>
