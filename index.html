<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>E.D.E.N. Globe</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        background: #000;
        overflow: hidden;
        touch-action: none;
      }
      canvas {
        display: block;
        width: 100vw !important;
        height: 100vh !important;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

      import { EffectComposer } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/RenderPass.js";
      import { ShaderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/ShaderPass.js";
      import { OutputPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/OutputPass.js";
      import { UnrealBloomPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js";

      // ---------------- Scene / Camera / Renderer ----------------
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 5000);
      camera.position.set(0, 0, 4.2);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.05; // ✅ slightly brighter/clearer continents
      document.body.appendChild(renderer.domElement);

      // ---------------- Lights ----------------
      scene.add(new THREE.AmbientLight(0xffffff, 0.12)); // ✅ a touch more fill

      const sunLight = new THREE.DirectionalLight(0xffffff, 1.35); // ✅ slightly stronger sun
      sunLight.position.set(5, 1.5, 2.5);
      scene.add(sunLight);

      // ---------------- Helpers: fallback texture + safe loading ----------------
      function make1x1DataTextureRGBA(r, g, b, a, colorSpace = THREE.SRGBColorSpace) {
        const data = new Uint8Array([r, g, b, a]);
        const tex = new THREE.DataTexture(data, 1, 1);
        tex.needsUpdate = true;
        tex.colorSpace = colorSpace;
        tex.magFilter = THREE.LinearFilter;
        tex.minFilter = THREE.LinearMipmapLinearFilter;
        tex.generateMipmaps = true;
        tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        return tex;
      }

      const FALLBACK_BLACK = make1x1DataTextureRGBA(0, 0, 0, 255, THREE.SRGBColorSpace);
      const FALLBACK_WHITE = make1x1DataTextureRGBA(255, 255, 255, 255, THREE.SRGBColorSpace);

      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin("anonymous");

      function loadTextureOrFallback(url, { colorSpace = THREE.SRGBColorSpace, fallback = FALLBACK_BLACK } = {}) {
        // Start with fallback immediately so nothing crashes / flashes “error”
        let tex = fallback;
        // Then try loading real texture and replace the reference later
        loader.load(
          url,
          (t) => {
            t.colorSpace = colorSpace;
            t.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
            t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
            tex = t;
          },
          undefined,
          () => {
            // Keep fallback; no throw
            console.warn("Texture failed to load:", url);
          }
        );
        return () => tex; // getter so uniforms always see latest
      }

      // ---------------- Textures (remote, but safe) ----------------
      const TEX = {
        day:    "https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg",
        night:  "https://threejs.org/examples/textures/planets/earth_lights_2048.png",
        spec:   "https://threejs.org/examples/textures/planets/earth_specular_2048.jpg",
        clouds: "https://threejs.org/examples/textures/planets/earth_clouds_1024.png"
      };

      // Use getters so if a texture finishes loading later, the shader picks it up
      const getDayMap    = loadTextureOrFallback(TEX.day,    { colorSpace: THREE.SRGBColorSpace, fallback: FALLBACK_BLACK });
      const getNightMap  = loadTextureOrFallback(TEX.night,  { colorSpace: THREE.SRGBColorSpace, fallback: FALLBACK_BLACK });
      const getSpecMap   = loadTextureOrFallback(TEX.spec,   { colorSpace: THREE.NoColorSpace,   fallback: FALLBACK_WHITE }); // spec is data
      const getCloudMap  = loadTextureOrFallback(TEX.clouds, { colorSpace: THREE.SRGBColorSpace, fallback: FALLBACK_BLACK });

      // ---------------- Procedural Stars (NO external texture => NO texture error) ----------------
      function makeStarfieldCanvasTexture(w = 1024, h = 512) {
        const c = document.createElement("canvas");
        c.width = w; c.height = h;
        const ctx = c.getContext("2d", { alpha: false });

        // background
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, w, h);

        // stars
        const starCount = 2200;
        for (let i = 0; i < starCount; i++) {
          const x = Math.random() * w;
          const y = Math.random() * h;
          const r = Math.random() < 0.92 ? (Math.random() * 1.2 + 0.2) : (Math.random() * 2.0 + 0.8);
          const a = Math.random() * 0.65 + 0.25;
          const tint = Math.random();
          // slight color variety
          const col =
            tint < 0.10 ? `rgba(180,210,255,${a})` :
            tint < 0.18 ? `rgba(255,220,190,${a})` :
                          `rgba(255,255,255,${a})`;
          ctx.fillStyle = col;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }

        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
        return tex;
      }

      {
        const starTex = makeStarfieldCanvasTexture();
        const starGeo = new THREE.SphereGeometry(90, 64, 64);
        const starMat = new THREE.MeshBasicMaterial({ map: starTex, side: THREE.BackSide });
        scene.add(new THREE.Mesh(starGeo, starMat));
      }

      // ---------------- Globe parts ----------------
      const earthRadius = 1.0;
      const SEG = 96;

      // Earth base shader (improved continent definition via contrast)
      const earthUniforms = {
        dayMap:    { value: FALLBACK_BLACK },
        specMap:   { value: FALLBACK_WHITE },
        sunDir:    { value: new THREE.Vector3(1, 0, 0) },
        cameraPos: { value: new THREE.Vector3() },
        contrast:  { value: 1.18 },  // ✅ more defined land/ocean separation
        clarity:   { value: 0.08 }   // ✅ subtle micro-boost (safe, not crunchy)
      };

      const earthMat = new THREE.ShaderMaterial({
        uniforms: earthUniforms,
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          void main() {
            vUv = uv;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vPosW = worldPos.xyz;
            vNormalW = normalize(mat3(modelMatrix) * normal);
            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `,
        fragmentShader: `
          precision highp float;
          uniform sampler2D dayMap;
          uniform sampler2D specMap;
          uniform vec3 sunDir;
          uniform vec3 cameraPos;
          uniform float contrast;
          uniform float clarity;

          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;

          vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
          vec3 linearToSrgb(vec3 c){ return pow(max(c, 0.0), vec3(1.0/2.2)); }

          vec3 applyContrast(vec3 c, float k){
            // k=1 no change; >1 increases contrast around mid-gray
            return (c - 0.5) * k + 0.5;
          }

          void main() {
            vec3 N = normalize(vNormalW);
            vec3 L = normalize(sunDir);
            vec3 V = normalize(cameraPos - vPosW);

            vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
            float specMask = texture2D(specMap, vUv).r;

            float ndl = dot(N, L);
            float dayAmt = smoothstep(-0.05, 0.15, ndl);

            // Night base
            vec3 nightBase = dayCol * 0.08;

            // Boost day clarity slightly (only on dayside)
            vec3 dayBoost = applyContrast(dayCol, contrast);
            dayBoost = mix(dayBoost, dayBoost * 1.06, clarity);

            vec3 col = mix(nightBase, dayBoost, dayAmt);

            vec3 H = normalize(L + V);
            float spec = pow(max(dot(N, H), 0.0), 80.0) * specMask * 0.55 * dayAmt;
            col += vec3(spec);

            float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
            col += vec3(0.05, 0.09, 0.15) * rim * (0.25 + 0.75 * dayAmt);

            gl_FragColor = vec4(linearToSrgb(col), 1.0);
          }
        `
      });

      const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);
      scene.add(earth);

      // Night lights mesh (additive) — blooms
      const lightsUniforms = {
        nightMap: { value: FALLBACK_BLACK },
        sunDir:   { value: new THREE.Vector3(1, 0, 0) },
        gain:     { value: 2.8 } // your upgraded value
      };

      const nightLights = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
        new THREE.ShaderMaterial({
          uniforms: lightsUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            void main(){
              vUv = uv;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform sampler2D nightMap;
            uniform vec3 sunDir;
            uniform float gain;
            varying vec2 vUv;
            varying vec3 vNormalW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);
              float nightAmt = 1.0 - dayAmt;

              vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
              float mask = smoothstep(0.05, 0.35, nightAmt);

              vec3 col = lights * mask;
              float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
              gl_FragColor = vec4(linearToSrgb(col), a);
            }
          `
        })
      );
      scene.add(nightLights);

      // Cloud shadows (multiply)
      const cloudShadow = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
        new THREE.MeshBasicMaterial({
          map: FALLBACK_BLACK,
          color: 0x000000,
          transparent: true,
          opacity: 0.28,
          blending: THREE.MultiplyBlending,
          depthWrite: false
        })
      );
      scene.add(cloudShadow);

      // Clouds (visible)
      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
        new THREE.MeshLambertMaterial({
          map: FALLBACK_BLACK,
          transparent: true,
          opacity: 0.85,
          depthWrite: false
        })
      );
      scene.add(clouds);

      // Atmosphere rim — blooms
      const atmoUniforms = {
        sunDir:    { value: new THREE.Vector3(1, 0, 0) },
        cameraPos: { value: new THREE.Vector3() },
        intensity: { value: 0.95 } // ✅ slightly reduced haze vs before
      };

      const atmosphere = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
        new THREE.ShaderMaterial({
          uniforms: atmoUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide,
          vertexShader: `
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main() {
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            uniform float intensity;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            void main() {
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
              float daySide = smoothstep(-0.15, 0.25, dot(N, L));

              vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide) * intensity;
              float alpha = rim * (0.16 + 0.55 * daySide) * intensity;

              gl_FragColor = vec4(col, alpha);
            }
          `
        })
      );
      scene.add(atmosphere);

      // ---------------- Rotation group ----------------
      const globe = new THREE.Group();
      scene.remove(earth, nightLights, cloudShadow, clouds, atmosphere);
      globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
      scene.add(globe);

      // ---------------- Selective Bloom ----------------
      const BLOOM_LAYER = 1;
      const bloomLayer = new THREE.Layers();
      bloomLayer.set(BLOOM_LAYER);

      nightLights.layers.enable(BLOOM_LAYER);
      atmosphere.layers.enable(BLOOM_LAYER);

      const darkMaterial = new THREE.MeshBasicMaterial({ color: "black" });
      const materials = new Map();

      function darkenNonBloom(obj) {
        if (obj.isMesh && !bloomLayer.test(obj.layers)) {
          materials.set(obj.uuid, obj.material);
          obj.material = darkMaterial;
        }
      }
      function restoreMaterial(obj) {
        if (materials.has(obj.uuid)) {
          obj.material = materials.get(obj.uuid);
          materials.delete(obj.uuid);
        }
      }

      const renderScene = new RenderPass(scene, camera);

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(innerWidth, innerHeight),
        1.25, // strength
        0.85, // radius
        0.18  // threshold
      );

      const bloomComposer = new EffectComposer(renderer);
      bloomComposer.renderToScreen = false;
      bloomComposer.addPass(renderScene);
      bloomComposer.addPass(bloomPass);

      const finalPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          bloomTexture: { value: bloomComposer.renderTarget2.texture }
        },
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform sampler2D bloomTexture;
          varying vec2 vUv;
          void main(){
            vec4 base = texture2D(tDiffuse, vUv);
            vec4 bloom = texture2D(bloomTexture, vUv);
            gl_FragColor = base + bloom;
          }
        `
      });

      const finalComposer = new EffectComposer(renderer);
      finalComposer.addPass(renderScene);
      finalComposer.addPass(finalPass);
      finalComposer.addPass(new OutputPass());

      function renderBloom() {
        scene.traverse(darkenNonBloom);
        bloomComposer.render();
        scene.traverse(restoreMaterial);
      }

      // ---------------- Touch drag + inertia ----------------
      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      let velY = 0;
      let velX = 0;

      const AUTO_SPIN = 0.0013;
      const DRAG_SENS = 0.0065;
      const PITCH_SENS = 0.0048;
      const DAMPING = 0.92;
      const MAX_PITCH = 0.55;

      function getPoint(e) {
        if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }

      function pointerDown(e) {
        dragging = true;
        const p = getPoint(e);
        lastX = p.x;
        lastY = p.y;
      }

      function pointerMove(e) {
        if (!dragging) return;
        const p = getPoint(e);
        const dx = p.x - lastX;
        const dy = p.y - lastY;
        lastX = p.x;
        lastY = p.y;

        globe.rotation.y += dx * DRAG_SENS;
        globe.rotation.x += dy * PITCH_SENS;
        globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));

        velY = dx * DRAG_SENS;
        velX = dy * PITCH_SENS;
      }

      function pointerUp() {
        dragging = false;
      }

      const el = renderer.domElement;
      el.addEventListener("touchstart", pointerDown, { passive: true });
      el.addEventListener("touchmove", pointerMove, { passive: true });
      el.addEventListener("touchend", pointerUp, { passive: true });
      el.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      // ---------------- Animation ----------------
      const sunDrift = 0.00005;
      const cloudSpin = 0.0020;

      // Set initial textures (getters update as loads finish)
      function syncTextures() {
        earthUniforms.dayMap.value = getDayMap();
        earthUniforms.specMap.value = getSpecMap();
        lightsUniforms.nightMap.value = getNightMap();

        const cm = getCloudMap();
        cloudShadow.material.map = cm;
        clouds.material.map = cm;
        cloudShadow.material.needsUpdate = true;
        clouds.material.needsUpdate = true;
      }

      function animate() {
        requestAnimationFrame(animate);

        syncTextures();

        clouds.rotation.y += cloudSpin;
        cloudShadow.rotation.y += cloudSpin + 0.00015;

        if (!dragging) {
          globe.rotation.y += AUTO_SPIN;
          globe.rotation.y += velY;
          globe.rotation.x += velX;
          velY *= DAMPING;
          velX *= DAMPING;
          globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));
        }

        sunLight.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), sunDrift);
        const sunDir = sunLight.position.clone().normalize();

        earthUniforms.sunDir.value.copy(sunDir);
        earthUniforms.cameraPos.value.copy(camera.position);

        lightsUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.cameraPos.value.copy(camera.position);

        renderBloom();
        finalComposer.render();
      }
      animate();

      // ---------------- Resize ----------------
      addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);

        bloomComposer.setSize(innerWidth, innerHeight);
        finalComposer.setSize(innerWidth, innerHeight);
        bloomPass.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
