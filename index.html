<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>E.D.E.N. Globe</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        background: #000;
        overflow: hidden;
        touch-action: none;
      }
      canvas {
        display: block;
        width: 100vw !important;
        height: 100vh !important;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

      import { EffectComposer } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/RenderPass.js";
      import { ShaderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/ShaderPass.js";
      import { OutputPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/OutputPass.js";
      import { UnrealBloomPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js";

      // ---------------- Scene / Camera / Renderer ----------------
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 5000);
      camera.position.set(0, 0, 4.2);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      document.body.appendChild(renderer.domElement);

      // ---------------- Lights ----------------
      scene.add(new THREE.AmbientLight(0xffffff, 0.10));

      const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
      sunLight.position.set(5, 1.5, 2.5);
      scene.add(sunLight);

      // ---------------- Textures ----------------
      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin("anonymous");

      const TEX = {
        day:    "https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg",
        night:  "https://threejs.org/examples/textures/planets/earth_lights_2048.png",
        spec:   "https://threejs.org/examples/textures/planets/earth_specular_2048.jpg",
        clouds: "https://threejs.org/examples/textures/planets/earth_clouds_1024.png",
        stars:  "https://threejs.org/examples/textures/galaxy_starfield.png"
      };

      const dayMap   = loader.load(TEX.day);
      const nightMap = loader.load(TEX.night);
      const specMap  = loader.load(TEX.spec);
      const cloudMap = loader.load(TEX.clouds);
      const starMap  = loader.load(TEX.stars);

      dayMap.colorSpace = THREE.SRGBColorSpace;
      nightMap.colorSpace = THREE.SRGBColorSpace;
      cloudMap.colorSpace = THREE.SRGBColorSpace;
      starMap.colorSpace = THREE.SRGBColorSpace;
      specMap.colorSpace = THREE.SRGBColorSpace;

      [dayMap, nightMap, specMap, cloudMap, starMap].forEach(t => {
        t.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
        t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
      });

      // ---------------- Stars ----------------
      {
        const starGeo = new THREE.SphereGeometry(90, 64, 64);
        const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
        scene.add(new THREE.Mesh(starGeo, starMat));
      }

      // ---------------- Globe parts ----------------
      const earthRadius = 1.0;
      const SEG = 96;

      // Earth base shader (no direct night lights here)
      const earthUniforms = {
        dayMap:    { value: dayMap },
        specMap:   { value: specMap },
        sunDir:    { value: new THREE.Vector3(1, 0, 0) },
        cameraPos: { value: new THREE.Vector3() }
      };

      const earthMat = new THREE.ShaderMaterial({
        uniforms: earthUniforms,
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;
          void main() {
            vUv = uv;
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vPosW = worldPos.xyz;
            vNormalW = normalize(mat3(modelMatrix) * normal);
            gl_Position = projectionMatrix * viewMatrix * worldPos;
          }
        `,
        fragmentShader: `
          precision highp float;
          uniform sampler2D dayMap;
          uniform sampler2D specMap;
          uniform vec3 sunDir;
          uniform vec3 cameraPos;

          varying vec2 vUv;
          varying vec3 vNormalW;
          varying vec3 vPosW;

          vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
          vec3 linearToSrgb(vec3 c){ return pow(max(c, 0.0), vec3(1.0/2.2)); }

          void main() {
            vec3 N = normalize(vNormalW);
            vec3 L = normalize(sunDir);
            vec3 V = normalize(cameraPos - vPosW);

            vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
            float specMask = texture2D(specMap, vUv).r;

            float ndl = dot(N, L);
            float dayAmt = smoothstep(-0.05, 0.15, ndl);

            vec3 nightBase = dayCol * 0.08;
            vec3 col = mix(nightBase, dayCol, dayAmt);

            vec3 H = normalize(L + V);
            float spec = pow(max(dot(N, H), 0.0), 80.0) * specMask * 0.50 * dayAmt;
            col += vec3(spec);

            float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
            col += vec3(0.06, 0.10, 0.16) * rim * (0.30 + 0.70 * dayAmt);

            gl_FragColor = vec4(linearToSrgb(col), 1.0);
          }
        `
      });

      const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);
      scene.add(earth);

      // Night lights mesh (additive) — blooms
      const lightsUniforms = {
        nightMap: { value: nightMap },
        sunDir:   { value: new THREE.Vector3(1, 0, 0) },
        gain:     { value: 2.8 } // ✅ upgraded from 2.4
      };

      const nightLights = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
        new THREE.ShaderMaterial({
          uniforms: lightsUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            void main(){
              vUv = uv;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform sampler2D nightMap;
            uniform vec3 sunDir;
            uniform float gain;
            varying vec2 vUv;
            varying vec3 vNormalW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            void main(){
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);
              float nightAmt = 1.0 - dayAmt;

              vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
              float mask = smoothstep(0.05, 0.35, nightAmt);

              vec3 col = lights * mask;
              float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
              gl_FragColor = vec4(linearToSrgb(col), a);
            }
          `
        })
      );
      scene.add(nightLights);

      // Cloud shadows (multiply)
      const cloudShadow = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
        new THREE.MeshBasicMaterial({
          map: cloudMap,
          color: 0x000000,
          transparent: true,
          opacity: 0.28,
          blending: THREE.MultiplyBlending,
          depthWrite: false
        })
      );
      scene.add(cloudShadow);

      // Clouds (visible)
      const clouds = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
        new THREE.MeshLambertMaterial({
          map: cloudMap,
          transparent: true,
          opacity: 0.85,
          depthWrite: false
        })
      );
      scene.add(clouds);

      // Atmosphere rim — blooms
      const atmoUniforms = {
        sunDir:    { value: new THREE.Vector3(1, 0, 0) },
        cameraPos: { value: new THREE.Vector3() }
      };

      const atmosphere = new THREE.Mesh(
        new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
        new THREE.ShaderMaterial({
          uniforms: atmoUniforms,
          transparent: true,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide,
          vertexShader: `
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main() {
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            precision highp float;
            uniform vec3 sunDir;
            uniform vec3 cameraPos;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            void main() {
              vec3 N = normalize(vNormalW);
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
              float daySide = smoothstep(-0.15, 0.25, dot(N, L));

              vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
              float alpha = rim * (0.18 + 0.62 * daySide);

              gl_FragColor = vec4(col, alpha);
            }
          `
        })
      );
      scene.add(atmosphere);

      // ---------------- Rotation group ----------------
      const globe = new THREE.Group();
      scene.remove(earth, nightLights, cloudShadow, clouds, atmosphere);
      globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
      scene.add(globe);

      // ---------------- Selective Bloom ----------------
      const BLOOM_LAYER = 1;
      const bloomLayer = new THREE.Layers();
      bloomLayer.set(BLOOM_LAYER);

      nightLights.layers.enable(BLOOM_LAYER);
      atmosphere.layers.enable(BLOOM_LAYER);

      const darkMaterial = new THREE.MeshBasicMaterial({ color: "black" });
      const materials = new Map();

      function darkenNonBloom(obj) {
        if (obj.isMesh && !bloomLayer.test(obj.layers)) {
          materials.set(obj.uuid, obj.material);
          obj.material = darkMaterial;
        }
      }
      function restoreMaterial(obj) {
        if (materials.has(obj.uuid)) {
          obj.material = materials.get(obj.uuid);
          materials.delete(obj.uuid);
        }
      }

      const renderScene = new RenderPass(scene, camera);

      // ✅ Upgraded bloom preset:
      // strength = 1.25, threshold = 0.18
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(innerWidth, innerHeight),
        1.25, // strength
        0.85, // radius
        0.18  // threshold
      );

      const bloomComposer = new EffectComposer(renderer);
      bloomComposer.renderToScreen = false;
      bloomComposer.addPass(renderScene);
      bloomComposer.addPass(bloomPass);

      const finalPass = new ShaderPass({
        uniforms: {
          tDiffuse: { value: null },
          bloomTexture: { value: bloomComposer.renderTarget2.texture }
        },
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform sampler2D bloomTexture;
          varying vec2 vUv;
          void main(){
            vec4 base = texture2D(tDiffuse, vUv);
            vec4 bloom = texture2D(bloomTexture, vUv);
            gl_FragColor = base + bloom;
          }
        `
      });

      const finalComposer = new EffectComposer(renderer);
      finalComposer.addPass(renderScene);
      finalComposer.addPass(finalPass);
      finalComposer.addPass(new OutputPass());

      function renderBloom() {
        scene.traverse(darkenNonBloom);
        bloomComposer.render();
        scene.traverse(restoreMaterial);
      }

      // ---------------- Touch drag + inertia ----------------
      let dragging = false;
      let lastX = 0;
      let lastY = 0;

      let velY = 0;
      let velX = 0;

      const AUTO_SPIN = 0.0013;
      const DRAG_SENS = 0.0065;
      const PITCH_SENS = 0.0048;
      const DAMPING = 0.92;
      const MAX_PITCH = 0.55;

      function getPoint(e) {
        if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
        return { x: e.clientX, y: e.clientY };
      }

      function pointerDown(e) {
        dragging = true;
        const p = getPoint(e);
        lastX = p.x;
        lastY = p.y;
      }

      function pointerMove(e) {
        if (!dragging) return;
        const p = getPoint(e);
        const dx = p.x - lastX;
        const dy = p.y - lastY;
        lastX = p.x;
        lastY = p.y;

        globe.rotation.y += dx * DRAG_SENS;
        globe.rotation.x += dy * PITCH_SENS;
        globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));

        velY = dx * DRAG_SENS;
        velX = dy * PITCH_SENS;
      }

      function pointerUp() {
        dragging = false;
      }

      const el = renderer.domElement;
      el.addEventListener("touchstart", pointerDown, { passive: true });
      el.addEventListener("touchmove", pointerMove, { passive: true });
      el.addEventListener("touchend", pointerUp, { passive: true });
      el.addEventListener("mousedown", pointerDown);
      window.addEventListener("mousemove", pointerMove);
      window.addEventListener("mouseup", pointerUp);

      // ---------------- Animation ----------------
      const sunDrift = 0.00005;
      const cloudSpin = 0.0020;

      function animate() {
        requestAnimationFrame(animate);

        clouds.rotation.y += cloudSpin;
        cloudShadow.rotation.y += cloudSpin + 0.00015;

        if (!dragging) {
          globe.rotation.y += AUTO_SPIN;
          globe.rotation.y += velY;
          globe.rotation.x += velX;
          velY *= DAMPING;
          velX *= DAMPING;
          globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));
        }

        sunLight.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), sunDrift);
        const sunDir = sunLight.position.clone().normalize();

        earthUniforms.sunDir.value.copy(sunDir);
        earthUniforms.cameraPos.value.copy(camera.position);

        lightsUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.sunDir.value.copy(sunDir);
        atmoUniforms.cameraPos.value.copy(camera.position);

        renderBloom();
        finalComposer.render();
      }
      animate();

      // ---------------- Resize ----------------
      addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);

        bloomComposer.setSize(innerWidth, innerHeight);
        finalComposer.setSize(innerWidth, innerHeight);
        bloomPass.setSize(innerWidth, innerHeight);
      });
    </script>
  </body>
</html>
