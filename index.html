<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>E.D.E.N. Globe</title>

    <style>
      html, body { height:100%; margin:0; background:#000; overflow:hidden; touch-action:none; }
      canvas { display:block; width:100vw !important; height:100vh !important; }

      /* Debug HUD (auto-hides; tap anywhere to toggle) */
      #hud{
        position:fixed; left:10px; bottom:10px; z-index:9999;
        font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial;
        font-size:12px; line-height:1.25;
        color:#d7d7d7; background:rgba(0,0,0,0.55);
        border:1px solid rgba(255,255,255,0.12);
        border-radius:10px; padding:10px 12px; max-width:88vw;
        backdrop-filter:blur(6px);
        user-select:none;
      }
      #hud b{ color:#fff; }
      #errors{ margin-top:8px; color:#ff9c9c; white-space:pre-wrap; display:none; }
      #hint{ margin-top:6px; color:#a9c7ff; }
    </style>

    <!-- Import map so GitHub Pages resolves "three" + "three/addons/" correctly -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
  </head>

  <body>
    <div id="hud">
      <div><b>Status:</b> <span id="status">Booting…</span></div>
      <div id="hint">Tap anywhere to toggle this HUD.</div>
      <div id="errors"></div>
    </div>

    <script type="module">
      const hud = document.getElementById("hud");
      const statusEl = document.getElementById("status");
      const errorsEl = document.getElementById("errors");

      function setHUD(status, details=""){
        statusEl.textContent = status;
        errorsEl.style.display = details ? "block" : "none";
        errorsEl.textContent = details || "";
      }
      function showError(msg){
        errorsEl.style.display = "block";
        errorsEl.textContent += (errorsEl.textContent ? "\n\n" : "") + msg;
        statusEl.textContent = "Error (see panel)";
      }
      window.addEventListener("error", (e) => showError("JS Error:\n" + (e.message || e.error || e)));
      window.addEventListener("unhandledrejection", (e) => showError("Promise Rejection:\n" + (e.reason?.message || e.reason || e)));

      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // ----------------- TUNING (your taste knobs) -----------------
      const BLOOM_STRENGTH = 1.15;   // more/less glow
      const BLOOM_THRESHOLD = 0.10;  // higher = glow only brightest pixels
      const BLOOM_RADIUS = 0.85;

      const LIGHTS_GAIN = 2.4;       // brighter city lights

      // Continents definition:
      const NORMAL_SCALE = 0.95;     // 0.7–1.2 (higher = more relief)
      const DAY_CONTRAST = 1.06;     // 1.00–1.12 (higher = punchier land)

      // Super Tunnel:
      const TUNNEL_ON = true;
      const TUNNEL_DIR = new THREE.Vector3(0.15, 0.92, 0.35).normalize(); // rotate this to align your E.D.E.N axis
      const TUNNEL_RADIUS = 0.035;   // thickness
      const TUNNEL_GLOW = 1.0;       // brightness

      // Motion:
      const AUTO_SPIN = 0.0013;
      const DRAG_SENS = 0.0065;
      const PITCH_SENS = 0.0048;
      const DAMPING = 0.92;
      const MAX_PITCH = 0.55;

      // ----------------- Helpers -----------------
      function makeFallbackTexture(hex = "#3a3a3a"){
        const c = document.createElement("canvas");
        c.width = c.height = 2;
        const ctx = c.getContext("2d");
        ctx.fillStyle = hex;
        ctx.fillRect(0,0,2,2);
        const t = new THREE.CanvasTexture(c);
        t.needsUpdate = true;
        return t;
      }

      function loadTexture(url){
        return new Promise((resolve, reject) => {
          const loader = new THREE.TextureLoader();
          loader.setCrossOrigin("anonymous");
          loader.load(url, tex => resolve(tex), undefined, err => reject(err));
        });
      }

      async function loadFirst(label, urls){
        for (const u of urls){
          try{
            const tex = await loadTexture(u);
            return { tex, used: u };
          } catch(e){
            // try next
          }
        }
        // fallback
        return { tex: makeFallbackTexture("#222"), used: "(fallback)" };
      }

      function applyTexSettings(tex, { colorSpace=null, maxAniso=1, linear=true } = {}){
        if (colorSpace) tex.colorSpace = colorSpace;
        tex.anisotropy = maxAniso;
        tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        if (linear){
          tex.minFilter = THREE.LinearMipmapLinearFilter;
          tex.magFilter = THREE.LinearFilter;
        }
      }

      function quatFromDir(dir){
        const q = new THREE.Quaternion();
        q.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
        return q;
      }

      try{
        // ---------- Scene / Camera / Renderer ----------
        setHUD("Booting…");
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
        camera.position.set(0, 0, 4.2);

        const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:"high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(innerWidth, innerHeight);
        renderer.setClearColor(0x000000, 1);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        const maxAniso = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;

        // ---------- Lights ----------
        scene.add(new THREE.AmbientLight(0xffffff, 0.10));
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.25);
        sunLight.position.set(5, 1.5, 2.5);
        scene.add(sunLight);

        // ---------- Texture URLs (multi-CDN, resilient) ----------
        const cdnJS = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r161/examples/textures/";
        const cdn3J = "https://threejs.org/examples/textures/";
        const cdnGH = "https://raw.githubusercontent.com/mrdoob/three.js/r161/examples/textures/";

        setHUD("Loading textures…");

        const dayRes = await loadFirst("day", [
          cdnJS+"planets/earth_atmos_2048.jpg",
          cdn3J+"planets/earth_atmos_2048.jpg",
          cdnGH+"planets/earth_atmos_2048.jpg"
        ]);

        const nightRes = await loadFirst("night", [
          cdnJS+"planets/earth_lights_2048.png",
          cdn3J+"planets/earth_lights_2048.png",
          cdnGH+"planets/earth_lights_2048.png"
        ]);

        const specRes = await loadFirst("spec", [
          cdnJS+"planets/earth_specular_2048.jpg",
          cdn3J+"planets/earth_specular_2048.jpg",
          cdnGH+"planets/earth_specular_2048.jpg"
        ]);

        const normalRes = await loadFirst("normal", [
          cdnJS+"planets/earth_normal_2048.jpg",
          cdn3J+"planets/earth_normal_2048.jpg",
          cdnGH+"planets/earth_normal_2048.jpg"
        ]);

        const cloudRes = await loadFirst("cloud", [
          cdnJS+"planets/earth_clouds_1024.png",
          cdn3J+"planets/earth_clouds_1024.png",
          cdnGH+"planets/earth_clouds_1024.png"
        ]);

        const starsRes = await loadFirst("stars", [
          cdnJS+"galaxy_starfield.png",
          cdn3J+"galaxy_starfield.png",
          cdnGH+"galaxy_starfield.png"
        ]);

        const dayMap = dayRes.tex;
        const nightMap = nightRes.tex;
        const specMap = specRes.tex;
        const normalMap = normalRes.tex;
        const cloudMap = cloudRes.tex;
        const starMap = starsRes.tex;

        applyTexSettings(dayMap,   { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(nightMap, { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(cloudMap, { colorSpace: THREE.SRGBColorSpace, maxAniso });
        applyTexSettings(starMap,  { colorSpace: THREE.SRGBColorSpace, maxAniso });

        // Spec + normal should stay linear:
        applyTexSettings(specMap,   { colorSpace: THREE.NoColorSpace, maxAniso });
        applyTexSettings(normalMap, { colorSpace: THREE.NoColorSpace, maxAniso });

        setHUD(
          "Running",
          `day:   ${dayRes.used}\nnight: ${nightRes.used}\nspec:  ${specRes.used}\nnormal:${normalRes.used}\ncloud: ${cloudRes.used}\nstars: ${starsRes.used}`
        );

        // Auto-hide HUD after 2.2s; tap anywhere to toggle.
        setTimeout(() => { hud.style.display = "none"; }, 2200);
        window.addEventListener("click", () => {
          hud.style.display = (hud.style.display === "none") ? "block" : "none";
        });

        // ---------------- Stars ----------------
        {
          const starGeo = new THREE.SphereGeometry(90, 64, 64);
          const starMat = new THREE.MeshBasicMaterial({ map: starMap, side: THREE.BackSide });
          scene.add(new THREE.Mesh(starGeo, starMat));
        }

        // ---------------- Globe parts ----------------
        const earthRadius = 1.0;
        const SEG = 96;

        // Earth base shader with normal map for sharper continents
        const earthUniforms = {
          dayMap:      { value: dayMap },
          specMap:     { value: specMap },
          normalMap:   { value: normalMap },
          normalScale: { value: NORMAL_SCALE },
          dayContrast: { value: DAY_CONTRAST },
          sunDir:      { value: new THREE.Vector3(1,0,0) },
          cameraPos:   { value: new THREE.Vector3() }
        };

        const earthMat = new THREE.ShaderMaterial({
          uniforms: earthUniforms,
          vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;
            void main(){
              vUv = uv;
              vec4 worldPos = modelMatrix * vec4(position, 1.0);
              vPosW = worldPos.xyz;
              vNormalW = normalize(mat3(modelMatrix) * normal);
              gl_Position = projectionMatrix * viewMatrix * worldPos;
            }
          `,
          fragmentShader: `
            #extension GL_OES_standard_derivatives : enable
            precision highp float;

            uniform sampler2D dayMap;
            uniform sampler2D specMap;
            uniform sampler2D normalMap;
            uniform float normalScale;
            uniform float dayContrast;

            uniform vec3 sunDir;
            uniform vec3 cameraPos;

            varying vec2 vUv;
            varying vec3 vNormalW;
            varying vec3 vPosW;

            vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
            vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

            // Derivative-based normal mapping (no tangents needed)
            vec3 perturbNormal(vec3 surfPos, vec3 surfNorm, vec2 uv){
              vec3 map = texture2D(normalMap, uv).xyz * 2.0 - 1.0;
              map.xy *= normalScale;

              vec3 dp1 = dFdx(surfPos);
              vec3 dp2 = dFdy(surfPos);
              vec2 duv1 = dFdx(uv);
              vec2 duv2 = dFdy(uv);

              vec3 dp2perp = cross(dp2, surfNorm);
              vec3 dp1perp = cross(surfNorm, dp1);
              vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
              vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

              float invmax = inversesqrt(max(dot(T,T), dot(B,B)));
              mat3 TBN = mat3(T*invmax, B*invmax, surfNorm);
              return normalize(TBN * map);
            }

            void main(){
              vec3 L = normalize(sunDir);
              vec3 V = normalize(cameraPos - vPosW);

              vec3 N0 = normalize(vNormalW);
              vec3 N = perturbNormal(vPosW, N0, vUv);

              vec3 dayCol = srgbToLinear(texture2D(dayMap, vUv).rgb);
              // extra punch / definition
              dayCol = pow(dayCol, vec3(1.0/dayContrast));

              float specMask = texture2D(specMap, vUv).r;

              float ndl = dot(N, L);
              float dayAmt = smoothstep(-0.05, 0.15, ndl);

              vec3 nightBase = dayCol * 0.09;
              vec3 col = mix(nightBase, dayCol, dayAmt);

              vec3 H = normalize(L + V);
              float spec = pow(max(dot(N, H), 0.0), 95.0) * specMask * 0.55 * dayAmt;
              col += vec3(spec);

              float rim = pow(1.0 - max(dot(N, V), 0.0), 2.2);
              col += vec3(0.06, 0.10, 0.18) * rim * (0.30 + 0.70 * dayAmt);

              gl_FragColor = vec4(linearToSrgb(col), 1.0);
            }
          `
        });

        const earth = new THREE.Mesh(new THREE.SphereGeometry(earthRadius, SEG, SEG), earthMat);
        scene.add(earth);

        // Night lights mesh (additive) — blooms
        const lightsUniforms = {
          nightMap: { value: nightMap },
          sunDir:   { value: new THREE.Vector3(1,0,0) },
          gain:     { value: LIGHTS_GAIN }
        };

        const nightLights = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.001, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: lightsUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexShader: `
              varying vec2 vUv;
              varying vec3 vNormalW;
              void main(){
                vUv = uv;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform sampler2D nightMap;
              uniform vec3 sunDir;
              uniform float gain;
              varying vec2 vUv;
              varying vec3 vNormalW;

              vec3 srgbToLinear(vec3 c){ return pow(c, vec3(2.2)); }
              vec3 linearToSrgb(vec3 c){ return pow(max(c,0.0), vec3(1.0/2.2)); }

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);

                float ndl = dot(N, L);
                float dayAmt = smoothstep(-0.05, 0.15, ndl);
                float nightAmt = 1.0 - dayAmt;

                vec3 lights = srgbToLinear(texture2D(nightMap, vUv).rgb) * gain;
                float mask = smoothstep(0.05, 0.35, nightAmt);

                vec3 col = lights * mask;
                float a = clamp(max(max(col.r, col.g), col.b), 0.0, 1.0);
                gl_FragColor = vec4(linearToSrgb(col), a);
              }
            `
          })
        );
        scene.add(nightLights);

        // Cloud shadow (multiply)
        const cloudShadow = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.0015, SEG, SEG),
          new THREE.MeshBasicMaterial({
            map: cloudMap,
            color: 0x000000,
            transparent: true,
            opacity: 0.28,
            blending: THREE.MultiplyBlending,
            depthWrite: false
          })
        );
        scene.add(cloudShadow);

        // Clouds (visible)
        const clouds = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.012, SEG, SEG),
          new THREE.MeshLambertMaterial({
            map: cloudMap,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
          })
        );
        scene.add(clouds);

        // Atmosphere rim — blooms
        const atmoUniforms = {
          sunDir:    { value: new THREE.Vector3(1,0,0) },
          cameraPos: { value: new THREE.Vector3() }
        };

        const atmosphere = new THREE.Mesh(
          new THREE.SphereGeometry(earthRadius * 1.045, SEG, SEG),
          new THREE.ShaderMaterial({
            uniforms: atmoUniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide,
            vertexShader: `
              varying vec3 vNormalW;
              varying vec3 vPosW;
              void main(){
                vec4 worldPos = modelMatrix * vec4(position, 1.0);
                vPosW = worldPos.xyz;
                vNormalW = normalize(mat3(modelMatrix) * normal);
                gl_Position = projectionMatrix * viewMatrix * worldPos;
              }
            `,
            fragmentShader: `
              precision highp float;
              uniform vec3 sunDir;
              uniform vec3 cameraPos;
              varying vec3 vNormalW;
              varying vec3 vPosW;

              void main(){
                vec3 N = normalize(vNormalW);
                vec3 L = normalize(sunDir);
                vec3 V = normalize(cameraPos - vPosW);

                float rim = pow(1.0 - max(dot(N, V), 0.0), 3.2);
                float daySide = smoothstep(-0.15, 0.25, dot(N, L));

                vec3 col = vec3(0.20, 0.55, 1.00) * rim * (0.25 + 0.75 * daySide);
                float alpha = rim * (0.18 + 0.62 * daySide);
                gl_FragColor = vec4(col, alpha);
              }
            `
          })
        );
        scene.add(atmosphere);

        // ---------------- Super Tunnel (bloom-only) ----------------
        let tunnel = null;
        let tunnelUniforms = null;

        if (TUNNEL_ON){
          tunnelUniforms = {
            time: { value: 0.0 },
            glow: { value: TUNNEL_GLOW }
          };

          tunnel = new THREE.Mesh(
            new THREE.CylinderGeometry(TUNNEL_RADIUS, TUNNEL_RADIUS, 3.2, 64, 1, true),
            new THREE.ShaderMaterial({
              uniforms: tunnelUniforms,
              transparent: true,
              depthWrite: false,
              blending: THREE.AdditiveBlending,
              side: THREE.DoubleSide,
              vertexShader: `
                varying vec2 vUv;
                void main(){
                  vUv = uv;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
              `,
              fragmentShader: `
                precision highp float;
                uniform float time;
                uniform float glow;
                varying vec2 vUv;

                // Soft beam + animated bands
                void main(){
                  float x = vUv.x; // around
                  float y = vUv.y; // along

                  // Core beam intensity (soft)
                  float core = 0.55;

                  // Pulsing bands moving along tunnel
                  float bands = 0.5 + 0.5 * sin((y*18.0 - time*3.5) * 6.28318);
                  bands = smoothstep(0.35, 1.0, bands);

                  // Edge falloff around cylinder (fake)
                  float edge = smoothstep(0.0, 0.15, x) * smoothstep(0.0, 0.15, 1.0 - x);

                  float a = (core + 0.65*bands) * edge * glow;

                  vec3 col = vec3(0.15, 0.75, 1.0) * a;
                  gl_FragColor = vec4(col, a);
                }
              `
            })
          );

          // Align cylinder to your tunnel direction
          tunnel.quaternion.copy(quatFromDir(TUNNEL_DIR));
          // Slightly enlarge so it visually “pierces” outside atmosphere
          tunnel.scale.set(1.0, 1.2, 1.0);
        }

        // ---------------- Rotation group ----------------
        const globe = new THREE.Group();
        scene.remove(earth, nightLights, cloudShadow, clouds, atmosphere);
        globe.add(earth, nightLights, cloudShadow, clouds, atmosphere);
        if (tunnel) globe.add(tunnel);
        scene.add(globe);

        // ---------------- Selective Bloom ----------------
        const BLOOM_LAYER = 1;
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_LAYER);

        nightLights.layers.enable(BLOOM_LAYER);
        atmosphere.layers.enable(BLOOM_LAYER);
        if (tunnel) tunnel.layers.enable(BLOOM_LAYER);

        const darkMaterial = new THREE.MeshBasicMaterial({ color:"black" });
        const materials = new Map();

        function darkenNonBloom(obj){
          if (obj.isMesh && !bloomLayer.test(obj.layers)){
            materials.set(obj.uuid, obj.material);
            obj.material = darkMaterial;
          }
        }
        function restoreMaterial(obj){
          if (materials.has(obj.uuid)){
            obj.material = materials.get(obj.uuid);
            materials.delete(obj.uuid);
          }
        }

        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(innerWidth, innerHeight),
          BLOOM_STRENGTH,
          BLOOM_RADIUS,
          BLOOM_THRESHOLD
        );

        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderScene);
        bloomComposer.addPass(bloomPass);

        const finalPass = new ShaderPass({
          uniforms: {
            tDiffuse: { value: null },
            bloomTexture: { value: null }
          },
          vertexShader: `
            varying vec2 vUv;
            void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
          `,
          fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main(){
              vec4 base = texture2D(tDiffuse, vUv);
              vec4 bloom = texture2D(bloomTexture, vUv);
              gl_FragColor = base + bloom;
            }
          `
        });

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderScene);
        finalComposer.addPass(finalPass);
        finalComposer.addPass(new OutputPass());

        function renderBloom(){
          scene.traverse(darkenNonBloom);
          bloomComposer.render();
          finalPass.uniforms.bloomTexture.value = bloomComposer.readBuffer.texture;
          scene.traverse(restoreMaterial);
        }

        // ---------------- Touch drag + inertia ----------------
        let dragging=false, lastX=0, lastY=0, velY=0, velX=0;

        function getPoint(e){
          if (e.touches && e.touches.length) return { x:e.touches[0].clientX, y:e.touches[0].clientY };
          return { x:e.clientX, y:e.clientY };
        }
        function down(e){ dragging=true; const p=getPoint(e); lastX=p.x; lastY=p.y; }
        function move(e){
          if(!dragging) return;
          const p=getPoint(e);
          const dx=p.x-lastX, dy=p.y-lastY;
          lastX=p.x; lastY=p.y;

          globe.rotation.y += dx*DRAG_SENS;
          globe.rotation.x += dy*PITCH_SENS;
          globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));

          velY = dx*DRAG_SENS;
          velX = dy*PITCH_SENS;
        }
        function up(){ dragging=false; }

        const el = renderer.domElement;
        el.addEventListener("touchstart", down, { passive:true });
        el.addEventListener("touchmove", move, { passive:true });
        el.addEventListener("touchend", up, { passive:true });
        el.addEventListener("mousedown", down);
        window.addEventListener("mousemove", move);
        window.addEventListener("mouseup", up);

        // ---------------- Animation ----------------
        const sunDrift = 0.00005;
        const cloudSpin = 0.0020;

        let t0 = performance.now();

        function animate(){
          requestAnimationFrame(animate);

          const t = (performance.now() - t0) * 0.001;

          clouds.rotation.y += cloudSpin;
          cloudShadow.rotation.y += cloudSpin + 0.00015;

          if(!dragging){
            globe.rotation.y += AUTO_SPIN;
            globe.rotation.y += velY;
            globe.rotation.x += velX;
            velY *= DAMPING;
            velX *= DAMPING;
            globe.rotation.x = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, globe.rotation.x));
          }

          sunLight.position.applyAxisAngle(new THREE.Vector3(0,1,0), sunDrift);
          const sunDir = sunLight.position.clone().normalize();

          earthUniforms.sunDir.value.copy(sunDir);
          earthUniforms.cameraPos.value.copy(camera.position);

          lightsUniforms.sunDir.value.copy(sunDir);

          atmoUniforms.sunDir.value.copy(sunDir);
          atmoUniforms.cameraPos.value.copy(camera.position);

          if (tunnelUniforms) tunnelUniforms.time.value = t;

          renderBloom();
          finalComposer.render();
        }
        animate();

        addEventListener("resize", () => {
          camera.aspect = innerWidth/innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
          bloomComposer.setSize(innerWidth, innerHeight);
          finalComposer.setSize(innerWidth, innerHeight);
          bloomPass.setSize(innerWidth, innerHeight);
        });

      } catch (err){
        showError("Top-level error:\n" + (err?.stack || err?.message || err));
      }
    </script>
  </body>
</html>
